/**
 * Cache Operations Test Suite
 *
 * Comprehensive tests for Redis caching functionality including:
 * - Cache hit/miss scenarios
 * - ETag validation and conditional requests
 * - Cache invalidation triggers
 * - WebSocket cache event notifications
 * - Multi-tenant cache isolation
 *
 * Generated by CC (Claude Code)
 */

import { test, expect, Page } from '@playwright/test';
import { CacheTestUtils } from './utils/cache-test-utils';

// WebSocket message type
interface WebSocketMessage {
  type: string;
  event?: string;
  data?: unknown;
  timestamp?: string;
}

test.describe('Cache Operations', () => {
  let cacheUtils: CacheTestUtils;
  let page: Page;

  test.beforeEach(async ({ page: testPage }) => {
    page = testPage;
    cacheUtils = new CacheTestUtils(page);
    await cacheUtils.clearAllCaches();

    // Set up authentication context
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'demo@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });
  });

  test.afterEach(async () => {
    cacheUtils.cleanup();
  });

  test('should return 304 Not Modified for unchanged data with ETag', async () => {
    // First request - should be cache miss
    const response1 = await page.request.get('/api/v1/cached-context/me', {
      headers: {
        'X-Client-Account-ID': 'demo-client',
      }
    });

    expect(response1.status()).toBe(200);
    expect(response1.headers()['x-cache']).toBe('MISS');

    const etag = response1.headers()['etag'];
    expect(etag).toBeTruthy();
    expect(etag).toMatch(/^"[a-f0-9]{32}"$/); // Should be quoted hex string

    // Second request with same ETag - should return 304
    const response2 = await page.request.get('/api/v1/cached-context/me', {
      headers: {
        'If-None-Match': etag!,
        'X-Client-Account-ID': 'demo-client',
      }
    });

    expect(response2.status()).toBe(304);
    expect(response2.headers()['x-cache']).toBe('ETAG_MATCH');
  });

  test('should cache and return data on subsequent requests', async () => {
    const endpoint = '/api/v1/cached-context/me';
    const headers = { 'X-Client-Account-ID': 'demo-client' };

    // First request - cache miss
    const response1 = await page.request.get(endpoint, { headers });
    expect(response1.status()).toBe(200);
    expect(response1.headers()['x-cache']).toBe('MISS');

    const data1 = await response1.json();
    expect(data1.cache_metadata.cached).toBe(false);

    // Second request - cache hit
    const response2 = await page.request.get(endpoint, { headers });
    expect(response2.status()).toBe(200);
    expect(response2.headers()['x-cache']).toBe('HIT');

    const data2 = await response2.json();
    expect(data2.cache_metadata.cached).toBe(true);

    // Data should be identical
    expect(data1.user_context).toEqual(data2.user_context);
  });

  test('should validate cache headers and metadata', async () => {
    const response = await page.request.get('/api/v1/cached-context/me', {
      headers: { 'X-Client-Account-ID': 'demo-client' }
    });

    expect(response.status()).toBe(200);

    // Validate cache headers
    expect(response.headers()['cache-control']).toContain('private');
    expect(response.headers()['etag']).toBeTruthy();
    expect(response.headers()['vary']).toContain('X-Client-Account-ID');

    const data = await response.json();
    expect(data.cache_metadata).toBeDefined();
    expect(data.cache_metadata.cache_key).toBeTruthy();

    if (response.headers()['x-cache'] === 'MISS') {
      expect(data.cache_metadata.fetch_time_ms).toBeGreaterThan(0);
      expect(data.cache_metadata.ttl_seconds).toBeGreaterThan(0);
    }
  });

  test('should invalidate cache on user profile update', async () => {
    const contextEndpoint = '/api/v1/cached-context/me';
    const headers = { 'X-Client-Account-ID': 'demo-client' };

    // Load initial user context
    const initialResponse = await page.request.get(contextEndpoint, { headers });
    expect(initialResponse.status()).toBe(200);

    const initialData = await initialResponse.json();
    const initialCallCount = await cacheUtils.getApiCallCount('cached-context/me');

    // Simulate user profile update (this should trigger cache invalidation)
    const updateResponse = await page.request.put('/api/v1/user/profile', {
      headers,
      data: {
        display_name: 'Updated Name',
        preferences: { theme: 'dark' }
      }
    });

    if (updateResponse.ok()) {
      // Wait a bit for cache invalidation to propagate
      await page.waitForTimeout(1000);

      // Request context again - should be cache miss due to invalidation
      const updatedResponse = await page.request.get(contextEndpoint, { headers });
      expect(updatedResponse.status()).toBe(200);

      // Should be cache miss after invalidation
      expect(updatedResponse.headers()['x-cache']).toBe('MISS');

      const newCallCount = await cacheUtils.getApiCallCount('cached-context/me');
      expect(newCallCount).toBeGreaterThan(initialCallCount);
    }
  });

  test('should handle WebSocket cache invalidation events', async () => {
    // Set up WebSocket connection for cache events
    const wsMessages: WebSocketMessage[] = [];

    page.on('websocket', ws => {
      ws.on('message', data => {
        try {
          const message = JSON.parse(data.toString());
          wsMessages.push(message);
        } catch (error) {
          console.log('Non-JSON WebSocket message:', data.toString());
        }
      });
    });

    // Navigate to a page that should establish WebSocket connection
    await page.goto('/dashboard');
    await page.waitForTimeout(2000); // Allow WebSocket connection

    // Trigger an action that should cause cache invalidation
    try {
      await page.goto('/admin/users');
      await page.click('[data-testid="refresh-users-btn"]');

      // Wait for WebSocket invalidation event
      await page.waitForTimeout(3000);

      // Check if we received cache invalidation events
      const cacheEvents = wsMessages.filter(msg =>
        msg.type === 'cache_invalidation'
      );

      if (cacheEvents.length > 0) {
        expect(cacheEvents[0].data).toHaveProperty('event_type');
        expect(cacheEvents[0].data).toHaveProperty('timestamp');
      }
    } catch (error) {
      console.log('WebSocket test skipped (admin access may not be available):', error);
    }
  });

  test('should handle concurrent requests efficiently', async () => {
    const endpoint = '/api/v1/cached-context/clients';
    const headers = { 'X-Client-Account-ID': 'demo-client' };

    // Make multiple concurrent requests
    const concurrentRequests = 5;
    const requestPromises = Array.from({ length: concurrentRequests }, () =>
      page.request.get(endpoint, { headers })
    );

    const responses = await Promise.all(requestPromises);

    // All requests should succeed
    responses.forEach(response => {
      expect(response.status()).toBe(200);
    });

    // At least some should be cache hits (except the first)
    const cacheStatuses = responses.map(r => r.headers()['x-cache']);
    const cacheHits = cacheStatuses.filter(status => status === 'HIT').length;

    // Should have cache hits for concurrent requests
    expect(cacheHits).toBeGreaterThan(0);
  });

  test('should respect cache TTL and expire appropriately', async () => {
    const endpoint = '/api/v1/cached-context/me';
    const headers = { 'X-Client-Account-ID': 'demo-client' };

    // Make initial request
    const response1 = await page.request.get(endpoint, { headers });
    expect(response1.status()).toBe(200);

    const cacheControl = response1.headers()['cache-control'];
    const maxAgeMatch = cacheControl?.match(/max-age=(\d+)/);
    const maxAge = maxAgeMatch ? parseInt(maxAgeMatch[1]) : 3600;

    // If TTL is short enough for testing (less than 10 seconds), wait for expiry
    if (maxAge <= 10) {
      await page.waitForTimeout((maxAge + 1) * 1000);

      // Request again - should be cache miss due to expiry
      const response2 = await page.request.get(endpoint, { headers });
      expect(response2.status()).toBe(200);
      expect(response2.headers()['x-cache']).toBe('MISS');
    } else {
      console.log(`Cache TTL too long for testing (${maxAge}s), skipping expiry test`);
    }
  });

  test('should handle cache errors gracefully', async () => {
    // Test with malformed client account ID
    const response1 = await page.request.get('/api/v1/cached-context/me', {
      headers: { 'X-Client-Account-ID': 'invalid-client-id-!@#$%' }
    });

    // Should still return data (graceful degradation)
    expect([200, 400, 403]).toContain(response1.status());

    // Test with missing required headers
    const response2 = await page.request.get('/api/v1/cached-context/me');

    // Should handle missing headers appropriately
    expect([200, 400, 401]).toContain(response2.status());
  });

  test('should support conditional requests with If-Modified-Since', async () => {
    const endpoint = '/api/v1/cached-context/me';
    const headers = { 'X-Client-Account-ID': 'demo-client' };

    // First request
    const response1 = await page.request.get(endpoint, { headers });
    expect(response1.status()).toBe(200);

    const lastModified = response1.headers()['last-modified'];

    if (lastModified) {
      // Request with If-Modified-Since
      const response2 = await page.request.get(endpoint, {
        headers: {
          ...headers,
          'If-Modified-Since': lastModified
        }
      });

      // Should return 304 if not modified
      expect([200, 304]).toContain(response2.status());
    }
  });

  test('should track cache metrics accurately', async () => {
    // Make several requests to generate metrics
    const endpoints = [
      '/api/v1/cached-context/me',
      '/api/v1/cached-context/clients',
    ];

    for (const endpoint of endpoints) {
      // Make each request twice to test hit/miss patterns
      await page.request.get(endpoint, {
        headers: { 'X-Client-Account-ID': 'demo-client' }
      });
      await page.request.get(endpoint, {
        headers: { 'X-Client-Account-ID': 'demo-client' }
      });
    }

    // Get cache metrics
    const metrics = await cacheUtils.getCacheMetrics();

    expect(metrics.totalRequests).toBeGreaterThan(0);
    expect(metrics.hitRatio).toBeGreaterThanOrEqual(0);
    expect(metrics.hitRatio).toBeLessThanOrEqual(1);
    expect(metrics.avgResponseTime).toBeGreaterThan(0);

    // Should have some cache hits
    expect(metrics.cacheHits).toBeGreaterThan(0);
  });

  test('should validate cache key structure for security', async () => {
    await page.request.get('/api/v1/cached-context/me', {
      headers: {
        'X-Client-Account-ID': 'test-client-123',
        'X-Engagement-ID': 'test-engagement-456'
      }
    });

    // Get cache keys to validate structure
    const cacheKeys = await cacheUtils.getCacheKeys('*');

    if (cacheKeys.length > 0) {
      const contextKeys = cacheKeys.filter(key => key.includes('context'));

      for (const key of contextKeys.slice(0, 3)) {
        // Keys should include version prefix
        expect(key).toMatch(/^v\d+:/);

        // Keys should include tenant isolation
        expect(key).toMatch(/(client:|user:)/);

        // Keys should not contain sensitive data
        expect(key).not.toMatch(/(password|secret|token|key)/i);
      }
    }
  });
});
