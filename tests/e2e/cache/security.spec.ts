/**
 * Cache Security Test Suite
 *
 * Comprehensive security validation tests for Redis caching including:
 * - Multi-tenant cache isolation verification
 * - Cache poisoning attack prevention
 * - Unauthorized access attempt blocking
 * - Data encryption validation in cache
 * - Secure cache key generation testing
 *
 * Generated by CC (Claude Code)
 */

import { test, expect, Browser, BrowserContext } from '@playwright/test';
import { SecurityTestUtils } from './utils/security-test-utils';
import { CacheTestUtils } from './utils/cache-test-utils';

test.describe('Cache Security', () => {
  let securityUtils: SecurityTestUtils;
  let cacheUtils: CacheTestUtils;
  let browser: Browser;

  test.beforeEach(async ({ page, browser: testBrowser }) => {
    browser = testBrowser;
    securityUtils = new SecurityTestUtils(page, browser);
    cacheUtils = new CacheTestUtils(page);

    await cacheUtils.clearAllCaches();
  });

  test.afterEach(async () => {
    cacheUtils.cleanup();
  });

  test('should isolate cache by tenant', async () => {
    // Create two contexts for different tenants
    const tenant1Context = await browser.newContext();
    const tenant2Context = await browser.newContext();

    const page1 = await tenant1Context.newPage();
    const page2 = await tenant2Context.newPage();

    try {
      // Login as users from different tenants
      const tenant1 = await securityUtils.loginAsUser(page1, 'tenant1@example.com');
      const tenant2 = await securityUtils.loginAsUser(page2, 'tenant2@example.com');

      console.log('Testing tenant isolation:', {
        tenant1: tenant1.clientAccountId,
        tenant2: tenant2.clientAccountId
      });

      // Make requests to same endpoint from both tenants
      const endpoint = '/api/v1/cached-context/me';

      const response1 = await page1.request.get(endpoint, {
        headers: {
          'X-Client-Account-ID': tenant1.clientAccountId,
        }
      });

      const response2 = await page2.request.get(endpoint, {
        headers: {
          'X-Client-Account-ID': tenant2.clientAccountId,
        }
      });

      // Both requests should succeed
      expect(response1.status()).toBe(200);
      expect(response2.status()).toBe(200);

      // If tenants are different, responses should be different
      if (tenant1.clientAccountId !== tenant2.clientAccountId) {
        const data1 = await response1.json();
        const data2 = await response2.json();

        // Tenant context should be different
        expect(data1.user_context?.client?.id).not.toBe(data2.user_context?.client?.id);
      }

      // Verify cache keys include tenant context
      const securityUtilsPage1 = new SecurityTestUtils(page1, browser);
      const securityUtilsPage2 = new SecurityTestUtils(page2, browser);

      const cacheKeys1 = await securityUtilsPage1.getCacheKeys(page1, '*');
      const cacheKeys2 = await securityUtilsPage2.getCacheKeys(page2, '*');

      // Look for tenant-specific patterns in cache keys
      const tenant1Keys = cacheKeys1.filter(key =>
        key.includes(tenant1.clientAccountId) || key.includes(`user:${tenant1.userId}`)
      );
      const tenant2Keys = cacheKeys2.filter(key =>
        key.includes(tenant2.clientAccountId) || key.includes(`user:${tenant2.userId}`)
      );

      // Each tenant should have their own cache keys
      if (tenant1Keys.length > 0 && tenant2Keys.length > 0) {
        expect(tenant1Keys).not.toEqual(tenant2Keys);
      }

    } finally {
      await tenant1Context.close();
      await tenant2Context.close();
    }
  });

  test('should prevent cache poisoning attacks', async ({ page }) => {
    const maliciousPayload = {
      user: {
        id: 'admin',
        role: 'super_admin',
        email: 'hacker@evil.com'
      },
      client: {
        id: 'system',
        name: 'System Admin'
      }
    };

    // Run cache poisoning prevention test
    const result = await securityUtils.testCachePoisoningPrevention(maliciousPayload);

    expect(result.passed).toBe(true);
    expect(result.violations.length).toBe(0);

    // Verify legitimate user data is not compromised
    await securityUtils.loginAsUser(page, 'legitimate@example.com');

    const response = await page.request.get('/api/v1/cached-context/me', {
      headers: { 'X-Client-Account-ID': 'legitimate-client' }
    });

    if (response.ok()) {
      const data = await response.json();
      // Should not contain malicious data
      expect(data.user_context?.user?.role).not.toBe('super_admin');
      expect(data.user_context?.user?.email).not.toBe('hacker@evil.com');
    }
  });

  test('should block unauthorized access to admin cache endpoints', async ({ page }) => {
    // Test unauthorized access to admin endpoints
    const result = await securityUtils.testUnauthorizedAccess();

    expect(result.passed).toBe(true);

    // Additional specific tests
    const unauthorizedEndpoints = [
      '/api/v1/admin/cache/clear',
      '/api/v1/admin/cache/keys',
      '/api/v1/admin/cache/stats',
      '/api/v1/admin/cache/inspect/some-key'
    ];

    for (const endpoint of unauthorizedEndpoints) {
      const response = await page.request.get(endpoint);

      // Should be unauthorized or forbidden
      expect([401, 403, 404]).toContain(response.status());
    }
  });

  test('should validate secure cache key generation', async ({ page }) => {
    await securityUtils.loginAsUser(page, 'testuser@example.com');

    // Make requests to generate cache keys
    await page.request.get('/api/v1/cached-context/me', {
      headers: {
        'X-Client-Account-ID': 'test-client-123',
        'X-Engagement-ID': 'test-engagement-456'
      }
    });

    const result = await securityUtils.testSecureCacheKeyGeneration();

    // Check for critical security violations
    const criticalViolations = result.violations.filter(v => v.severity === 'critical');
    expect(criticalViolations.length).toBe(0);

    // Additional validation of cache key structure
    const cacheKeys = await securityUtils.getCacheKeys(page, '*');

    for (const key of cacheKeys.slice(0, 10)) {
      // Keys should not contain plaintext sensitive data
      expect(key).not.toMatch(/(password|secret|token|api[_-]?key)/i);

      // Keys should be properly structured
      expect(key.length).toBeLessThan(250); // Reasonable length
      expect(key).not.toContain(' '); // No spaces
      expect(key).not.toMatch(/[^\w:.-]/); // Only safe characters
    }
  });

  test('should prevent cross-tenant data leakage', async () => {
    const tenant1Context = await browser.newContext();
    const tenant2Context = await browser.newContext();

    const page1 = await tenant1Context.newPage();
    const page2 = await tenant2Context.newPage();

    try {
      // Set up different tenants
      const tenant1 = await securityUtils.loginAsUser(page1, 'tenant1@company1.com');
      const tenant2 = await securityUtils.loginAsUser(page2, 'tenant2@company2.com');

      // Tenant 1 creates/accesses data
      const createResponse1 = await page1.request.get('/api/v1/cached-context/clients', {
        headers: { 'X-Client-Account-ID': tenant1.clientAccountId }
      });

      if (createResponse1.ok()) {
        const tenant1Data = await createResponse1.json();

        // Tenant 2 tries to access same endpoint
        const accessResponse2 = await page2.request.get('/api/v1/cached-context/clients', {
          headers: { 'X-Client-Account-ID': tenant2.clientAccountId }
        });

        if (accessResponse2.ok()) {
          const tenant2Data = await accessResponse2.json();

          // Data should be different (no leakage)
          expect(JSON.stringify(tenant1Data)).not.toBe(JSON.stringify(tenant2Data));
        }
      }

      // Try cross-tenant access (should fail)
      const crossAccessResponse = await page2.request.get('/api/v1/cached-context/clients', {
        headers: { 'X-Client-Account-ID': tenant1.clientAccountId } // Wrong tenant
      });

      // Should be unauthorized or return different/empty data
      if (crossAccessResponse.ok()) {
        const crossData = await crossAccessResponse.json();
        // Should not get tenant1's data
        expect(crossData).not.toEqual(await createResponse1.json());
      } else {
        expect([401, 403]).toContain(crossAccessResponse.status());
      }

    } finally {
      await tenant1Context.close();
      await tenant2Context.close();
    }
  });

  test('should validate ETag security and prevent manipulation', async ({ page }) => {
    await securityUtils.loginAsUser(page, 'testuser@example.com');

    const endpoint = '/api/v1/cached-context/me';
    const headers = { 'X-Client-Account-ID': 'test-client' };

    // Get legitimate ETag
    const response1 = await page.request.get(endpoint, { headers });
    expect(response1.status()).toBe(200);

    const legitimateETag = response1.headers()['etag'];
    expect(legitimateETag).toBeTruthy();

    // Try malicious ETag manipulation
    const maliciousETags = [
      '"malicious-etag"',
      '"../../secrets"',
      '"<script>alert(1)</script>"',
      '"DROP TABLE users;"',
      '"\'; DROP TABLE users; --"'
    ];

    for (const maliciousETag of maliciousETags) {
      const response = await page.request.get(endpoint, {
        headers: {
          ...headers,
          'If-None-Match': maliciousETag
        }
      });

      // Should not cause server errors or security issues
      expect([200, 304, 400]).toContain(response.status());

      // Response should be safe
      if (response.status() === 200) {
        const data = await response.json();
        expect(data).not.toContain('malicious');
        expect(data).not.toContain('<script>');
      }
    }
  });

  test('should handle cache timing attacks prevention', async ({ page }) => {
    await securityUtils.loginAsUser(page, 'testuser@example.com');

    const endpoint = '/api/v1/cached-context/me';
    const headers = { 'X-Client-Account-ID': 'test-client' };

    // Make multiple requests to establish baseline timing
    const timings: number[] = [];

    for (let i = 0; i < 10; i++) {
      const startTime = Date.now();
      const response = await page.request.get(endpoint, { headers });
      const endTime = Date.now();

      expect(response.status()).toBe(200);
      timings.push(endTime - startTime);
    }

    // Calculate timing statistics
    const avgTiming = timings.reduce((sum, t) => sum + t, 0) / timings.length;
    const maxTiming = Math.max(...timings);
    const minTiming = Math.min(...timings);
    const timingVariance = maxTiming - minTiming;

    console.log(`Timing analysis: avg=${avgTiming.toFixed(1)}ms, min=${minTiming}ms, max=${maxTiming}ms, variance=${timingVariance}ms`);

    // Cache response times should be consistent (prevent timing attacks)
    // Allow some variance but not excessive
    expect(timingVariance).toBeLessThan(100); // Less than 100ms variance
    expect(avgTiming).toBeLessThan(200); // Average under 200ms
  });

  test('should validate input sanitization in cache operations', async ({ page }) => {
    await securityUtils.loginAsUser(page, 'testuser@example.com');

    // Test various malicious inputs in headers
    const maliciousInputs = [
      { name: 'XSS attempt', value: '<script>alert("xss")</script>' },
      { name: 'SQL injection', value: "'; DROP TABLE cache; --" },
      { name: 'Path traversal', value: '../../../etc/passwd' },
      { name: 'Command injection', value: '$(rm -rf /)' },
      { name: 'LDAP injection', value: '*)(uid=*))(|(uid=*' }
    ];

    for (const maliciousInput of maliciousInputs) {
      const response = await page.request.get('/api/v1/cached-context/me', {
        headers: {
          'X-Client-Account-ID': maliciousInput.value,
          'X-Engagement-ID': maliciousInput.value
        }
      });

      // Should handle malicious input gracefully
      expect([200, 400, 403]).toContain(response.status());

      if (response.ok()) {
        const data = await response.json();
        const dataString = JSON.stringify(data);

        // Response should not contain unescaped malicious content
        expect(dataString).not.toContain('<script>');
        expect(dataString).not.toContain('DROP TABLE');
        expect(dataString).not.toContain('rm -rf');
      }
    }
  });

  test('should run comprehensive security test suite', async ({ page }) => {
    const results = await securityUtils.runSecurityTestSuite();

    console.log('Security Test Results:', results.summary);

    // Overall security should pass
    expect(results.overall).toBe('PASS');
    expect(results.summary.criticalViolations).toBe(0);
    expect(results.summary.passed).toBeGreaterThan(results.summary.failed);

    // Generate security report
    const report = securityUtils.generateSecurityReport(results.results);
    console.log('Security Report Generated:', report.length > 0);

    // Log any violations for investigation
    const allViolations = results.results.flatMap(r => r.violations);
    if (allViolations.length > 0) {
      console.log('Security violations found:', allViolations);
    }
  });

  test('should validate cache access control with different user roles', async () => {
    const roles = [
      { email: 'admin@example.com', role: 'admin', shouldAccess: true },
      { email: 'user@example.com', role: 'user', shouldAccess: true },
      { email: 'viewer@example.com', role: 'viewer', shouldAccess: true },
      { email: 'disabled@example.com', role: 'disabled', shouldAccess: false }
    ];

    for (const roleTest of roles) {
      const context = await browser.newContext();
      const rolePage = await context.newPage();

      try {
        await securityUtils.loginAsUser(rolePage, roleTest.email);

        const response = await rolePage.request.get('/api/v1/cached-context/me', {
          headers: { 'X-Client-Account-ID': 'test-client' }
        });

        if (roleTest.shouldAccess) {
          expect([200, 304]).toContain(response.status());
        } else {
          expect([401, 403]).toContain(response.status());
        }

      } catch (error) {
        if (!roleTest.shouldAccess) {
          // Expected for disabled users
          console.log(`Expected access denial for ${roleTest.role}:`, error);
        } else {
          throw error;
        }
      } finally {
        await context.close();
      }
    }
  });
});
