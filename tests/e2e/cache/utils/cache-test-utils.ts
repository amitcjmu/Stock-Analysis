/**
 * Cache Test Utilities for AI Force Migration Platform
 *
 * Comprehensive utilities for testing Redis caching functionality, including:
 * - Cache state management and validation
 * - API call tracking and metrics collection
 * - ETag and conditional request testing
 * - Multi-tenant cache isolation verification
 * - Performance benchmarking tools
 *
 * Generated by CC (Claude Code)
 */

import { Page, Request, Response } from '@playwright/test';
import { expect } from '@playwright/test';

// Extended performance types
interface PerformanceResourceTimingExt extends PerformanceResourceTiming {
  transferSize?: number;
  encodedBodySize?: number;
}

interface NavigationMetrics {
  domContentLoaded: number;
  loadComplete: number;
  totalTime: number;
}

interface ResourceMetrics {
  name: string;
  duration: number;
  transferSize?: number;
  encodedBodySize?: number;
}

export interface CacheMetrics {
  totalRequests: number;
  cacheHits: number;
  cacheMisses: number;
  hitRatio: number;
  avgResponseTime: number;
  etagMatches: number;
  invalidations: number;
}

export interface ApiCallTracker {
  endpoint: string;
  method: string;
  timestamp: number;
  responseTime: number;
  cacheStatus: 'HIT' | 'MISS' | 'ETAG_MATCH' | 'BYPASS';
  statusCode: number;
  etag?: string;
}

export interface CacheState {
  key: string;
  value: unknown;
  ttl: number;
  tenant: string;
  cached_at: string;
}

export class CacheTestUtils {
  private page: Page;
  private apiCalls: ApiCallTracker[] = [];
  private requestListener: ((request: Request) => void) | null = null;
  private responseListener: ((response: Response) => void) | null = null;

  constructor(page: Page) {
    this.page = page;
    this.setupRequestTracking();
  }

  /**
   * Set up request and response tracking for cache analysis
   */
  private setupRequestTracking(): void {
    this.requestListener = (request: Request) => {
      // Track API requests
      if (request.url().includes('/api/v1/')) {
        this.apiCalls.push({
          endpoint: this.extractEndpoint(request.url()),
          method: request.method(),
          timestamp: Date.now(),
          responseTime: 0,
          cacheStatus: 'BYPASS',
          statusCode: 0,
        });
      }
    };

    this.responseListener = (response: Response) => {
      // Update API call tracking with response data
      if (response.url().includes('/api/v1/')) {
        const callIndex = this.apiCalls.findIndex(
          call =>
            call.endpoint === this.extractEndpoint(response.url()) &&
            call.responseTime === 0
        );

        if (callIndex !== -1) {
          const cacheHeader = response.headers()['x-cache'] || 'BYPASS';
          this.apiCalls[callIndex] = {
            ...this.apiCalls[callIndex],
            responseTime: Date.now() - this.apiCalls[callIndex].timestamp,
            cacheStatus: cacheHeader as 'HIT' | 'MISS' | 'ETAG_MATCH' | 'BYPASS',
            statusCode: response.status(),
            etag: response.headers()['etag']?.replace(/"/g, ''),
          };
        }
      }
    };

    this.page.on('request', this.requestListener);
    this.page.on('response', this.responseListener);
  }

  /**
   * Extract API endpoint from full URL
   */
  private extractEndpoint(url: string): string {
    try {
      const urlObj = new URL(url);
      return urlObj.pathname.replace('/api/v1/', '');
    } catch {
      return url;
    }
  }

  /**
   * Clear all caches (browser and server-side)
   */
  async clearAllCaches(): Promise<void> {
    // Clear browser cache
    await this.page.context().clearCookies();
    await this.page.evaluate(() => {
      localStorage.clear();
      sessionStorage.clear();
      // Clear any custom caches
      if ('caches' in window) {
        caches.keys().then(names => {
          names.forEach(name => caches.delete(name));
        });
      }
    });

    // Clear server cache via admin API
    try {
      const adminToken = process.env.ADMIN_TOKEN || 'demo-admin-token';
      const response = await this.page.request.post('/api/v1/admin/cache/clear', {
        headers: {
          'X-Admin-Token': adminToken,
          'Content-Type': 'application/json'
        },
        data: { force: true, reason: 'test_setup' }
      });

      if (!response.ok()) {
        console.warn(`Failed to clear server cache: ${response.status()}`);
      }
    } catch (error) {
      console.warn('Could not clear server cache:', error);
    }

    // Reset tracking
    this.apiCalls = [];
  }

  /**
   * Get API call count for a specific endpoint
   */
  async getApiCallCount(endpoint: string): Promise<number> {
    return this.apiCalls.filter(call =>
      call.endpoint.includes(endpoint.replace('/api/v1/', ''))
    ).length;
  }

  /**
   * Get API calls with cache status filtering
   */
  getApiCallsWithStatus(status: 'HIT' | 'MISS' | 'ETAG_MATCH'): ApiCallTracker[] {
    return this.apiCalls.filter(call => call.cacheStatus === status);
  }

  /**
   * Get comprehensive cache metrics
   */
  async getCacheMetrics(): Promise<CacheMetrics> {
    const totalRequests = this.apiCalls.length;
    const cacheHits = this.apiCalls.filter(call => call.cacheStatus === 'HIT').length;
    const cacheMisses = this.apiCalls.filter(call => call.cacheStatus === 'MISS').length;
    const etagMatches = this.apiCalls.filter(call => call.cacheStatus === 'ETAG_MATCH').length;

    const hitRatio = totalRequests > 0 ? (cacheHits + etagMatches) / totalRequests : 0;
    const avgResponseTime = totalRequests > 0
      ? this.apiCalls.reduce((sum, call) => sum + call.responseTime, 0) / totalRequests
      : 0;

    try {
      // Get server-side cache metrics
      const response = await this.page.request.get('/api/v1/cached-context/stats');
      const serverMetrics = response.ok() ? await response.json() : {};

      return {
        totalRequests,
        cacheHits,
        cacheMisses,
        hitRatio,
        avgResponseTime,
        etagMatches,
        invalidations: serverMetrics.invalidation_service?.total_invalidations || 0,
      };
    } catch {
      return {
        totalRequests,
        cacheHits,
        cacheMisses,
        hitRatio,
        avgResponseTime,
        etagMatches,
        invalidations: 0,
      };
    }
  }

  /**
   * Test ETag conditional requests
   */
  async testETagConditionalRequest(endpoint: string): Promise<{
    initialResponse: Response;
    conditionalResponse: Response;
    etagMatch: boolean;
  }> {
    // First request to get ETag
    const initialResponse = await this.page.request.get(endpoint);
    const etag = initialResponse.headers()['etag'];

    expect(etag).toBeTruthy();
    expect(initialResponse.status()).toBe(200);

    // Second request with If-None-Match header
    const conditionalResponse = await this.page.request.get(endpoint, {
      headers: { 'If-None-Match': etag! }
    });

    return {
      initialResponse,
      conditionalResponse,
      etagMatch: conditionalResponse.status() === 304,
    };
  }

  /**
   * Validate cache headers
   */
  validateCacheHeaders(response: Response, expectedCacheStatus: string): void {
    const cacheHeader = response.headers()['x-cache'];
    const cacheControl = response.headers()['cache-control'];
    const etag = response.headers()['etag'];

    expect(cacheHeader).toBe(expectedCacheStatus);

    if (expectedCacheStatus === 'HIT' || expectedCacheStatus === 'MISS') {
      expect(cacheControl).toContain('private');
      expect(etag).toBeTruthy();
    }
  }

  /**
   * Wait for cache invalidation event via WebSocket
   */
  async waitForCacheInvalidation(
    entityType: string,
    entityId?: string,
    timeout: number = 5000
  ): Promise<boolean> {
    return new Promise((resolve) => {
      let wsEventReceived = false;
      const timer = setTimeout(() => resolve(wsEventReceived), timeout);

      // Listen for WebSocket messages
      this.page.on('websocket', ws => {
        ws.on('message', data => {
          try {
            const message = JSON.parse(data.toString());
            if (
              message.type === 'cache_invalidation' &&
              message.data?.entity_type === entityType &&
              (!entityId || message.data?.entity_id === entityId)
            ) {
              wsEventReceived = true;
              clearTimeout(timer);
              resolve(true);
            }
          } catch (error) {
            // Ignore JSON parse errors
          }
        });
      });
    });
  }

  /**
   * Simulate network conditions for cache testing
   */
  async simulateNetworkConditions(
    downloadThroughput: number = 1000000, // 1 Mbps
    uploadThroughput: number = 1000000,
    latency: number = 100 // 100ms
  ): Promise<void> {
    const client = await this.page.context().newCDPSession(this.page);
    await client.send('Network.emulateNetworkConditions', {
      offline: false,
      downloadThroughput,
      uploadThroughput,
      latency,
    });
  }

  /**
   * Reset network conditions
   */
  async resetNetworkConditions(): Promise<void> {
    const client = await this.page.context().newCDPSession(this.page);
    await client.send('Network.emulateNetworkConditions', {
      offline: false,
      downloadThroughput: -1,
      uploadThroughput: -1,
      latency: 0,
    });
  }

  /**
   * Measure page load time
   */
  async measurePageLoadTime(url: string): Promise<number> {
    const startTime = Date.now();
    await this.page.goto(url);
    await this.page.waitForLoadState('networkidle');
    return Date.now() - startTime;
  }

  /**
   * Get cache keys from Redis (requires admin access)
   */
  async getCacheKeys(pattern: string = '*'): Promise<string[]> {
    try {
      const response = await this.page.request.get(`/api/v1/admin/cache/keys?pattern=${pattern}`);
      if (response.ok()) {
        const data = await response.json();
        return data.keys || [];
      }
    } catch (error) {
      console.warn('Could not fetch cache keys:', error);
    }
    return [];
  }

  /**
   * Invalidate specific cache entries
   */
  async invalidateCache(
    keys: string[] | string,
    clientAccountId?: string
  ): Promise<boolean> {
    try {
      const keyArray = Array.isArray(keys) ? keys : [keys];
      const headers: Record<string, string> = {
        'Content-Type': 'application/json'
      };

      if (clientAccountId) {
        headers['X-Client-Account-ID'] = clientAccountId;
      }

      const response = await this.page.request.post('/api/v1/admin/cache/invalidate', {
        headers,
        data: { keys: keyArray, reason: 'test_invalidation' }
      });

      return response.ok();
    } catch (error) {
      console.warn('Cache invalidation failed:', error);
      return false;
    }
  }

  /**
   * Enable/disable feature flags for testing
   */
  async setFeatureFlags(flags: Record<string, boolean>): Promise<void> {
    await this.page.addInitScript((flagsData) => {
      window.FEATURE_FLAGS = { ...window.FEATURE_FLAGS, ...flagsData };
    }, flags);
  }

  /**
   * Get detailed performance metrics
   */
  async getPerformanceMetrics(): Promise<{
    navigation: NavigationMetrics | null;
    resources: ResourceMetrics[];
    cacheEfficiency: number;
  }> {
    return await this.page.evaluate(() => {
      const navigation = performance.getEntriesByType('navigation')[0];
      const resources = performance.getEntriesByType('resource');

      // Calculate cache efficiency from resource timing
      const cachedResources = resources.filter(resource => {
        const res = resource as PerformanceResourceTimingExt;
        return res.transferSize === 0 ||
          (res.transferSize !== undefined && res.encodedBodySize !== undefined && res.transferSize < res.encodedBodySize);
      });

      const cacheEfficiency = resources.length > 0
        ? cachedResources.length / resources.length
        : 0;

      return {
        navigation: navigation ? {
          domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
          loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
          totalTime: navigation.loadEventEnd - navigation.fetchStart,
        } : null,
        resources: resources.map(r => ({
          name: r.name,
          duration: r.duration,
          transferSize: (r as PerformanceResourceTimingExt).transferSize,
          encodedBodySize: (r as PerformanceResourceTimingExt).encodedBodySize,
        })),
        cacheEfficiency,
      };
    });
  }

  /**
   * Clean up event listeners
   */
  cleanup(): void {
    if (this.requestListener) {
      this.page.off('request', this.requestListener);
    }
    if (this.responseListener) {
      this.page.off('response', this.responseListener);
    }
  }

  /**
   * Get API call summary for reporting
   */
  getApiCallSummary(): {
    totalCalls: number;
    cacheHitRatio: number;
    averageResponseTime: number;
    endpointBreakdown: Record<string, { calls: number; hitRatio: number }>;
  } {
    const totalCalls = this.apiCalls.length;
    const cacheHits = this.getApiCallsWithStatus('HIT').length + this.getApiCallsWithStatus('ETAG_MATCH').length;
    const cacheHitRatio = totalCalls > 0 ? cacheHits / totalCalls : 0;
    const averageResponseTime = totalCalls > 0
      ? this.apiCalls.reduce((sum, call) => sum + call.responseTime, 0) / totalCalls
      : 0;

    // Group by endpoint
    const endpointBreakdown: Record<string, { calls: number; hitRatio: number }> = {};
    this.apiCalls.forEach(call => {
      if (!endpointBreakdown[call.endpoint]) {
        endpointBreakdown[call.endpoint] = { calls: 0, hitRatio: 0 };
      }
      endpointBreakdown[call.endpoint].calls++;
    });

    // Calculate hit ratio for each endpoint
    Object.keys(endpointBreakdown).forEach(endpoint => {
      const endpointCalls = this.apiCalls.filter(call => call.endpoint === endpoint);
      const endpointHits = endpointCalls.filter(call =>
        call.cacheStatus === 'HIT' || call.cacheStatus === 'ETAG_MATCH'
      ).length;
      endpointBreakdown[endpoint].hitRatio = endpointHits / endpointCalls.length;
    });

    return {
      totalCalls,
      cacheHitRatio,
      averageResponseTime,
      endpointBreakdown,
    };
  }
}
