/**
 * Performance Monitor for Cache Testing
 *
 * Advanced performance monitoring utilities for validating cache implementation benefits:
 * - API call reduction tracking (target: 70%+ reduction)
 * - Page load time improvements (target: 50%+ faster)
 * - Memory usage monitoring
 * - Network request analysis
 * - Cache efficiency calculations
 *
 * Generated by CC (Claude Code)
 */

import { Page, Request, Response } from '@playwright/test';

// Extended window interface for performance monitoring
interface PerformanceWindow extends Window {
  __originalFetch?: typeof fetch;
  __navigationTiming?: PerformanceNavigationTiming;
  __paintTiming?: Record<string, number>;
}

// Performance memory interface
interface PerformanceMemory {
  usedJSHeapSize: number;
  totalJSHeapSize: number;
  jsHeapSizeLimit?: number;
}

interface ExtendedPerformance extends Performance {
  memory?: PerformanceMemory;
}

// Endpoint breakdown interface
interface EndpointBreakdown {
  [endpoint: string]: {
    calls: number;
    avgResponseTime: number;
    cacheHitRate: number;
  };
}

export interface PerformanceMetrics {
  // API metrics
  totalApiCalls: number;
  uniqueApiCalls: number;
  cacheHits: number;
  cacheMisses: number;
  cacheHitRatio: number;
  apiCallReduction: number;

  // Timing metrics
  totalResponseTime: number;
  averageResponseTime: number;
  pageLoadTime: number;
  timeToFirstByte: number;
  domContentLoaded: number;

  // Network metrics
  totalNetworkBytes: number;
  cachedBytes: number;
  networkBytesReduction: number;

  // Cache efficiency
  cacheEfficiencyScore: number;
  etag304Responses: number;

  // Memory metrics
  memoryUsage?: {
    used: number;
    total: number;
    percentage: number;
  };
}

export interface RequestMetric {
  url: string;
  method: string;
  timestamp: number;
  responseTime: number;
  size: number;
  cached: boolean;
  statusCode: number;
  cacheStatus: 'HIT' | 'MISS' | 'ETAG_MATCH' | 'BYPASS';
}

export interface PageTimingMetric {
  url: string;
  loadTime: number;
  domContentLoaded: number;
  firstPaint: number;
  firstContentfulPaint: number;
  largestContentfulPaint: number;
  cumulativeLayoutShift: number;
}

export class PerformanceMonitor {
  private page: Page;
  private requests: RequestMetric[] = [];
  private pageTimings: PageTimingMetric[] = [];
  private monitoring = false;
  private baselineMetrics: PerformanceMetrics | null = null;

  constructor(page: Page) {
    this.page = page;
  }

  /**
   * Start performance monitoring
   */
  async startMonitoring(): Promise<void> {
    if (this.monitoring) return;

    this.monitoring = true;
    this.requests = [];
    this.pageTimings = [];

    // Set up request tracking
    this.page.on('request', this.trackRequest.bind(this));
    this.page.on('response', this.trackResponse.bind(this));

    // Inject performance monitoring script
    await this.page.addInitScript(() => {
      // Store original fetch for comparison
      (window as PerformanceWindow).__originalFetch = window.fetch;

      // Enhanced performance observer for Web Vitals
      if ('PerformanceObserver' in window) {
        const observer = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          entries.forEach((entry) => {
            if (entry.entryType === 'navigation') {
              (window as PerformanceWindow).__navigationTiming = entry as PerformanceNavigationTiming;
            } else if (entry.entryType === 'paint') {
              (window as PerformanceWindow).__paintTiming = {
                ...(window as PerformanceWindow).__paintTiming,
                [entry.name]: entry.startTime,
              };
            }
          });
        });

        observer.observe({ entryTypes: ['navigation', 'paint', 'largest-contentful-paint'] });
      }
    });
  }

  /**
   * Stop performance monitoring
   */
  stopMonitoring(): void {
    if (!this.monitoring) return;

    this.monitoring = false;
    this.page.removeAllListeners('request');
    this.page.removeAllListeners('response');
  }

  /**
   * Track individual requests
   */
  private trackRequest(request: Request): void {
    if (!this.monitoring || !request.url().includes('/api/v1/')) return;

    const metric: RequestMetric = {
      url: request.url(),
      method: request.method(),
      timestamp: Date.now(),
      responseTime: 0,
      size: 0,
      cached: false,
      statusCode: 0,
      cacheStatus: 'BYPASS',
    };

    this.requests.push(metric);
  }

  /**
   * Track responses and update metrics
   */
  private trackResponse(response: Response): void {
    if (!this.monitoring || !response.url().includes('/api/v1/')) return;

    const requestIndex = this.requests.findIndex(
      req => req.url === response.url() && req.responseTime === 0
    );

    if (requestIndex === -1) return;

    const responseTime = Date.now() - this.requests[requestIndex].timestamp;
    const cacheStatus = response.headers()['x-cache'] || 'BYPASS';
    const contentLength = parseInt(response.headers()['content-length'] || '0', 10);

    this.requests[requestIndex] = {
      ...this.requests[requestIndex],
      responseTime,
      size: contentLength,
      cached: ['HIT', 'ETAG_MATCH'].includes(cacheStatus),
      statusCode: response.status(),
      cacheStatus: cacheStatus as 'HIT' | 'MISS' | 'ETAG_MATCH' | 'BYPASS',
    };
  }

  /**
   * Measure page load performance
   */
  async measurePageLoad(url: string): Promise<PageTimingMetric> {
    const startTime = Date.now();

    await this.page.goto(url);
    await this.page.waitForLoadState('networkidle');

    const timingData = await this.page.evaluate(() => {
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
      const paintTiming = (window as PerformanceWindow).__paintTiming || {};

      return {
        loadTime: navigation.loadEventEnd - navigation.fetchStart,
        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        firstPaint: paintTiming['first-paint'] || 0,
        firstContentfulPaint: paintTiming['first-contentful-paint'] || 0,
        // Placeholder for LCP and CLS - would need more sophisticated measurement
        largestContentfulPaint: 0,
        cumulativeLayoutShift: 0,
      };
    });

    const pageMetric: PageTimingMetric = {
      url,
      ...timingData,
    };

    this.pageTimings.push(pageMetric);
    return pageMetric;
  }

  /**
   * Capture baseline metrics (without cache)
   */
  async captureBaseline(): Promise<PerformanceMetrics> {
    const metrics = await this.getMetrics();
    this.baselineMetrics = metrics;
    return metrics;
  }

  /**
   * Get comprehensive performance metrics
   */
  async getMetrics(): Promise<PerformanceMetrics> {
    const apiRequests = this.requests.filter(req => req.url.includes('/api/v1/'));
    const totalApiCalls = apiRequests.length;
    const uniqueApiCalls = new Set(apiRequests.map(req => req.url)).size;
    const cacheHits = apiRequests.filter(req => req.cached).length;
    const cacheMisses = totalApiCalls - cacheHits;
    const cacheHitRatio = totalApiCalls > 0 ? cacheHits / totalApiCalls : 0;

    const etag304Responses = apiRequests.filter(req => req.cacheStatus === 'ETAG_MATCH').length;

    const totalResponseTime = apiRequests.reduce((sum, req) => sum + req.responseTime, 0);
    const averageResponseTime = totalApiCalls > 0 ? totalResponseTime / totalApiCalls : 0;

    const totalNetworkBytes = apiRequests.reduce((sum, req) => sum + req.size, 0);
    const cachedBytes = apiRequests
      .filter(req => req.cached)
      .reduce((sum, req) => sum + req.size, 0);

    // Calculate reductions compared to baseline
    let apiCallReduction = 0;
    let networkBytesReduction = 0;

    if (this.baselineMetrics) {
      apiCallReduction = this.baselineMetrics.totalApiCalls > 0
        ? 1 - (totalApiCalls / this.baselineMetrics.totalApiCalls)
        : 0;
      networkBytesReduction = this.baselineMetrics.totalNetworkBytes > 0
        ? 1 - (totalNetworkBytes / this.baselineMetrics.totalNetworkBytes)
        : 0;
    }

    // Calculate cache efficiency score (0-100)
    const cacheEfficiencyScore = this.calculateCacheEfficiency();

    // Get page load timing
    const latestPageTiming = this.pageTimings[this.pageTimings.length - 1];
    const pageLoadTime = latestPageTiming?.loadTime || 0;
    const domContentLoaded = latestPageTiming?.domContentLoaded || 0;

    // Get memory usage
    const memoryUsage = await this.getMemoryUsage();

    return {
      totalApiCalls,
      uniqueApiCalls,
      cacheHits,
      cacheMisses,
      cacheHitRatio,
      apiCallReduction,
      totalResponseTime,
      averageResponseTime,
      pageLoadTime,
      timeToFirstByte: 0, // Would need more sophisticated measurement
      domContentLoaded,
      totalNetworkBytes,
      cachedBytes,
      networkBytesReduction,
      cacheEfficiencyScore,
      etag304Responses,
      memoryUsage,
    };
  }

  /**
   * Calculate cache efficiency score based on multiple factors
   */
  private calculateCacheEfficiency(): number {
    if (this.requests.length === 0) return 0;

    const apiRequests = this.requests.filter(req => req.url.includes('/api/v1/'));
    if (apiRequests.length === 0) return 0;

    // Factors for efficiency calculation
    const hitRatio = apiRequests.filter(req => req.cached).length / apiRequests.length;
    const avgCachedResponseTime = this.getAverageResponseTime(apiRequests.filter(req => req.cached));
    const avgUncachedResponseTime = this.getAverageResponseTime(apiRequests.filter(req => !req.cached));

    // Time improvement factor (cached requests should be faster)
    const timeImprovement = avgUncachedResponseTime > 0
      ? Math.min(1, (avgUncachedResponseTime - avgCachedResponseTime) / avgUncachedResponseTime)
      : 0;

    // Combined efficiency score (weighted)
    const efficiency = (hitRatio * 0.6) + (timeImprovement * 0.4);
    return Math.round(efficiency * 100);
  }

  /**
   * Get average response time for a set of requests
   */
  private getAverageResponseTime(requests: RequestMetric[]): number {
    if (requests.length === 0) return 0;
    return requests.reduce((sum, req) => sum + req.responseTime, 0) / requests.length;
  }

  /**
   * Get memory usage information
   */
  private async getMemoryUsage(): Promise<{ used: number; total: number; percentage: number } | undefined> {
    try {
      const memoryInfo = await this.page.evaluate(() => {
        if ('memory' in performance) {
          const memory = (performance as ExtendedPerformance).memory!;
          return {
            used: memory.usedJSHeapSize,
            total: memory.totalJSHeapSize,
            percentage: (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100,
          };
        }
        return null;
      });

      return memoryInfo;
    } catch {
      return undefined;
    }
  }

  /**
   * Generate performance comparison report
   */
  generateComparisonReport(cachedMetrics: PerformanceMetrics, uncachedMetrics: PerformanceMetrics): {
    apiCallReduction: number;
    pageLoadImprovement: number;
    averageResponseTimeImprovement: number;
    networkBytesReduction: number;
    cacheHitRatio: number;
    recommendations: string[];
  } {
    const apiCallReduction = uncachedMetrics.totalApiCalls > 0
      ? (uncachedMetrics.totalApiCalls - cachedMetrics.totalApiCalls) / uncachedMetrics.totalApiCalls
      : 0;

    const pageLoadImprovement = uncachedMetrics.pageLoadTime > 0
      ? (uncachedMetrics.pageLoadTime - cachedMetrics.pageLoadTime) / uncachedMetrics.pageLoadTime
      : 0;

    const averageResponseTimeImprovement = uncachedMetrics.averageResponseTime > 0
      ? (uncachedMetrics.averageResponseTime - cachedMetrics.averageResponseTime) / uncachedMetrics.averageResponseTime
      : 0;

    const networkBytesReduction = uncachedMetrics.totalNetworkBytes > 0
      ? (uncachedMetrics.totalNetworkBytes - cachedMetrics.totalNetworkBytes) / uncachedMetrics.totalNetworkBytes
      : 0;

    // Generate recommendations
    const recommendations: string[] = [];

    if (apiCallReduction < 0.7) {
      recommendations.push(`API call reduction is ${(apiCallReduction * 100).toFixed(1)}%, target is 70%+`);
    }

    if (pageLoadImprovement < 0.5) {
      recommendations.push(`Page load improvement is ${(pageLoadImprovement * 100).toFixed(1)}%, target is 50%+`);
    }

    if (cachedMetrics.cacheHitRatio < 0.8) {
      recommendations.push(`Cache hit ratio is ${(cachedMetrics.cacheHitRatio * 100).toFixed(1)}%, consider increasing TTL or optimizing cache keys`);
    }

    if (cachedMetrics.averageResponseTime > 50) {
      recommendations.push(`Average cached response time is ${cachedMetrics.averageResponseTime.toFixed(1)}ms, consider optimizing cache lookup`);
    }

    return {
      apiCallReduction,
      pageLoadImprovement,
      averageResponseTimeImprovement,
      networkBytesReduction,
      cacheHitRatio: cachedMetrics.cacheHitRatio,
      recommendations,
    };
  }

  /**
   * Test cache performance under load
   */
  async testCacheUnderLoad(
    url: string,
    concurrent: number = 10,
    iterations: number = 5
  ): Promise<{
    averageResponseTime: number;
    cacheHitRatio: number;
    successRate: number;
  }> {
    const results: Array<{ responseTime: number; cached: boolean; success: boolean }> = [];

    for (let i = 0; i < iterations; i++) {
      const promises = Array.from({ length: concurrent }, async () => {
        const startTime = Date.now();
        try {
          const response = await this.page.request.get(url);
          const responseTime = Date.now() - startTime;
          const cached = ['HIT', 'ETAG_MATCH'].includes(response.headers()['x-cache'] || '');

          return {
            responseTime,
            cached,
            success: response.ok(),
          };
        } catch {
          return {
            responseTime: Date.now() - startTime,
            cached: false,
            success: false,
          };
        }
      });

      const batchResults = await Promise.all(promises);
      results.push(...batchResults);
    }

    const averageResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;
    const cacheHitRatio = results.filter(r => r.cached).length / results.length;
    const successRate = results.filter(r => r.success).length / results.length;

    return {
      averageResponseTime,
      cacheHitRatio,
      successRate,
    };
  }

  /**
   * Get detailed endpoint performance breakdown
   */
  getEndpointBreakdown(): Record<string, {
    calls: number;
    averageResponseTime: number;
    cacheHitRatio: number;
    totalBytes: number;
  }> {
    const breakdown: Record<string, {
      calls: number;
      averageResponseTime: number;
      cacheHitRatio: number;
      totalBytes: number;
    }> = {};

    this.requests.forEach(req => {
      const endpoint = this.normalizeEndpoint(req.url);

      if (!breakdown[endpoint]) {
        breakdown[endpoint] = {
          calls: 0,
          averageResponseTime: 0,
          cacheHitRatio: 0,
          totalBytes: 0,
        };
      }

      breakdown[endpoint].calls++;
      breakdown[endpoint].totalBytes += req.size;
    });

    // Calculate averages
    Object.keys(breakdown).forEach(endpoint => {
      const endpointRequests = this.requests.filter(req =>
        this.normalizeEndpoint(req.url) === endpoint
      );

      breakdown[endpoint].averageResponseTime =
        endpointRequests.reduce((sum, req) => sum + req.responseTime, 0) / endpointRequests.length;

      breakdown[endpoint].cacheHitRatio =
        endpointRequests.filter(req => req.cached).length / endpointRequests.length;
    });

    return breakdown;
  }

  /**
   * Normalize endpoint URL for grouping
   */
  private normalizeEndpoint(url: string): string {
    try {
      const urlObj = new URL(url);
      // Remove query parameters and normalize path
      let path = urlObj.pathname.replace('/api/v1/', '');

      // Replace UUIDs and IDs with placeholders
      path = path.replace(/[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}/gi, '{uuid}');
      path = path.replace(/\/\d+/g, '/{id}');

      return path;
    } catch {
      return url;
    }
  }

  /**
   * Reset all collected metrics
   */
  reset(): void {
    this.requests = [];
    this.pageTimings = [];
    this.baselineMetrics = null;
  }

  /**
   * Export metrics for reporting
   */
  exportMetrics(): {
    summary: PerformanceMetrics;
    requests: RequestMetric[];
    pageTimings: PageTimingMetric[];
    endpointBreakdown: EndpointBreakdown;
  } {
    return {
      summary: this.getMetrics(),
      requests: this.requests,
      pageTimings: this.pageTimings,
      endpointBreakdown: this.getEndpointBreakdown(),
    };
  }
}
