/**
 * NEW Lean Collection Flow Gap Analysis E2E Test
 *
 * This test validates the REDESIGNED lean single-agent gap analysis implementation.
 * It creates a FRESH collection flow and verifies:
 * 1. User can login successfully
 * 2. Navigate to Adaptive Forms (new collection UI)
 * 3. Clean up any blocking flows from previous test runs
 * 4. Start a NEW collection flow
 * 5. Select 2-3 assets for gap analysis
 * 6. Proceed through gap analysis phase
 * 7. Wait for completion with proper polling (5-second intervals, 60-second max)
 * 8. Verify gaps detected message in UI
 * 9. Query database to verify gaps persisted to collection_data_gaps table
 * 10. Verify questionnaire displayed (if applicable)
 *
 * CRITICAL: This test uses REAL Docker environment (localhost:8081 frontend, localhost:8000 backend)
 * and performs actual database verification via docker exec commands.
 *
 * FIX FOR ISSUE #591: Increased timeout for "Available Assets" from 10s to 45s
 * The asset list requires:
 * - Flow initialization to complete
 * - Backend to return formData with asset options
 * - AssetSelectionForm component to render
 * This can take up to 45 seconds (matching questionnaire generation timeout)
 *
 * Generated by CC (Claude Code) for qa-playwright-tester agent
 */

import { test, expect } from '@playwright/test';
import { execSync } from 'child_process';

const BASE_URL = 'http://localhost:8081';
const API_URL = 'http://localhost:8000';

// Demo user credentials for testing
const TEST_USER = {
  email: 'demo@demo-corp.com',
  password: 'Demo123!'
};

// Test configuration
const TEST_CONFIG = {
  maxWaitTimeMs: 60000, // 60 seconds max wait for gap analysis
  pollIntervalMs: 5000,  // Poll every 5 seconds
  minExpectedGaps: 1,    // Minimum gaps expected
  flowCleanupTimeoutMs: 10000
};

/**
 * Helper function to execute database queries via Docker
 */
function queryDatabase(sql: string): string {
  try {
    const command = `docker exec migration_postgres psql -U postgres -d migration_db -t -c "${sql}"`;
    const result = execSync(command, { encoding: 'utf-8' });
    return result.trim();
  } catch (error) {
    console.error('âŒ Database query failed:', error);
    throw error;
  }
}

/**
 * Helper function to clean up blocking flows from previous test runs
 */
function cleanupBlockingFlows(): void {
  console.log('ðŸ§¹ Cleaning up blocking flows from previous test runs...');

  try {
    // Delete gaps first (due to foreign key constraints)
    const deleteGapsSql = `
      DELETE FROM migration.collection_data_gaps
      WHERE collection_flow_id IN (
        SELECT id FROM migration.collection_flows
        WHERE status NOT IN ('completed', 'failed', 'cancelled')
      );
    `;
    queryDatabase(deleteGapsSql);
    console.log('âœ… Deleted gaps from incomplete flows');

    // Delete incomplete flows
    const deleteFlowsSql = `
      DELETE FROM migration.collection_flows
      WHERE status NOT IN ('completed', 'failed', 'cancelled');
    `;
    const deleteResult = queryDatabase(deleteFlowsSql);
    console.log('âœ… Deleted incomplete flows:', deleteResult);

  } catch (error) {
    console.warn('âš ï¸ Cleanup encountered an error (may be expected if no flows exist):', error);
  }
}

/**
 * Helper function to verify gaps in database
 */
function verifyGapsInDatabase(flowId?: string): { total_gaps: number; details: string } {
  console.log('ðŸ” Verifying gaps in database...');

  const sql = flowId
    ? `
      SELECT
        COUNT(*) as total_gaps,
        gap_type,
        gap_category,
        priority,
        field_name
      FROM migration.collection_data_gaps
      WHERE collection_flow_id = (
        SELECT id FROM migration.collection_flows WHERE flow_id = '${flowId}'
      )
      GROUP BY gap_type, gap_category, priority, field_name
      ORDER BY priority ASC, gap_category, gap_type;
    `
    : `
      SELECT
        COUNT(*) as total_gaps,
        gap_type,
        gap_category,
        priority
      FROM migration.collection_data_gaps
      WHERE created_at > NOW() - INTERVAL '5 minutes'
      GROUP BY gap_type, gap_category, priority
      ORDER BY priority ASC;
    `;

  const result = queryDatabase(sql);
  console.log('ðŸ“Š Database query result:', result);

  // Parse the result to extract total gaps
  const lines = result.split('\n').filter(line => line.trim());
  const total_gaps = lines.length;

  return {
    total_gaps,
    details: result
  };
}

test.describe('NEW Lean Collection Flow Gap Analysis', () => {

  test.beforeAll(async () => {
    console.log('ðŸ§ª Starting NEW Lean Collection Flow Gap Analysis E2E Test...');
    console.log('ðŸ“ Test Configuration:', TEST_CONFIG);

    // Clean up any blocking flows before starting test
    cleanupBlockingFlows();
  });

  test.beforeEach(async ({ page }) => {
    // Set up console log capture
    page.on('console', msg => {
      const type = msg.type();
      if (type === 'error' || type === 'warning') {
        console.log(`ðŸ–¥ï¸ Browser ${type}: ${msg.text()}`);
      }
    });

    // Set up network request monitoring
    page.on('requestfailed', request => {
      console.log(`âŒ Network request failed: ${request.url()}`);
    });
  });

  test('should execute complete gap analysis flow with database verification', async ({ page }) => {

    // STEP 1: LOGIN
    console.log('\nðŸ“ STEP 1: Logging in as demo user...');
    await page.goto(`${BASE_URL}/login`);
    await page.waitForLoadState('networkidle');

    // Wait for form to be ready
    await page.waitForSelector('input[type="email"]', { state: 'visible', timeout: 5000 });
    await page.waitForSelector('input[type="password"]', { state: 'visible', timeout: 5000 });

    // Fill login form - use more specific selectors and ensure fields are filled
    const emailInput = page.locator('input[type="email"]').first();
    const passwordInput = page.locator('input[type="password"]').first();

    await emailInput.fill(TEST_USER.email);
    await passwordInput.fill(TEST_USER.password);

    // Verify fields are filled
    await expect(emailInput).toHaveValue(TEST_USER.email);
    await expect(passwordInput).toHaveValue(TEST_USER.password);

    // Click login button and wait for navigation
    const [response] = await Promise.all([
      page.waitForResponse(response => response.url().includes('/api/v1/auth/login') && response.status() === 200),
      page.click('button:has-text("Sign In")')
    ]);

    console.log('âœ… Login API responded with:', response.status());

    // Wait for navigation away from login page
    await page.waitForURL(url => !url.pathname.includes('/login'), { timeout: 10000 });
    console.log('âœ… Login successful, redirected to:', page.url());

    // Take screenshot after login
    await page.screenshot({ path: 'test-results/01-after-login.png', fullPage: false });

    // STEP 2: NAVIGATE TO ADAPTIVE FORMS
    console.log('\nðŸ“ STEP 2: Navigating to Collection â†’ Adaptive Forms...');
    await page.goto(`${BASE_URL}/collection/adaptive-forms`);
    await page.waitForLoadState('networkidle');
    await page.waitForTimeout(2000); // Allow UI to settle

    console.log('âœ… Navigated to Adaptive Forms:', page.url());
    await page.screenshot({ path: 'test-results/02-adaptive-forms-page.png', fullPage: true });

    // STEP 3: CHECK FOR EXISTING INCOMPLETE FLOWS
    console.log('\nðŸ“ STEP 3: Checking for incomplete flows that might block new flow creation...');

    // Look for "Collection Blocked" alert
    const blockedAlert = page.locator('text=/Collection Blocked/i');
    const isBlocked = await blockedAlert.isVisible({ timeout: 5000 }).catch(() => false);

    if (isBlocked) {
      console.log('âš ï¸ Collection blocked by existing flow, deleting it...');

      // Find and click the Delete button for the blocking flow
      const deleteButton = page.locator('button:has-text("Delete")').first();
      if (await deleteButton.isVisible({ timeout: 3000 })) {
        await deleteButton.click();
        await page.waitForTimeout(2000);

        // Confirm deletion if there's a confirmation dialog
        const confirmButton = page.locator('button:has-text("Confirm"), button:has-text("Yes"), button:has-text("Delete")').first();
        if (await confirmButton.isVisible({ timeout: 2000 })) {
          await confirmButton.click();
          await page.waitForTimeout(1000);
        }

        console.log('âœ… Deleted blocking flow');

        // Refresh the page to show the clean state
        await page.reload();
        await page.waitForLoadState('networkidle');
        await page.waitForTimeout(2000);
        console.log('âœ… Page refreshed after flow deletion');
      }
    }

    // STEP 4: START NEW COLLECTION FLOW
    console.log('\nðŸ“ STEP 4: Starting NEW collection flow...');

    // Look for "Start" or "New" button
    const startButton = page.locator(
      'button:has-text("Start Collection"), ' +
      'button:has-text("New Collection"), ' +
      'button:has-text("Start Flow"), ' +
      'button:has-text("Create Flow"), ' +
      '[data-testid="start-collection-button"]'
    ).first();

    if (await startButton.isVisible({ timeout: 5000 })) {
      await startButton.click();
      await page.waitForTimeout(2000);
      console.log('âœ… Clicked start collection button');
    } else {
      console.log('âš ï¸ No explicit start button found, flow may auto-start');
    }

    await page.screenshot({ path: 'test-results/03-flow-started.png', fullPage: true });

    // STEP 5: SELECT ASSETS
    console.log('\nðŸ“ STEP 5: Selecting 2-3 assets for gap analysis...');

    // Wait for page to finish initializing - check for loading indicators
    console.log('â³ Waiting for page initialization to complete...');
    const loadingIndicators = page.locator('text=/loading|initializing/i').first();
    const isLoading = await loadingIndicators.isVisible({ timeout: 3000 }).catch(() => false);
    if (isLoading) {
      console.log('ðŸ”„ Page is loading, waiting for completion...');
      try {
        await loadingIndicators.waitFor({ state: 'hidden', timeout: 30000 });
        console.log('âœ… Loading completed');
      } catch (e) {
        console.log('âš ï¸ Loading indicator still visible after 30s, continuing anyway...');
      }
    }

    // Check if questionnaire generation modal is showing and wait for it to complete
    const questionnaireModal = page.locator('text=/Generating.*Questionnaire/i').first();
    if (await questionnaireModal.isVisible({ timeout: 5000 })) {
      console.log('âš ï¸ Questionnaire generation modal detected, waiting for completion...');

      // Wait for modal to disappear (up to 45 seconds for generation to complete)
      try {
        await questionnaireModal.waitFor({ state: 'hidden', timeout: 45000 });
        console.log('âœ… Questionnaire generation completed');
      } catch (e) {
        console.log('âš ï¸ Modal still visible after 45s, attempting to close manually...');
        const closeButton = page.locator('button:has-text("Close")').first();
        if (await closeButton.isVisible({ timeout: 2000 })) {
          await closeButton.click();
          await page.waitForTimeout(1000);
          console.log('âœ… Closed questionnaire modal manually');
        }
      }
    }

    // Additional wait for form data to load
    console.log('â³ Allowing time for form data and assets to load...');
    await page.waitForTimeout(2000);

    // Wait for asset list to load - this may take longer as the flow initializes
    // CRITICAL: The "Available Assets" text only appears after:
    // 1. Flow initialization completes
    // 2. Backend returns formData with asset options
    // 3. AssetSelectionForm component renders
    // Increased timeout to 45s to match questionnaire generation timeout
    try {
      await page.waitForSelector('text=/Available Assets/i', { timeout: 45000 });
      console.log('âœ… Asset list section found');
      await page.waitForTimeout(3000); // Allow assets to fully render
    } catch (timeoutError) {
      console.error('âŒ Timeout waiting for "Available Assets" section');
      console.log('ðŸ“¸ Taking debug screenshot of current page state...');
      await page.screenshot({ path: 'test-results/05-timeout-no-assets.png', fullPage: true });

      // Check what's actually on the page
      const pageContent = await page.content();
      console.log('ðŸ“„ Page contains "loading":', pageContent.toLowerCase().includes('loading'));
      console.log('ðŸ“„ Page contains "error":', pageContent.toLowerCase().includes('error'));
      console.log('ðŸ“„ Page contains "collection":', pageContent.toLowerCase().includes('collection'));

      throw new Error('Timeout waiting for asset list to load. Check test-results/05-timeout-no-assets.png for details.');
    }

    // Screenshot current state for debugging
    await page.screenshot({ path: 'test-results/05-before-asset-selection.png', fullPage: true });

    // Try direct clicking on the first 3 visible asset text elements (based on screenshot showing they're clickable)
    const assetTextElements = page.locator('text=/^10\\.\\d+\\.\\d+\\.\\d+/');  // Match IP addresses like 10.1.1.1
    const assetCount = await assetTextElements.count();

    console.log(`Found ${assetCount} assets with IP addresses`);

    // Move selectCount declaration to higher scope for use in final summary
    let selectCount = 0;

    if (assetCount > 0) {
      selectCount = Math.min(3, assetCount);
      console.log(`Clicking ${selectCount} assets...`);

      for (let i = 0; i < selectCount; i++) {
        try {
          await assetTextElements.nth(i).click();
          await page.waitForTimeout(500);
          const assetText = await assetTextElements.nth(i).textContent();
          console.log(`âœ… Clicked asset ${i + 1}: ${assetText?.substring(0, 30)}`);
        } catch (e) {
          console.log(`âš ï¸ Failed to click asset ${i + 1}: ${e}`);
        }
      }

      console.log(`âœ… Selected ${selectCount} assets`);
      await page.screenshot({ path: 'test-results/04-assets-selected.png', fullPage: true });
    } else {
      console.log('âŒ No assets found, taking debug screenshot...');
      await page.screenshot({ path: 'test-results/04-no-assets-debug.png', fullPage: true });
      throw new Error('âŒ No selectable assets found!');
    }

    // STEP 6: PROCEED TO GAP ANALYSIS
    console.log('\nðŸ“ STEP 6: Proceeding to gap analysis phase...');

    // Find and click Next/Continue/Analyze button
    const nextButton = page.locator(
      'button:has-text("Next"), ' +
      'button:has-text("Continue"), ' +
      'button:has-text("Analyze"), ' +
      'button:has-text("Proceed"), ' +
      '[data-testid*="next"], ' +
      '[data-testid*="continue"]'
    ).first();

    if (await nextButton.isVisible({ timeout: 5000 })) {
      await nextButton.click();
      console.log('âœ… Clicked next/continue button');
      await page.waitForTimeout(2000);
    } else {
      throw new Error('âŒ Could not find Next/Continue button to proceed to gap analysis');
    }

    // Wait for gap analysis phase to start
    await page.waitForSelector(
      'text=/Gap Analysis|Analyzing|Analysis.*Progress/i, ' +
      '[data-testid*="gap-analysis"], ' +
      '[data-phase="gap_analysis"]',
      { timeout: 10000 }
    );
    console.log('ðŸ¤– Gap analysis phase started!');
    await page.screenshot({ path: 'test-results/05-gap-analysis-started.png', fullPage: true });

    // STEP 7: WAIT FOR GAP ANALYSIS COMPLETION (with polling)
    console.log('\nðŸ“ STEP 7: Waiting for gap analysis completion (max 60 seconds, 5-second polling)...');

    let analysisComplete = false;
    let attempts = 0;
    const maxAttempts = TEST_CONFIG.maxWaitTimeMs / TEST_CONFIG.pollIntervalMs; // 12 attempts (60 seconds)

    while (!analysisComplete && attempts < maxAttempts) {
      await page.waitForTimeout(TEST_CONFIG.pollIntervalMs); // Poll every 5 seconds
      attempts++;

      console.log(`â³ Polling attempt ${attempts}/${maxAttempts}...`);

      // Check for completion indicators
      const completedText = await page.locator('text=/completed|finished|done|success/i').isVisible().catch(() => false);
      const gapsDetectedText = await page.locator('text=/gaps.*detected|gaps.*found|gaps.*identified/i').isVisible().catch(() => false);
      const questionnaireVisible = await page.locator('text=/questionnaire|questions/i').isVisible().catch(() => false);
      const nextPhaseButton = await page.locator('button:has-text("Next"), button:has-text("Continue"), button:has-text("Proceed")').isVisible().catch(() => false);

      // Check for error states
      const errorText = await page.locator('text=/error|failed/i').isVisible().catch(() => false);

      if (errorText) {
        const errorMessage = await page.locator('text=/error|failed/i').first().textContent();
        console.error(`âŒ Error detected during gap analysis: ${errorMessage}`);
        await page.screenshot({ path: 'test-results/error-gap-analysis.png', fullPage: true });
        throw new Error(`Gap analysis failed with error: ${errorMessage}`);
      }

      if (completedText || gapsDetectedText || questionnaireVisible || nextPhaseButton) {
        analysisComplete = true;
        console.log('âœ… Gap analysis completed!');
        console.log(`  - Completion text: ${completedText}`);
        console.log(`  - Gaps detected text: ${gapsDetectedText}`);
        console.log(`  - Questionnaire visible: ${questionnaireVisible}`);
        console.log(`  - Next button visible: ${nextPhaseButton}`);
      } else {
        console.log(`  â³ Still analyzing... (${attempts * TEST_CONFIG.pollIntervalMs / 1000}s elapsed)`);
      }
    }

    if (!analysisComplete) {
      await page.screenshot({ path: 'test-results/timeout-gap-analysis.png', fullPage: true });
      throw new Error('âŒ Gap analysis did not complete within 60 seconds');
    }

    await page.screenshot({ path: 'test-results/06-gap-analysis-completed.png', fullPage: true });

    // STEP 8: VERIFY GAPS DETECTED MESSAGE IN UI
    console.log('\nðŸ“ STEP 8: Verifying gaps detected message in UI...');

    const gapsMessage = page.locator('text=/gaps.*detected|gaps.*found|gaps.*identified/i');
    const hasGapsMessage = await gapsMessage.isVisible();

    if (hasGapsMessage) {
      const messageText = await gapsMessage.first().textContent();
      console.log(`âœ… Gaps detected message: "${messageText}"`);
    } else {
      console.warn('âš ï¸ No explicit gaps detected message found in UI');
    }

    // STEP 9: EXTRACT FLOW ID AND VERIFY GAPS IN DATABASE
    console.log('\nðŸ“ STEP 9: Extracting flow ID and verifying gaps in database...');

    // Try to extract flow ID from URL
    const currentUrl = page.url();
    let flowId: string | null = null;

    const flowIdMatches = [
      currentUrl.match(/flowId=([a-f0-9-]+)/i),
      currentUrl.match(/flow[_-]?id=([a-f0-9-]+)/i),
      currentUrl.match(/collection\/([a-f0-9-]+)/i)
    ];

    for (const match of flowIdMatches) {
      if (match && match[1]) {
        flowId = match[1];
        break;
      }
    }

    if (!flowId) {
      // Try to get from page state/attributes
      const flowIdElement = await page.locator('[data-flow-id], [data-collection-flow-id]').first();
      if (await flowIdElement.isVisible({ timeout: 3000 })) {
        flowId = await flowIdElement.getAttribute('data-flow-id') ||
                 await flowIdElement.getAttribute('data-collection-flow-id');
      }
    }

    console.log(`ðŸ” Collection flow ID: ${flowId || 'Not found in UI, will query by time'}`);

    // Query database to verify gaps
    const gapVerification = verifyGapsInDatabase(flowId || undefined);

    console.log(`ðŸ“Š Database Verification Results:`);
    console.log(`   Total gaps: ${gapVerification.total_gaps}`);
    console.log(`   Details:\n${gapVerification.details}`);

    // Assert minimum gaps detected
    expect(gapVerification.total_gaps).toBeGreaterThanOrEqual(TEST_CONFIG.minExpectedGaps);
    console.log(`âœ… Verified ${gapVerification.total_gaps} gaps persisted to database (expected >= ${TEST_CONFIG.minExpectedGaps})`);

    // STEP 10: VERIFY QUESTIONNAIRE (if applicable)
    console.log('\nðŸ“ STEP 10: Verifying questionnaire display...');

    const questionnaireHeader = page.locator('text=/questionnaire|questions/i');
    const questionnaireVisible = await questionnaireHeader.isVisible({ timeout: 5000 }).catch(() => false);

    if (questionnaireVisible) {
      console.log('âœ… Questionnaire displayed in UI');

      // Try to count questions
      const questionElements = page.locator(
        '[data-testid*="question"], ' +
        '.question, ' +
        '[class*="question"], ' +
        'input[type="text"], ' +
        'input[type="radio"], ' +
        'textarea'
      );
      const questionCount = await questionElements.count();
      console.log(`ðŸ“‹ Found ${questionCount} potential question/input elements in questionnaire`);

      await page.screenshot({ path: 'test-results/07-questionnaire-displayed.png', fullPage: true });
    } else {
      console.log('â„¹ï¸ Questionnaire not yet visible (may appear in next phase or after user action)');
    }

    // FINAL VERIFICATION
    console.log('\nðŸŽ‰ Test completed successfully!');
    console.log('ðŸ“ Summary:');
    console.log(`   âœ… Login successful`);
    console.log(`   âœ… Navigated to Adaptive Forms`);
    console.log(`   âœ… Started new collection flow`);
    console.log(`   âœ… Selected ${selectCount} assets`);
    console.log(`   âœ… Gap analysis completed in ${attempts * TEST_CONFIG.pollIntervalMs / 1000}s`);
    console.log(`   âœ… ${gapVerification.total_gaps} gaps verified in database`);
    console.log(`   ${questionnaireVisible ? 'âœ…' : 'â„¹ï¸'} Questionnaire ${questionnaireVisible ? 'displayed' : 'pending'}`);

    await page.screenshot({ path: 'test-results/08-final-state.png', fullPage: true });
  });

  test('should verify database schema and gap structure', async () => {
    console.log('\nðŸ—„ï¸ Verifying database schema and gap data structure...');

    // Verify table exists and has correct structure
    const tableCheckSql = `
      SELECT column_name, data_type
      FROM information_schema.columns
      WHERE table_schema = 'migration'
      AND table_name = 'collection_data_gaps'
      ORDER BY ordinal_position;
    `;

    const schemaResult = queryDatabase(tableCheckSql);
    console.log('ðŸ“Š collection_data_gaps table schema:');
    console.log(schemaResult);

    // Verify required columns exist
    const requiredColumns = ['id', 'collection_flow_id', 'gap_type', 'gap_category', 'field_name', 'priority'];
    for (const column of requiredColumns) {
      expect(schemaResult.toLowerCase()).toContain(column.toLowerCase());
    }
    console.log('âœ… All required columns present in table schema');

    // Check if we have any recent gaps
    const recentGapsSql = `
      SELECT
        COUNT(*) as total,
        COUNT(DISTINCT gap_type) as distinct_types,
        COUNT(DISTINCT gap_category) as distinct_categories,
        MIN(priority) as min_priority,
        MAX(priority) as max_priority
      FROM migration.collection_data_gaps
      WHERE created_at > NOW() - INTERVAL '10 minutes';
    `;

    const gapStats = queryDatabase(recentGapsSql);
    console.log('ðŸ“Š Recent gap statistics (last 10 minutes):');
    console.log(gapStats);

    console.log('âœ… Database schema verification complete');
  });

  test.afterAll(async () => {
    console.log('\nðŸ§¹ Test suite completed. Database state preserved for inspection.');
    console.log('ðŸ’¡ To manually inspect gaps, run:');
    console.log('   docker exec migration_postgres psql -U postgres -d migration_db -c "SELECT * FROM migration.collection_data_gaps ORDER BY created_at DESC LIMIT 10;"');
  });
});
