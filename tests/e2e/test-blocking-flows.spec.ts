/**
 * Focused Test for Blocking Flow Handling
 * Tests specifically the blocking flow detection and resolution logic
 *
 * Generated by CC
 */

import { test, expect } from '@playwright/test';
import {
  login,
  navigateToDiscovery,
  ensureCleanUploadState,
  handleBlockingFlows,
  takeScreenshot,
  TEST_USERS,
  generateTestCSV
} from './helpers/test-helpers';
import * as path from 'path';
import * as fs from 'fs';

test.describe('Blocking Flow Handling Tests', () => {
  let testDataFile: string;

  test.beforeAll(async () => {
    // Create test data file
    const testDir = path.join(process.cwd(), 'tests', 'e2e', 'test-data');
    if (!fs.existsSync(testDir)) {
      fs.mkdirSync(testDir, { recursive: true });
    }

    testDataFile = path.join(testDir, `test-blocking-${Date.now()}.csv`);
    const csvData = generateTestCSV(10);
    fs.writeFileSync(testDataFile, csvData);
    console.log(`Created test data file: ${testDataFile}`);
  });

  test.afterAll(async () => {
    // Cleanup test data file
    if (fs.existsSync(testDataFile)) {
      fs.unlinkSync(testDataFile);
      console.log(`Cleaned up test data file: ${testDataFile}`);
    }
  });

  test('Can handle clean upload state', async ({ page }) => {
    console.log('\n=== TESTING CLEAN UPLOAD STATE ===');

    // Login
    await login(page, TEST_USERS.demo);

    // Ensure clean upload state
    await ensureCleanUploadState(page);
    await takeScreenshot(page, 'clean-upload-state');

    // Verify upload area is ready
    const fileInput = page.locator('input[type="file"]');
    const uploadArea = page.locator('.upload-area, .border-dashed');

    const hasFileInput = await fileInput.isVisible();
    const hasUploadArea = await uploadArea.isVisible();

    expect(hasFileInput || hasUploadArea).toBeTruthy();
    console.log('✓ Upload area is accessible');

    // Check no blocking message exists
    const blockingMessage = page.locator('text="Upload Blocked"');
    const isBlocked = await blockingMessage.isVisible({ timeout: 2000 });

    expect(isBlocked).toBeFalsy();
    console.log('✓ No blocking message present');
  });

  test('Can detect and handle blocking flows', async ({ page }) => {
    console.log('\n=== TESTING BLOCKING FLOW DETECTION ===');

    // Login
    await login(page, TEST_USERS.demo);

    // Navigate to discovery
    await navigateToDiscovery(page);

    // Try to handle blocking flows (should return false if none exist)
    const blockingHandled = await handleBlockingFlows(page);

    console.log(`Blocking flow handling result: ${blockingHandled}`);
    console.log('✓ Blocking flow handler executed without errors');

    await takeScreenshot(page, 'blocking-flow-detection-test');
  });

  test('Can recover from blocked upload scenario', async ({ page }) => {
    console.log('\n=== TESTING UPLOAD RECOVERY FROM BLOCKING SCENARIO ===');

    // Login
    await login(page, TEST_USERS.demo);

    // Use ensureCleanUploadState which should handle any blocking scenarios
    await ensureCleanUploadState(page);

    // Verify we can access upload functionality
    const fileInput = page.locator('input[type="file"]');
    const uploadArea = page.locator('.upload-area, .border-dashed');

    const canUpload = await fileInput.isVisible() || await uploadArea.isVisible();
    expect(canUpload).toBeTruthy();

    console.log('✓ Upload functionality is accessible after cleanup');
    await takeScreenshot(page, 'upload-recovery-test');
  });
});
