#!/usr/bin/env node

/**
 * E2E Test Setup Validation Script
 * Validates that all test files are properly structured and dependencies are available
 * Generated by CC
 */

const fs = require('fs');
const path = require('path');

// Colors for console output
const colors = {
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    reset: '\x1b[0m'
};

function log(color, message) {
    console.log(`${colors[color]}${message}${colors.reset}`);
}

function printSection(title) {
    console.log('');
    log('blue', '='.repeat(50));
    log('blue', title);
    log('blue', '='.repeat(50));
}

function validateTestFile(filePath, testName) {
    log('yellow', `Validating ${testName}...`);

    if (!fs.existsSync(filePath)) {
        log('red', `‚ùå ${testName} file not found: ${filePath}`);
        return false;
    }

    const content = fs.readFileSync(filePath, 'utf8');
    const checks = [
        {
            name: 'Import statements',
            test: /import.*@playwright\/test/,
            required: true
        },
        {
            name: 'Test helpers import',
            test: /from.*test-helpers/,
            required: true
        },
        {
            name: 'Test describe block',
            test: /test\.describe\(/,
            required: true
        },
        {
            name: 'Happy path test',
            test: /Happy Path.*async.*\{/,
            required: true
        },
        {
            name: 'beforeEach setup',
            test: /test\.beforeEach/,
            required: true
        },
        {
            name: 'afterEach cleanup',
            test: /test\.afterEach/,
            required: true
        },
        {
            name: 'Console error monitoring',
            test: /consoleErrors/,
            required: true
        },
        {
            name: 'Network error monitoring',
            test: /networkErrors/,
            required: true
        },
        {
            name: 'Screenshot capture',
            test: /takeScreenshot/,
            required: true
        },
        {
            name: 'Login functionality',
            test: /login\(/,
            required: true
        }
    ];

    let passed = 0;
    let failed = 0;

    checks.forEach(check => {
        if (check.test.test(content)) {
            log('green', `  ‚úì ${check.name}`);
            passed++;
        } else if (check.required) {
            log('red', `  ‚ùå Missing: ${check.name}`);
            failed++;
        } else {
            log('yellow', `  ‚ö† Optional: ${check.name}`);
        }
    });

    // Count test methods
    const testMatches = content.match(/test\(/g) || [];
    log('blue', `  üìù Found ${testMatches.length} test methods`);

    if (failed === 0) {
        log('green', `‚úÖ ${testName} validation passed (${passed} checks)`);
        return true;
    } else {
        log('red', `‚ùå ${testName} validation failed (${failed} issues)`);
        return false;
    }
}

function validateTestHelpers() {
    const helpersPath = path.join(__dirname, 'helpers', 'test-helpers.ts');
    log('yellow', 'Validating test helpers...');

    if (!fs.existsSync(helpersPath)) {
        log('red', '‚ùå Test helpers file not found');
        return false;
    }

    const content = fs.readFileSync(helpersPath, 'utf8');
    const requiredExports = [
        'TEST_CONFIG',
        'TEST_USERS',
        'TEST_DATA',
        'login',
        'navigateToDiscovery',
        'navigateToCollection',
        'navigateToAssessment',
        'uploadFile',
        'takeScreenshot',
        'waitForElement',
        'clickWithRetry',
        'waitForAgents',
        'cleanup',
        'generateTestCSV'
    ];

    let passed = 0;
    let failed = 0;

    requiredExports.forEach(exportName => {
        if (content.includes(`export async function ${exportName}`) ||
            content.includes(`export function ${exportName}`) ||
            content.includes(`export const ${exportName}`)) {
            log('green', `  ‚úì ${exportName} exported`);
            passed++;
        } else {
            log('red', `  ‚ùå Missing export: ${exportName}`);
            failed++;
        }
    });

    if (failed === 0) {
        log('green', `‚úÖ Test helpers validation passed (${passed} exports)`);
        return true;
    } else {
        log('red', `‚ùå Test helpers validation failed (${failed} missing exports)`);
        return false;
    }
}

function validateFixtures() {
    log('yellow', 'Validating test fixtures...');

    const fixtures = [
        'test-discovery-data.csv',
        'enterprise-cmdb-data.csv',
        'assessment-test-applications.json'
    ];

    let passed = 0;
    let failed = 0;

    fixtures.forEach(fixture => {
        const fixturePath = path.join(__dirname, '..', 'fixtures', fixture);
        if (fs.existsSync(fixturePath)) {
            const stats = fs.statSync(fixturePath);
            if (stats.size > 0) {
                log('green', `  ‚úì ${fixture} (${stats.size} bytes)`);
                passed++;
            } else {
                log('red', `  ‚ùå ${fixture} is empty`);
                failed++;
            }
        } else {
            log('red', `  ‚ùå Missing fixture: ${fixture}`);
            failed++;
        }
    });

    if (failed === 0) {
        log('green', `‚úÖ Fixtures validation passed (${passed} files)`);
        return true;
    } else {
        log('red', `‚ùå Fixtures validation failed (${failed} issues)`);
        return false;
    }
}

function validatePlaywrightConfig() {
    log('yellow', 'Validating Playwright configuration...');

    const configPath = path.join(__dirname, 'playwright.config.ts');
    if (!fs.existsSync(configPath)) {
        log('red', '‚ùå Playwright config not found');
        return false;
    }

    const content = fs.readFileSync(configPath, 'utf8');
    const checks = [
        'testDir:',
        'baseURL:',
        'trace:',
        'screenshot:',
        'video:'
    ];

    let passed = 0;
    checks.forEach(check => {
        if (content.includes(check)) {
            log('green', `  ‚úì ${check}`);
            passed++;
        }
    });

    log('green', `‚úÖ Playwright config validation passed (${passed} settings)`);
    return true;
}

function validateDirectories() {
    log('yellow', 'Validating directory structure...');

    const requiredDirs = [
        'helpers',
        'test-data',
        'screenshots',
        '../fixtures'
    ];

    let passed = 0;
    let created = 0;

    requiredDirs.forEach(dir => {
        const dirPath = path.join(__dirname, dir);
        if (fs.existsSync(dirPath)) {
            log('green', `  ‚úì ${dir}/ exists`);
            passed++;
        } else {
            try {
                fs.mkdirSync(dirPath, { recursive: true });
                log('yellow', `  üìÅ Created ${dir}/`);
                created++;
            } catch (error) {
                log('red', `  ‚ùå Failed to create ${dir}/`);
            }
        }
    });

    log('green', `‚úÖ Directory validation passed (${passed} exist, ${created} created)`);
    return true;
}

function checkNodeDependencies() {
    log('yellow', 'Checking Node.js dependencies...');

    const packageJsonPath = path.join(__dirname, '..', '..', 'package.json');
    if (!fs.existsSync(packageJsonPath)) {
        log('red', '‚ùå package.json not found');
        return false;
    }

    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };

    const requiredDeps = [
        '@playwright/test',
        'typescript'
    ];

    let passed = 0;
    let failed = 0;

    requiredDeps.forEach(dep => {
        if (dependencies[dep]) {
            log('green', `  ‚úì ${dep} (${dependencies[dep]})`);
            passed++;
        } else {
            log('red', `  ‚ùå Missing dependency: ${dep}`);
            failed++;
        }
    });

    if (failed === 0) {
        log('green', `‚úÖ Dependencies validation passed (${passed} found)`);
        return true;
    } else {
        log('red', `‚ùå Dependencies validation failed (${failed} missing)`);
        log('yellow', '  Run: npm install @playwright/test typescript');
        return false;
    }
}

function main() {
    printSection('E2E Test Setup Validation');
    console.log('Validating comprehensive E2E test setup...\n');

    const results = [];

    // Validate individual components
    results.push(validateDirectories());
    results.push(checkNodeDependencies());
    results.push(validatePlaywrightConfig());
    results.push(validateTestHelpers());
    results.push(validateFixtures());

    // Validate test files
    const testFiles = [
        {
            path: path.join(__dirname, 'discovery-flow-e2e.spec.ts'),
            name: 'Discovery Flow Tests'
        },
        {
            path: path.join(__dirname, 'collection-flow-e2e.spec.ts'),
            name: 'Collection Flow Tests'
        },
        {
            path: path.join(__dirname, 'assessment-flow-e2e.spec.ts'),
            name: 'Assessment Flow Tests'
        }
    ];

    testFiles.forEach(testFile => {
        results.push(validateTestFile(testFile.path, testFile.name));
    });

    // Summary
    printSection('VALIDATION SUMMARY');

    const passed = results.filter(r => r).length;
    const total = results.length;
    const failed = total - passed;

    console.log(`Total Validations: ${total}`);
    log('green', `Passed: ${passed}`);

    if (failed > 0) {
        log('red', `Failed: ${failed}`);
    }

    console.log('');

    if (passed === total) {
        log('green', 'üéâ ALL VALIDATIONS PASSED!');
        log('green', '‚úÖ E2E test setup is ready');
        log('blue', 'Run tests with: ./tests/e2e/run-comprehensive-tests.sh');
        process.exit(0);
    } else {
        log('red', '‚ùå VALIDATION ISSUES FOUND');
        log('yellow', 'Please fix the issues above before running tests');
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}

module.exports = {
    validateTestFile,
    validateTestHelpers,
    validateFixtures,
    validatePlaywrightConfig,
    validateDirectories,
    checkNodeDependencies
};
