import { test, expect, Page } from '@playwright/test';
import path from 'path';

/**
 * Performance and Timeout Validation Test Suite
 * 
 * Tests extended timeout scenarios and slow-loading phases that were identified:
 * 1. Extended loading states in certain phases
 * 2. Performance under normal and stress conditions
 * 3. Timeout handling for slow network conditions
 * 4. Resource loading validation
 * 5. Memory usage and cleanup
 * 
 * Generated by CC (Claude Code)
 */

const BASE_URL = 'http://localhost:8081';
const API_URL = 'http://localhost:8000';

const TEST_USER = {
  email: 'chocka@gmail.com',
  password: 'Password123!'
};

interface PerformanceMetrics {
  phase: string;
  startTime: number;
  endTime: number;
  duration: number;
  success: boolean;
  errorMessage?: string;
  networkRequests: number;
  resourceSizes: number[];
}

interface TimeoutTestResult {
  phase: string;
  expectedTimeout: number;
  actualTimeout: number;
  timedOut: boolean;
  gracefulHandling: boolean;
  userFeedback: boolean;
}

// Helper function to perform login
async function loginUser(page: Page): Promise<void> {
  await page.goto(`${BASE_URL}/login`);
  await page.fill('input[type="email"]', TEST_USER.email);
  await page.fill('input[type="password"]', TEST_USER.password);
  await page.click('button[type="submit"]');
  await page.waitForURL('**/dashboard', { timeout: 15000 }); // Extended timeout for login
}

// Helper function to monitor network requests
async function monitorNetworkActivity(page: Page): Promise<{ requestCount: number, totalSize: number }> {
  let requestCount = 0;
  let totalSize = 0;

  const responsePromises: Promise<void>[] = [];

  page.on('response', (response) => {
    requestCount++;
    responsePromises.push(
      response.body().then(body => {
        totalSize += body.length;
      }).catch(() => {
        // Ignore errors - some responses may not be accessible
      })
    );
  });

  // Wait a bit for requests to complete
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // Wait for all response body promises to complete
  await Promise.allSettled(responsePromises);

  return { requestCount, totalSize };
}

// Helper function to simulate slow network conditions
async function simulateSlowNetwork(page: Page): Promise<void> {
  await page.route('**/*', (route) => {
    // Add delay to simulate slow network
    setTimeout(() => {
      route.continue();
    }, Math.random() * 1000); // Random delay up to 1 second
  });
}

test.describe('Performance and Timeout Validation', () => {
  test.beforeEach(async ({ page }) => {
    await loginUser(page);
  });

  test('Discovery phase loading performance with extended timeouts', async ({ page }) => {
    const performanceMetrics: PerformanceMetrics[] = [];
    const phases = [
      { name: 'Discovery Overview', url: '/discovery', selector: 'text=/Overview|Active Discovery|Flow Status/i' },
      { name: 'CMDB Import', url: '/discovery/cmdb-import', selector: '.border-dashed, input[type="file"]' },
      { name: 'Attribute Mapping', url: '/discovery/attribute-mapping', selector: '.attribute-mapping, [data-testid="attribute-mapping"]' },
      { name: 'Asset Inventory', url: '/discovery/asset-inventory', selector: '.assets-table, [data-testid="assets-table"]' }
    ];

    for (const phase of phases) {
      await test.step(`Test ${phase.name} loading performance`, async () => {
        const startTime = Date.now();
        let networkActivity = { requestCount: 0, totalSize: 0 };

        try {
          // Start monitoring network activity
          const networkPromise = monitorNetworkActivity(page);
          
          // Navigate to phase
          await page.goto(`${BASE_URL}${phase.url}`);
          
          // Wait for phase to load with extended timeout
          let loadingComplete = false;
          let attempts = 0;
          const maxAttempts = 30; // 60 seconds total
          
          while (!loadingComplete && attempts < maxAttempts) {
            await page.waitForTimeout(2000);
            attempts++;

            // Check for loading completion
            const mainContent = page.locator(phase.selector);
            const loadingSpinner = page.locator('.loading, .spinner, [data-testid="loading"]');
            const errorMessage = page.locator('.error, [role="alert"]');

            if (await errorMessage.isVisible()) {
              const errorText = await errorMessage.textContent();
              throw new Error(`Error in ${phase.name}: ${errorText}`);
            }

            if (await mainContent.isVisible()) {
              // Additional check - ensure content is actually loaded, not just visible
              const contentText = await page.textContent('body');
              if (contentText && contentText.length > 200) {
                loadingComplete = true;
                console.log(`‚úÖ ${phase.name} loaded after ${attempts * 2} seconds`);
              }
            } else if (await loadingSpinner.isVisible()) {
              console.log(`‚è≥ ${phase.name} still loading... (attempt ${attempts})`);
            }

            // Check for extremely slow loading
            if (attempts > 15) { // 30 seconds
              console.warn(`‚ö†Ô∏è ${phase.name} is loading very slowly`);
            }
          }

          const endTime = Date.now();
          networkActivity = await networkPromise;

          const metrics: PerformanceMetrics = {
            phase: phase.name,
            startTime,
            endTime,
            duration: endTime - startTime,
            success: loadingComplete,
            networkRequests: networkActivity.requestCount,
            resourceSizes: [networkActivity.totalSize]
          };

          if (!loadingComplete) {
            metrics.errorMessage = `Failed to load within ${maxAttempts * 2} seconds`;
          }

          performanceMetrics.push(metrics);

          // Assertions for this phase
          expect(loadingComplete, `${phase.name} should load within extended timeout`).toBe(true);
          
          // Performance thresholds
          if (metrics.duration > 15000) { // 15 seconds
            console.warn(`‚ö†Ô∏è ${phase.name} loaded slowly: ${metrics.duration}ms`);
          }
          
          expect(metrics.duration, `${phase.name} should load within 30 seconds`).toBeLessThan(30000);

        } catch (error) {
          const endTime = Date.now();
          performanceMetrics.push({
            phase: phase.name,
            startTime,
            endTime,
            duration: endTime - startTime,
            success: false,
            errorMessage: error.toString(),
            networkRequests: networkActivity.requestCount,
            resourceSizes: [networkActivity.totalSize]
          });
          throw error;
        }
      });
    }

    // Report overall performance
    console.log('\n=== Performance Metrics Summary ===');
    performanceMetrics.forEach(metrics => {
      console.log(`${metrics.phase}: ${metrics.duration}ms (${metrics.success ? 'Success' : 'Failed'})`);
      console.log(`  Network Requests: ${metrics.networkRequests}`);
      console.log(`  Data Size: ${(metrics.resourceSizes[0] / 1024).toFixed(2)} KB`);
    });

    // Overall assertions
    const failedPhases = performanceMetrics.filter(m => !m.success);
    expect(failedPhases.length, 'All phases should load successfully').toBe(0);

    const averageLoadTime = performanceMetrics.reduce((sum, m) => sum + m.duration, 0) / performanceMetrics.length;
    console.log(`Average load time: ${averageLoadTime.toFixed(2)}ms`);
    
    // Warn if average is too high but don't fail
    if (averageLoadTime > 8000) {
      console.warn(`‚ö†Ô∏è Average load time is high: ${averageLoadTime}ms - consider optimization`);
    }
  });

  test('File upload timeout and progress handling', async ({ page }) => {
    const uploadMetrics: PerformanceMetrics[] = [];
    
    await test.step('Test normal file upload performance', async () => {
      await page.goto(`${BASE_URL}/discovery/cmdb-import`);
      await page.waitForTimeout(2000);

      const testFilePath = path.join(__dirname, '../fixtures/test-cmdb-data.csv');
      const startTime = Date.now();

      try {
        // Monitor upload progress
        const uploadArea = page.locator('.border-dashed').first();
        await uploadArea.click();

        const fileInput = page.locator('input[type="file"]');
        await fileInput.setInputFiles(testFilePath);

        // Wait for upload completion with extended timeout
        let uploadComplete = false;
        let attempts = 0;
        const maxAttempts = 45; // 90 seconds for file processing

        while (!uploadComplete && attempts < maxAttempts) {
          await page.waitForTimeout(2000);
          attempts++;

          // Check for completion indicators
          const successMessage = page.locator('text=/Upload completed|Processing complete|Data import complete/i');
          const errorMessage = page.locator('text=/Upload failed|Error|Failed/i');
          const progressIndicator = page.locator('.progress, [data-testid="upload-progress"]');

          if (await successMessage.isVisible()) {
            uploadComplete = true;
            console.log(`‚úÖ Upload completed after ${attempts * 2} seconds`);
          } else if (await errorMessage.isVisible()) {
            const errorText = await errorMessage.textContent();
            throw new Error(`Upload failed: ${errorText}`);
          } else if (await progressIndicator.isVisible()) {
            console.log(`‚è≥ Upload in progress... (attempt ${attempts})`);
          }

          // Log progress for very slow uploads
          if (attempts > 30) { // 60 seconds
            console.warn(`‚ö†Ô∏è Upload is taking unusually long: ${attempts * 2} seconds`);
          }
        }

        const endTime = Date.now();
        const metrics: PerformanceMetrics = {
          phase: 'File Upload',
          startTime,
          endTime,
          duration: endTime - startTime,
          success: uploadComplete,
          networkRequests: 1,
          resourceSizes: []
        };

        if (!uploadComplete) {
          metrics.errorMessage = `Upload timed out after ${maxAttempts * 2} seconds`;
        }

        uploadMetrics.push(metrics);

        // Assertions
        expect(uploadComplete, 'Upload should complete within extended timeout').toBe(true);
        expect(metrics.duration, 'Upload should complete within 90 seconds').toBeLessThan(90000);

      } catch (error) {
        const endTime = Date.now();
        uploadMetrics.push({
          phase: 'File Upload',
          startTime,
          endTime,
          duration: endTime - startTime,
          success: false,
          errorMessage: error.toString(),
          networkRequests: 1,
          resourceSizes: []
        });
        throw error;
      }
    });

    await test.step('Test slow network upload scenario', async () => {
      // Simulate slow network
      await simulateSlowNetwork(page);
      
      await page.goto(`${BASE_URL}/discovery/cmdb-import`);
      await page.waitForTimeout(3000); // Extra time for slow network

      const testFilePath = path.join(__dirname, '../fixtures/enterprise-cmdb-data.csv');
      const startTime = Date.now();

      try {
        const uploadArea = page.locator('.border-dashed').first();
        await uploadArea.click();

        const fileInput = page.locator('input[type="file"]');
        await fileInput.setInputFiles(testFilePath);

        // Extended timeout for slow network
        let uploadComplete = false;
        let userFeedbackProvided = false;
        let attempts = 0;
        const maxAttempts = 60; // 120 seconds for slow network

        while (!uploadComplete && attempts < maxAttempts) {
          await page.waitForTimeout(2000);
          attempts++;

          // Check for user feedback during slow upload
          const loadingIndicator = page.locator('.loading, .spinner, .progress');
          const statusMessage = page.locator('[data-testid="upload-status"], .upload-status');
          const successMessage = page.locator('text=/Upload completed|Processing complete/i');
          const errorMessage = page.locator('text=/Upload failed|Error/i');

          if (await loadingIndicator.isVisible() || await statusMessage.isVisible()) {
            userFeedbackProvided = true;
          }

          if (await successMessage.isVisible()) {
            uploadComplete = true;
            console.log(`‚úÖ Slow network upload completed after ${attempts * 2} seconds`);
          } else if (await errorMessage.isVisible()) {
            const errorText = await errorMessage.textContent();
            throw new Error(`Slow network upload failed: ${errorText}`);
          }

          // Report progress every 20 seconds
          if (attempts % 10 === 0) {
            console.log(`‚è≥ Slow network upload in progress: ${attempts * 2} seconds`);
          }
        }

        const endTime = Date.now();
        const metrics: PerformanceMetrics = {
          phase: 'Slow Network Upload',
          startTime,
          endTime,
          duration: endTime - startTime,
          success: uploadComplete,
          networkRequests: 1,
          resourceSizes: []
        };

        if (!uploadComplete) {
          metrics.errorMessage = `Slow network upload timed out after ${maxAttempts * 2} seconds`;
        }

        uploadMetrics.push(metrics);

        // Assertions - be more lenient for slow network
        expect(uploadComplete, 'Slow network upload should eventually complete').toBe(true);
        expect(userFeedbackProvided, 'User should receive feedback during slow upload').toBe(true);

      } catch (error) {
        const endTime = Date.now();
        uploadMetrics.push({
          phase: 'Slow Network Upload',
          startTime,
          endTime,
          duration: endTime - startTime,
          success: false,
          errorMessage: error.toString(),
          networkRequests: 1,
          resourceSizes: []
        });
        throw error;
      } finally {
        // Remove slow network simulation
        await page.unroute('**/*');
      }
    });

    // Report upload metrics
    console.log('\n=== Upload Performance Metrics ===');
    uploadMetrics.forEach(metrics => {
      console.log(`${metrics.phase}: ${metrics.duration}ms (${metrics.success ? 'Success' : 'Failed'})`);
      if (metrics.errorMessage) {
        console.log(`  Error: ${metrics.errorMessage}`);
      }
    });
  });

  test('Assessment flow timeout handling', async ({ page }) => {
    const timeoutTests: TimeoutTestResult[] = [];

    await test.step('Test assessment initialization with timeout', async () => {
      const startTime = Date.now();
      let timedOut = false;
      let gracefulHandling = false;
      let userFeedback = false;

      try {
        await page.goto(`${BASE_URL}/assessment/initialize`);

        // Wait for assessment to load with monitoring
        let loadingComplete = false;
        let attempts = 0;
        const maxAttempts = 20; // 40 seconds

        while (!loadingComplete && attempts < maxAttempts) {
          await page.waitForTimeout(2000);
          attempts++;

          const loadingSpinner = page.locator('.loading, .spinner');
          const initButton = page.locator('button').filter({ hasText: /Start Assessment|Initialize/i });
          const errorMessage = page.locator('.error, [role="alert"]');
          const statusMessage = page.locator('[data-testid="status"], .status-message');

          if (await statusMessage.isVisible()) {
            userFeedback = true;
          }

          if (await errorMessage.isVisible()) {
            const errorText = await errorMessage.textContent();
            if (errorText?.includes('timeout') || errorText?.includes('slow')) {
              gracefulHandling = true;
            }
          }

          if (await initButton.isVisible()) {
            loadingComplete = true;
            console.log(`‚úÖ Assessment initialization loaded after ${attempts * 2} seconds`);
          }
        }

        if (!loadingComplete) {
          timedOut = true;
          console.log(`‚è≥ Assessment initialization timed out after ${maxAttempts * 2} seconds`);
        }

        const endTime = Date.now();
        timeoutTests.push({
          phase: 'Assessment Initialization',
          expectedTimeout: 30000, // 30 seconds
          actualTimeout: endTime - startTime,
          timedOut,
          gracefulHandling,
          userFeedback
        });

      } catch (error) {
        const endTime = Date.now();
        timeoutTests.push({
          phase: 'Assessment Initialization',
          expectedTimeout: 30000,
          actualTimeout: endTime - startTime,
          timedOut: true,
          gracefulHandling: false,
          userFeedback: false
        });
      }
    });

    await test.step('Test assessment flow with intentional delays', async () => {
      // Add delays to API responses
      await page.route('**/api/v1/assessment/**', async (route) => {
        await new Promise(resolve => setTimeout(resolve, 2000)); // 2 second delay
        route.continue();
      });

      const startTime = Date.now();
      let gracefulHandling = false;
      let userFeedback = false;

      try {
        const initButton = page.locator('button').filter({ hasText: /Start Assessment|Initialize/i }).first();
        
        if (await initButton.isVisible()) {
          await initButton.click();

          // Monitor for timeout handling
          let processingComplete = false;
          let attempts = 0;
          const maxAttempts = 25; // 50 seconds

          while (!processingComplete && attempts < maxAttempts) {
            await page.waitForTimeout(2000);
            attempts++;

            const loadingIndicator = page.locator('.loading, .spinner, [data-testid="loading"]');
            const timeoutMessage = page.locator('text=/timeout|slow|taking longer/i');
            const retryButton = page.locator('button').filter({ hasText: /retry|try again/i });
            const assessmentContent = page.locator('h1, h2').filter({ hasText: /Assessment|Architecture/i });

            if (await loadingIndicator.isVisible()) {
              userFeedback = true;
            }

            if (await timeoutMessage.isVisible() || await retryButton.isVisible()) {
              gracefulHandling = true;
              console.log('‚úÖ Graceful timeout handling detected');
            }

            if (await assessmentContent.isVisible()) {
              processingComplete = true;
              console.log(`‚úÖ Assessment started after ${attempts * 2} seconds`);
            }
          }

          const endTime = Date.now();
          timeoutTests.push({
            phase: 'Assessment Flow Processing',
            expectedTimeout: 40000, // 40 seconds
            actualTimeout: endTime - startTime,
            timedOut: !processingComplete,
            gracefulHandling,
            userFeedback
          });
        }

      } catch (error) {
        const endTime = Date.now();
        timeoutTests.push({
          phase: 'Assessment Flow Processing',
          expectedTimeout: 40000,
          actualTimeout: endTime - startTime,
          timedOut: true,
          gracefulHandling: false,
          userFeedback: false
        });
      } finally {
        // Remove API delays
        await page.unroute('**/api/v1/assessment/**');
      }
    });

    // Report timeout test results
    console.log('\n=== Timeout Handling Results ===');
    timeoutTests.forEach(test => {
      console.log(`${test.phase}:`);
      console.log(`  Duration: ${test.actualTimeout}ms (expected: ${test.expectedTimeout}ms)`);
      console.log(`  Timed Out: ${test.timedOut}`);
      console.log(`  Graceful Handling: ${test.gracefulHandling}`);
      console.log(`  User Feedback: ${test.userFeedback}`);
    });

    // Assertions
    timeoutTests.forEach(test => {
      // Don't fail if timeout occurs, but ensure graceful handling
      if (test.timedOut) {
        expect(test.gracefulHandling, 
          `${test.phase} should handle timeouts gracefully`).toBe(true);
      }
      
      expect(test.userFeedback, 
        `${test.phase} should provide user feedback during long operations`).toBe(true);
    });
  });

  test('Resource loading and cleanup validation', async ({ page }) => {
    const resourceMetrics: Array<{phase: string, memoryUsage: number, networkRequests: number}> = [];

    await test.step('Monitor resource usage across phases', async () => {
      const phases = [
        '/discovery',
        '/discovery/cmdb-import',
        '/discovery/attribute-mapping',
        '/assessment/initialize'
      ];

      for (const phaseUrl of phases) {
        await page.goto(`${BASE_URL}${phaseUrl}`);
        await page.waitForTimeout(3000);

        // Get memory usage (if available)
        const memoryInfo = await page.evaluate(() => {
          // @ts-ignore - performance.memory may not be available in all browsers
          return (performance as any).memory ? {
            usedJSHeapSize: (performance as any).memory.usedJSHeapSize,
            totalJSHeapSize: (performance as any).memory.totalJSHeapSize
          } : { usedJSHeapSize: 0, totalJSHeapSize: 0 };
        });

        // Count network requests
        const networkActivity = await monitorNetworkActivity(page);

        resourceMetrics.push({
          phase: phaseUrl,
          memoryUsage: memoryInfo.usedJSHeapSize,
          networkRequests: networkActivity.requestCount
        });

        console.log(`üìä ${phaseUrl}: Memory: ${(memoryInfo.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB, Requests: ${networkActivity.requestCount}`);
      }
    });

    await test.step('Test memory cleanup on navigation', async () => {
      // Navigate back to dashboard and check if memory is freed
      await page.goto(`${BASE_URL}/dashboard`);
      await page.waitForTimeout(3000);

      // Force garbage collection (if available)
      await page.evaluate(() => {
        // @ts-ignore
        if (window.gc) {
          window.gc();
        }
      });

      const finalMemoryInfo = await page.evaluate(() => {
        // @ts-ignore
        return (performance as any).memory ? {
          usedJSHeapSize: (performance as any).memory.usedJSHeapSize,
          totalJSHeapSize: (performance as any).memory.totalJSHeapSize
        } : { usedJSHeapSize: 0, totalJSHeapSize: 0 };
      });

      console.log(`üßπ Final memory usage: ${(finalMemoryInfo.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`);

      // Check for significant memory increase
      if (resourceMetrics.length > 0) {
        const initialMemory = resourceMetrics[0].memoryUsage;
        const memoryIncrease = finalMemoryInfo.usedJSHeapSize - initialMemory;
        const memoryIncreasePercent = (memoryIncrease / initialMemory) * 100;

        if (memoryIncreasePercent > 50) {
          console.warn(`‚ö†Ô∏è Significant memory increase detected: ${memoryIncreasePercent.toFixed(2)}%`);
        }
      }
    });

    // Report resource metrics
    console.log('\n=== Resource Usage Summary ===');
    resourceMetrics.forEach(metrics => {
      console.log(`${metrics.phase}: ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB, ${metrics.networkRequests} requests`);
    });

    // Basic assertions - don't fail for performance issues, just warn
    const highMemoryPhases = resourceMetrics.filter(m => m.memoryUsage > 50 * 1024 * 1024); // 50MB
    if (highMemoryPhases.length > 0) {
      console.warn(`‚ö†Ô∏è High memory usage detected in ${highMemoryPhases.length} phases`);
    }

    const highNetworkPhases = resourceMetrics.filter(m => m.networkRequests > 20);
    if (highNetworkPhases.length > 0) {
      console.warn(`‚ö†Ô∏è High network activity detected in ${highNetworkPhases.length} phases`);
    }
  });
});