import { test, expect, Page, APIResponse } from '@playwright/test';
import path from 'path';

/**
 * Flow Integrity Validation Test Suite
 * 
 * Tests the data integrity issues that were identified and fixed:
 * 1. Flow ID generation and validation (no undefined flow IDs)
 * 2. Flow state persistence and consistency
 * 3. Data integrity across flow transitions
 * 4. Proper flow initialization and cleanup
 * 
 * Generated by CC (Claude Code)
 */

const BASE_URL = 'http://localhost:8081';
const API_URL = 'http://localhost:8000';

const TEST_USER = {
  email: 'chocka@gmail.com',
  password: 'Password123!'
};

interface FlowValidationResults {
  flowId: string;
  isValid: boolean;
  hasCorrectFormat: boolean;
  persistsAcrossTransitions: boolean;
  errors: string[];
}

interface ApiResponse {
  flow_id?: string;
  id?: string;
  status?: string;
  state?: any;
  error?: string;
}

// Helper function to validate flow ID format
function validateFlowIdFormat(flowId: string | null | undefined): boolean {
  if (!flowId) return false;
  
  // Expected format: flow-YYYYMMDD-HHMMSS or similar timestamp-based format
  const flowIdPattern = /^flow-\d{8}-\d{6}$/;
  const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  
  return flowIdPattern.test(flowId) || uuidPattern.test(flowId);
}

// Helper function to perform login
async function loginUser(page: Page): Promise<void> {
  await page.goto(`${BASE_URL}/login`);
  await page.fill('input[type="email"]', TEST_USER.email);
  await page.fill('input[type="password"]', TEST_USER.password);
  await page.click('button[type="submit"]');
  await page.waitForURL('**/dashboard', { timeout: 10000 });
}

// Helper function to extract flow ID from various sources
async function extractFlowIdFromPage(page: Page): Promise<string | null> {
  // Try multiple strategies to find flow ID
  const strategies = [
    async () => {
      const flowIdElement = page.locator('text=/flow-\\d{8}-\\d{6}/');
      return await flowIdElement.textContent();
    },
    async () => {
      const flowIdElement = page.locator('[data-testid="flow-id"]');
      return await flowIdElement.textContent();
    },
    async () => {
      const flowIdElement = page.locator('.flow-id');
      return await flowIdElement.textContent();
    },
    async () => {
      // Check URL for flow ID
      const url = page.url();
      const match = url.match(/flow[_-]([a-f0-9-]+)/i);
      return match ? match[1] : null;
    },
    async () => {
      // Check local storage
      return await page.evaluate(() => {
        const keys = Object.keys(localStorage);
        for (const key of keys) {
          if (key.includes('flow')) {
            const value = localStorage.getItem(key);
            try {
              const parsed = JSON.parse(value || '{}');
              if (parsed.flow_id || parsed.id) {
                return parsed.flow_id || parsed.id;
              }
            } catch {
              if (value && value.includes('flow-')) {
                return value;
              }
            }
          }
        }
        return null;
      });
    }
  ];

  for (const strategy of strategies) {
    try {
      const result = await strategy();
      if (result && result.trim()) {
        return result.trim();
      }
    } catch (error) {
      console.log('Strategy failed:', error);
    }
  }

  return null;
}

test.describe('Flow Integrity Validation', () => {
  test.beforeEach(async ({ page }) => {
    await loginUser(page);
  });

  test('Flow ID generation and validation during discovery flow', async ({ page }) => {
    const validationResults: FlowValidationResults = {
      flowId: '',
      isValid: false,
      hasCorrectFormat: false,
      persistsAcrossTransitions: false,
      errors: []
    };

    await test.step('Initialize new discovery flow', async () => {
      await page.goto(`${BASE_URL}/discovery`);
      await page.waitForTimeout(2000);

      // Check if we need to start a new flow
      const startNewFlowBtn = page.locator('button').filter({ hasText: /Start New Discovery|New Flow|Initialize/i });
      if (await startNewFlowBtn.isVisible()) {
        
        // Monitor the API call for flow initialization
        const [response] = await Promise.all([
          page.waitForResponse(response => 
            response.url().includes('/flow/initialize') || 
            response.url().includes('/discovery/start') ||
            response.url().includes('/unified-discovery')
          ),
          startNewFlowBtn.click()
        ]);

        // Validate API response
        if (response.status() !== 200) {
          validationResults.errors.push(`Flow initialization API returned status: ${response.status()}`);
        }

        try {
          const responseData: ApiResponse = await response.json();
          
          // Check for flow ID in response
          const apiFlowId = responseData.flow_id || responseData.id;
          if (!apiFlowId) {
            validationResults.errors.push('API response missing flow_id field');
          } else if (apiFlowId === 'undefined' || apiFlowId === null) {
            validationResults.errors.push(`API returned invalid flow_id: ${apiFlowId}`);
          } else {
            validationResults.flowId = apiFlowId;
            validationResults.hasCorrectFormat = validateFlowIdFormat(apiFlowId);
            if (!validationResults.hasCorrectFormat) {
              validationResults.errors.push(`Invalid flow ID format: ${apiFlowId}`);
            }
          }
        } catch (error) {
          validationResults.errors.push(`Failed to parse API response: ${error}`);
        }
      }

      await page.waitForTimeout(2000);
    });

    await test.step('Validate flow ID persistence across navigation', async () => {
      // Extract flow ID from the page after initialization
      if (!validationResults.flowId) {
        const pageFlowId = await extractFlowIdFromPage(page);
        if (pageFlowId) {
          validationResults.flowId = pageFlowId;
          validationResults.hasCorrectFormat = validateFlowIdFormat(pageFlowId);
        }
      }

      if (!validationResults.flowId) {
        validationResults.errors.push('No flow ID found on page after initialization');
        return;
      }

      // Navigate through different phases and verify flow ID persistence
      const phases = [
        { name: 'CMDB Import', url: '/discovery/cmdb-import' },
        { name: 'Attribute Mapping', url: '/discovery/attribute-mapping' },
        { name: 'Asset Inventory', url: '/discovery/asset-inventory' }
      ];

      let flowIdConsistent = true;

      for (const phase of phases) {
        await page.goto(`${BASE_URL}${phase.url}`);
        await page.waitForTimeout(2000);

        const currentFlowId = await extractFlowIdFromPage(page);
        
        if (!currentFlowId) {
          validationResults.errors.push(`Flow ID not found on ${phase.name} page`);
          flowIdConsistent = false;
        } else if (currentFlowId !== validationResults.flowId) {
          validationResults.errors.push(
            `Flow ID changed from ${validationResults.flowId} to ${currentFlowId} on ${phase.name} page`
          );
          flowIdConsistent = false;
        }
      }

      validationResults.persistsAcrossTransitions = flowIdConsistent;
    });

    await test.step('Validate flow state API endpoints', async () => {
      if (!validationResults.flowId) {
        validationResults.errors.push('Cannot validate API endpoints without flow ID');
        return;
      }

      // Test flow status endpoint
      try {
        const statusResponse = await page.request.get(`${API_URL}/api/v1/unified-discovery/flow/${validationResults.flowId}/status`);
        
        if (statusResponse.status() === 404) {
          validationResults.errors.push(`Flow status API returned 404 for flow ID: ${validationResults.flowId}`);
        } else if (statusResponse.status() !== 200) {
          validationResults.errors.push(`Flow status API returned unexpected status: ${statusResponse.status()}`);
        } else {
          const statusData = await statusResponse.json();
          if (!statusData.id && !statusData.flow_id) {
            validationResults.errors.push('Flow status response missing ID fields');
          }
        }
      } catch (error) {
        validationResults.errors.push(`Flow status API error: ${error}`);
      }

      // Test flow details endpoint
      try {
        const detailsResponse = await page.request.get(`${API_URL}/api/v1/flows/${validationResults.flowId}`);
        
        if (detailsResponse.status() === 404) {
          validationResults.errors.push(`Flow details API returned 404 for flow ID: ${validationResults.flowId}`);
        } else if (detailsResponse.status() !== 200) {
          validationResults.errors.push(`Flow details API returned unexpected status: ${detailsResponse.status()}`);
        }
      } catch (error) {
        // This might be expected if endpoint doesn't exist
        console.log(`Flow details endpoint not available: ${error}`);
      }
    });

    // Set validation status based on results
    validationResults.isValid = validationResults.errors.length === 0 && 
                                validationResults.hasCorrectFormat && 
                                validationResults.persistsAcrossTransitions &&
                                validationResults.flowId !== '';

    // Assertions
    expect(validationResults.flowId, 'Flow ID should be generated').not.toBe('');
    expect(validationResults.flowId, 'Flow ID should not be undefined').not.toBe('undefined');
    expect(validationResults.flowId, 'Flow ID should not be null').not.toBeNull();
    expect(validationResults.hasCorrectFormat, 'Flow ID should have correct format').toBe(true);
    expect(validationResults.persistsAcrossTransitions, 'Flow ID should persist across navigation').toBe(true);
    expect(validationResults.errors, 'Should have no validation errors').toHaveLength(0);

    console.log('Flow Validation Results:', validationResults);
  });

  test('Flow data integrity during file upload and processing', async ({ page }) => {
    let flowId = '';
    const dataIntegrityIssues: string[] = [];

    await test.step('Upload test file and validate flow creation', async () => {
      await page.goto(`${BASE_URL}/discovery/cmdb-import`);
      await page.waitForTimeout(2000);

      const testFilePath = path.join(__dirname, '../fixtures/test-cmdb-data.csv');
      
      // Upload file and monitor API responses
      const uploadArea = page.locator('.border-dashed').filter({ hasText: 'Application Discovery' }).first();
      await uploadArea.click();

      const [uploadResponse] = await Promise.all([
        page.waitForResponse(response => 
          response.url().includes('/upload') || 
          response.url().includes('/import') ||
          response.url().includes('/process')
        ),
        page.locator('input[type="file"]').setInputFiles(testFilePath)
      ]);

      // Validate upload response
      if (uploadResponse.status() !== 200) {
        dataIntegrityIssues.push(`File upload returned status: ${uploadResponse.status()}`);
      }

      try {
        const uploadData = await uploadResponse.json();
        const responseFlowId = uploadData.flow_id || uploadData.id;
        
        if (!responseFlowId) {
          dataIntegrityIssues.push('Upload response missing flow_id');
        } else if (responseFlowId === 'undefined' || !validateFlowIdFormat(responseFlowId)) {
          dataIntegrityIssues.push(`Invalid flow ID in upload response: ${responseFlowId}`);
        } else {
          flowId = responseFlowId;
        }
      } catch (error) {
        dataIntegrityIssues.push(`Failed to parse upload response: ${error}`);
      }

      await page.waitForTimeout(3000);
    });

    await test.step('Validate flow state consistency during processing', async () => {
      if (!flowId) {
        flowId = await extractFlowIdFromPage(page) || '';
      }

      if (!flowId) {
        dataIntegrityIssues.push('No flow ID available for state validation');
        return;
      }

      // Check flow state multiple times during processing
      const stateChecks = 3;
      const stateResults: any[] = [];

      for (let i = 0; i < stateChecks; i++) {
        try {
          const stateResponse = await page.request.get(`${API_URL}/api/v1/unified-discovery/flow/${flowId}/state`);
          
          if (stateResponse.status() === 200) {
            const stateData = await stateResponse.json();
            stateResults.push(stateData);
            
            // Check for undefined values in state
            const stateString = JSON.stringify(stateData);
            if (stateString.includes('"undefined"') || stateString.includes(':undefined')) {
              dataIntegrityIssues.push(`State contains undefined values at check ${i + 1}`);
            }
          } else if (stateResponse.status() === 404) {
            dataIntegrityIssues.push(`Flow state not found (404) at check ${i + 1}`);
          }
        } catch (error) {
          dataIntegrityIssues.push(`State validation error at check ${i + 1}: ${error}`);
        }

        if (i < stateChecks - 1) {
          await page.waitForTimeout(2000);
        }
      }

      // Validate state consistency
      if (stateResults.length > 1) {
        const firstState = stateResults[0];
        const lastState = stateResults[stateResults.length - 1];

        if (firstState.id !== lastState.id) {
          dataIntegrityIssues.push('Flow ID changed during processing');
        }
      }
    });

    // Assertions
    expect(flowId, 'Flow should have valid ID').toBeTruthy();
    expect(validateFlowIdFormat(flowId), 'Flow ID should have correct format').toBe(true);
    expect(dataIntegrityIssues, 'Should have no data integrity issues').toHaveLength(0);

    if (dataIntegrityIssues.length > 0) {
      console.log('Data Integrity Issues Found:', dataIntegrityIssues);
    }
  });

  test('Flow cleanup and state management', async ({ page }) => {
    const cleanupIssues: string[] = [];
    let testFlowId = '';

    await test.step('Create and validate flow for cleanup testing', async () => {
      await page.goto(`${BASE_URL}/discovery`);
      await page.waitForTimeout(2000);

      // Start new flow
      const startBtn = page.locator('button').filter({ hasText: /Start New Discovery|New Flow/i });
      if (await startBtn.isVisible()) {
        await startBtn.click();
        await page.waitForTimeout(3000);

        testFlowId = await extractFlowIdFromPage(page) || '';
        
        if (!testFlowId) {
          cleanupIssues.push('Failed to create flow for cleanup testing');
          return;
        }
      }
    });

    await test.step('Validate flow state persistence', async () => {
      if (!testFlowId) return;

      // Navigate away and back
      await page.goto(`${BASE_URL}/dashboard`);
      await page.waitForTimeout(1000);
      await page.goto(`${BASE_URL}/discovery`);
      await page.waitForTimeout(2000);

      // Check if flow is still accessible
      const currentFlowId = await extractFlowIdFromPage(page);
      
      if (!currentFlowId) {
        cleanupIssues.push('Flow ID lost after navigation');
      } else if (currentFlowId !== testFlowId) {
        cleanupIssues.push(`Flow ID changed after navigation: ${testFlowId} -> ${currentFlowId}`);
      }
    });

    await test.step('Validate flow state API after navigation', async () => {
      if (!testFlowId) return;

      try {
        const stateResponse = await page.request.get(`${API_URL}/api/v1/unified-discovery/flow/${testFlowId}/state`);
        
        if (stateResponse.status() === 404) {
          cleanupIssues.push('Flow state lost - API returns 404 after navigation');
        } else if (stateResponse.status() !== 200) {
          cleanupIssues.push(`Unexpected flow state API status: ${stateResponse.status()}`);
        } else {
          const stateData = await stateResponse.json();
          if (!stateData || !stateData.id) {
            cleanupIssues.push('Flow state data is empty or missing ID');
          }
        }
      } catch (error) {
        cleanupIssues.push(`Flow state API error: ${error}`);
      }
    });

    // Assertions
    expect(testFlowId, 'Test flow should be created').toBeTruthy();
    expect(cleanupIssues, 'Should have no cleanup issues').toHaveLength(0);

    if (cleanupIssues.length > 0) {
      console.log('Flow Cleanup Issues:', cleanupIssues);
    }
  });

  test('Multiple concurrent flows handling', async ({ page, context }) => {
    const concurrencyIssues: string[] = [];
    const flowIds: string[] = [];

    await test.step('Create multiple flows in different tabs', async () => {
      // Create additional pages for concurrent testing
      const page2 = await context.newPage();
      await loginUser(page2);

      // Start flow in first tab
      await page.goto(`${BASE_URL}/discovery`);
      const startBtn1 = page.locator('button').filter({ hasText: /Start New Discovery|New Flow/i });
      if (await startBtn1.isVisible()) {
        await startBtn1.click();
        await page.waitForTimeout(2000);
        const flowId1 = await extractFlowIdFromPage(page);
        if (flowId1) flowIds.push(flowId1);
      }

      // Start flow in second tab
      await page2.goto(`${BASE_URL}/discovery`);
      const startBtn2 = page2.locator('button').filter({ hasText: /Start New Discovery|New Flow/i });
      if (await startBtn2.isVisible()) {
        await startBtn2.click();
        await page2.waitForTimeout(2000);
        const flowId2 = await extractFlowIdFromPage(page2);
        if (flowId2) flowIds.push(flowId2);
      }

      // Validate flows are different
      if (flowIds.length === 2 && flowIds[0] === flowIds[1]) {
        concurrencyIssues.push('Concurrent flows have same ID - potential collision');
      }

      await page2.close();
    });

    await test.step('Validate flow isolation', async () => {
      if (flowIds.length < 2) {
        concurrencyIssues.push('Could not create multiple flows for isolation testing');
        return;
      }

      // Check that each flow maintains its own state
      for (const flowId of flowIds) {
        try {
          const stateResponse = await page.request.get(`${API_URL}/api/v1/unified-discovery/flow/${flowId}/state`);
          
          if (stateResponse.status() !== 200) {
            concurrencyIssues.push(`Flow ${flowId} state not accessible: ${stateResponse.status()}`);
          } else {
            const stateData = await stateResponse.json();
            if (stateData.id !== flowId) {
              concurrencyIssues.push(`Flow state mismatch: expected ${flowId}, got ${stateData.id}`);
            }
          }
        } catch (error) {
          concurrencyIssues.push(`Flow ${flowId} validation error: ${error}`);
        }
      }
    });

    // Assertions
    expect(flowIds.length, 'Should create multiple flows').toBeGreaterThan(1);
    expect(concurrencyIssues, 'Should have no concurrency issues').toHaveLength(0);

    if (concurrencyIssues.length > 0) {
      console.log('Concurrency Issues:', concurrencyIssues);
    }
  });
});