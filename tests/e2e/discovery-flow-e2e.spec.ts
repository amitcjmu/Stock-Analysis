/**
 * Comprehensive Discovery Flow E2E Tests
 * Tests the complete discovery workflow from login to asset inventory creation
 * Covers happy path, error scenarios, and persistent agent verification
 *
 * Generated by CC
 */

import { test, expect, Page, BrowserContext } from '@playwright/test';
import {
  TEST_CONFIG,
  TEST_USERS,
  TEST_DATA,
  login,
  navigateToDiscovery,
  uploadFile,
  waitForAPIResponse,
  checkForConsoleErrors,
  takeScreenshot,
  waitForElement,
  clickWithRetry,
  fillForm,
  expectElementText,
  checkFlowStatus,
  waitForAgents,
  cleanup,
  generateTestCSV
} from './helpers/test-helpers';
import path from 'path';
import fs from 'fs';

test.describe('Discovery Flow E2E Tests', () => {
  let flowId: string | null = null;
  let consoleErrors: string[] = [];
  let networkErrors: Array<{ url: string; status: number; statusText?: string }> = [];
  let testDataFile: string;

  test.beforeAll(async () => {
    // Create test data file
    const testDir = path.join(process.cwd(), 'tests', 'e2e', 'test-data');
    if (!fs.existsSync(testDir)) {
      fs.mkdirSync(testDir, { recursive: true });
    }

    testDataFile = path.join(testDir, `test-discovery-${Date.now()}.csv`);
    const csvData = generateTestCSV(15);
    fs.writeFileSync(testDataFile, csvData);
    console.log(`Created test data file: ${testDataFile}`);
  });

  test.afterAll(async () => {
    // Cleanup test data file
    if (fs.existsSync(testDataFile)) {
      fs.unlinkSync(testDataFile);
      console.log(`Cleaned up test data file: ${testDataFile}`);
    }
  });

  test.beforeEach(async ({ page, context }) => {
    // Reset error arrays
    consoleErrors = [];
    networkErrors = [];

    // Setup console error monitoring
    page.on('console', (msg) => {
      if (msg.type() === 'error') {
        consoleErrors.push(msg.text());
        console.log(`Console Error: ${msg.text()}`);
      }
    });

    // Setup network error monitoring
    page.on('response', async (response) => {
      if (response.status() >= 400) {
        networkErrors.push({
          url: response.url(),
          status: response.status(),
          statusText: response.statusText()
        });
        console.log(`Network Error: ${response.status()} ${response.url()}`);
      }
    });

    // Login before each test
    await login(page, TEST_USERS.demo);
    await takeScreenshot(page, 'discovery-logged-in');
  });

  test.afterEach(async ({ page, context }, testInfo) => {
    // Take screenshot on failure
    if (testInfo.status === 'failed') {
      await takeScreenshot(page, `discovery-failure-${testInfo.title.replace(/\s+/g, '-')}`);
    }

    // Log test summary
    console.log(`\n=== ${testInfo.title} SUMMARY ===`);
    console.log(`Status: ${testInfo.status}`);
    console.log(`Duration: ${testInfo.duration}ms`);
    console.log(`Console Errors: ${consoleErrors.length}`);
    console.log(`Network Errors: ${networkErrors.length}`);

    if (consoleErrors.length > 0) {
      console.log('Console Errors:');
      consoleErrors.forEach((error, index) => console.log(`  ${index + 1}. ${error}`));
    }

    if (networkErrors.length > 0) {
      console.log('Network Errors:');
      networkErrors.forEach((error, index) =>
        console.log(`  ${index + 1}. ${error.status} - ${error.url}`)
      );
    }

    // Cleanup browser context
    await cleanup(context);
  });

  test('Complete Discovery Flow - Happy Path', async ({ page }) => {
    console.log('\n=== STARTING COMPLETE DISCOVERY FLOW - HAPPY PATH ===');

    // Step 1: Navigate to Discovery
    console.log('\nStep 1: Navigate to Discovery Overview');
    await navigateToDiscovery(page);
    await takeScreenshot(page, 'discovery-overview');

    // Verify we're on the discovery page
    await expect(page).toHaveURL(/.*discovery\/overview/);

    // Step 2: Check for persistent agents initialization
    console.log('\nStep 2: Verify persistent agents initialization');
    try {
      await waitForAgents(page);
      console.log('✓ Persistent agents initialized successfully');
    } catch (error) {
      console.log('⚠ Persistent agents initialization not detected');
    }

    // Step 3: Navigate to Data Import
    console.log('\nStep 3: Navigate to Data Import');
    await clickWithRetry(page, 'text=Data Import');
    await page.waitForURL('**/discovery/cmdb-import', { timeout: 15000 });
    await takeScreenshot(page, 'discovery-data-import');

    // Step 4: Upload CSV file
    console.log('\nStep 4: Upload CSV test data');
    await waitForElement(page, 'input[type="file"], .upload-area');

    const fileInput = page.locator('input[type="file"]');
    if (await fileInput.isVisible()) {
      await uploadFile(page, testDataFile);
    } else {
      // Click upload area first
      await page.click('.upload-area, .border-dashed');
      await page.waitForTimeout(1000);
      await uploadFile(page, testDataFile);
    }

    console.log('✓ File uploaded successfully');
    await takeScreenshot(page, 'discovery-file-uploaded');

    // Step 5: Wait for upload processing and capture flow ID
    console.log('\nStep 5: Wait for upload processing');
    await page.waitForTimeout(3000);

    // Look for success indicators
    const successSelectors = [
      'text="Upload completed"',
      'text="Upload successful"',
      'text="Processing complete"',
      'text="Data imported successfully"',
      '[data-testid="upload-success"]'
    ];

    let uploadSuccess = false;
    for (const selector of successSelectors) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        uploadSuccess = true;
        console.log('✓ Upload success indicator found');
        break;
      }
    }

    // Capture flow ID
    const flowIdRegex = /flow-\d{8}-\d{6}/;
    const flowIdElement = page.locator(`text=${flowIdRegex}`);

    if (await flowIdElement.isVisible({ timeout: 10000 })) {
      flowId = await flowIdElement.textContent();
      console.log(`✓ Flow ID created: ${flowId}`);
    }

    expect(uploadSuccess || flowId).toBeTruthy();
    await takeScreenshot(page, 'discovery-upload-processed');

    // Step 6: Navigate to Field Mapping
    console.log('\nStep 6: Navigate to Field Mapping');
    await clickWithRetry(page, 'text=Attribute Mapping');
    await page.waitForURL('**/discovery/attribute-mapping', { timeout: 15000 });
    await page.waitForTimeout(2000);
    await takeScreenshot(page, 'discovery-field-mapping');

    // Check if data is available
    const noDataMessage = await page.locator('text="No Field Mapping Available"').isVisible();
    if (noDataMessage) {
      console.log('⚠ No field mapping data initially visible');

      // Try selecting a flow if dropdown exists
      const flowSelector = page.locator('select[data-testid="flow-selector"], .flow-selector select').first();
      if (await flowSelector.isVisible()) {
        console.log('  - Flow selector found, selecting flow...');
        const options = await flowSelector.locator('option').count();
        if (options > 1) {
          await flowSelector.selectOption({ index: 1 });
          await page.waitForTimeout(2000);
        }
      }
    }

    // Verify field mapping UI
    const fieldMappingCount = await page.locator('.field-mapping-item, [data-testid="field-mapping"]').count();
    console.log(`✓ Found ${fieldMappingCount} field mapping elements`);

    // Complete field mapping
    const approveButton = page.locator('button:has-text("Approve"), button:has-text("Confirm"), button:has-text("Next")').first();
    if (await approveButton.isVisible()) {
      await approveButton.click();
      console.log('✓ Field mapping approved');
      await page.waitForTimeout(2000);
    }
    await takeScreenshot(page, 'discovery-field-mapping-complete');

    // Step 7: Navigate to Data Cleansing
    console.log('\nStep 7: Navigate to Data Cleansing');
    await clickWithRetry(page, 'text=Data Cleansing');
    await page.waitForTimeout(3000);
    await takeScreenshot(page, 'discovery-data-cleansing');

    // Verify cleansing phase
    const cleansingIndicators = [
      'text="Quality"',
      'text="Accuracy"',
      'text="Completeness"',
      '[data-testid="data-quality"]'
    ];

    let cleansingVisible = false;
    for (const selector of cleansingIndicators) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        cleansingVisible = true;
        console.log('✓ Data quality metrics visible');
        break;
      }
    }

    // Complete cleansing phase
    const cleansingCompleteButton = page.locator('button:has-text("Complete"), button:has-text("Continue"), button:has-text("Next")').first();
    if (await cleansingCompleteButton.isVisible()) {
      await cleansingCompleteButton.click();
      console.log('✓ Data cleansing completed');
      await page.waitForTimeout(2000);
    }

    // Step 8: Navigate to Asset Inventory
    console.log('\nStep 8: Navigate to Asset Inventory');
    await clickWithRetry(page, 'text=Inventory');
    await page.waitForURL('**/discovery/inventory', { timeout: 15000 });
    await page.waitForTimeout(3000);
    await takeScreenshot(page, 'discovery-inventory');

    // Verify asset inventory
    const assetTable = page.locator('table, .asset-list, [data-testid="asset-table"]');
    await expect(assetTable).toBeVisible({ timeout: 10000 });

    const assetCount = await page.locator('tbody tr, .asset-item').count();
    console.log(`✓ Asset inventory contains ${assetCount} assets`);
    expect(assetCount).toBeGreaterThan(0);

    // Step 9: Verify flow completion status
    console.log('\nStep 9: Verify flow completion status');
    const flowStatus = page.locator('[data-testid="flow-status"], .flow-status');
    if (await flowStatus.isVisible()) {
      const statusText = await flowStatus.textContent();
      console.log(`Flow status: ${statusText}`);
    }

    // Check for completion indicators
    const completionIndicators = [
      'text="Flow Completed"',
      'text="Discovery Complete"',
      '[data-testid="flow-complete"]',
      '.status-complete'
    ];

    let flowCompleted = false;
    for (const selector of completionIndicators) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        flowCompleted = true;
        console.log('✓ Flow marked as completed');
        break;
      }
    }

    // Step 10: Test starting a new flow after completion
    console.log('\nStep 10: Test starting new flow capability');
    await navigateToDiscovery(page);
    await page.waitForTimeout(2000);

    // Look for "Start New Flow" or similar button
    const newFlowButton = page.locator('button:has-text("Start New"), button:has-text("New Flow"), [data-testid="new-flow-button"]');
    if (await newFlowButton.isVisible({ timeout: 5000 })) {
      console.log('✓ New flow capability available after completion');
    } else {
      console.log('⚠ New flow button not visible');
    }

    // Final verification
    console.log('\n=== DISCOVERY FLOW COMPLETED SUCCESSFULLY ===');
    expect(consoleErrors.filter(error => !error.includes('Warning')).length).toBeLessThan(5);
    expect(networkErrors.filter(error => error.status >= 500).length).toBe(0);
  });

  test('Discovery Flow - Field Mapping Error Handling', async ({ page }) => {
    console.log('\n=== TESTING FIELD MAPPING ERROR HANDLING ===');

    // Navigate to discovery and upload data
    await navigateToDiscovery(page);
    await clickWithRetry(page, 'text=Data Import');
    await page.waitForURL('**/discovery/cmdb-import');

    // Upload test data
    await uploadFile(page, testDataFile);
    await page.waitForTimeout(3000);

    // Navigate to field mapping
    await clickWithRetry(page, 'text=Attribute Mapping');
    await page.waitForURL('**/discovery/attribute-mapping');
    await page.waitForTimeout(2000);

    // Test field mapping with no flow selected
    const noDataVisible = await page.locator('text="No Field Mapping Available"').isVisible();
    if (noDataVisible) {
      console.log('✓ Appropriate message shown when no data available');
    }

    // Test field mapping dropdown behavior
    const flowSelector = page.locator('select[data-testid="flow-selector"], .flow-selector select').first();
    if (await flowSelector.isVisible()) {
      console.log('✓ Flow selector is available');

      // Test selecting different flows
      const optionCount = await flowSelector.locator('option').count();
      console.log(`Found ${optionCount} flow options`);

      if (optionCount > 1) {
        for (let i = 1; i < Math.min(optionCount, 3); i++) {
          await flowSelector.selectOption({ index: i });
          await page.waitForTimeout(1000);

          const mappingVisible = await page.locator('.field-mapping-item').count();
          console.log(`Flow ${i}: ${mappingVisible} mapping items visible`);
        }
      }
    }

    // Test field mapping validation
    const mappingItems = page.locator('.field-mapping-item, [data-testid="field-mapping"]');
    const itemCount = await mappingItems.count();

    if (itemCount > 0) {
      console.log(`✓ ${itemCount} field mapping items available for testing`);

      // Test invalid mapping selections
      const firstMapping = mappingItems.first();
      const dropdown = firstMapping.locator('select').first();

      if (await dropdown.isVisible()) {
        // Try selecting an invalid option or empty option
        await dropdown.selectOption('');

        // Try to approve with invalid mapping
        const approveButton = page.locator('button:has-text("Approve")');
        if (await approveButton.isVisible()) {
          await approveButton.click();

          // Check for validation error
          const errorMessage = page.locator('text="Please select", text="Required", .error-message');
          if (await errorMessage.isVisible({ timeout: 3000 })) {
            console.log('✓ Validation error shown for incomplete mapping');
          }
        }
      }
    }

    await takeScreenshot(page, 'discovery-field-mapping-error-handling');
  });

  test('Discovery Flow - Network Error Recovery', async ({ page }) => {
    console.log('\n=== TESTING NETWORK ERROR RECOVERY ===');

    // Navigate to discovery
    await navigateToDiscovery(page);
    await clickWithRetry(page, 'text=Data Import');
    await page.waitForURL('**/discovery/cmdb-import');

    // Intercept network requests to simulate failures
    await page.route('**/api/v1/unified-discovery/**', async route => {
      const url = route.request().url();
      if (url.includes('upload')) {
        // Simulate upload failure first time, success second time
        const attempt = await page.evaluate(() => {
          window.__uploadAttempts = (window.__uploadAttempts || 0) + 1;
          return window.__uploadAttempts;
        });

        if (attempt === 1) {
          console.log('Simulating upload failure...');
          await route.fulfill({
            status: 500,
            body: JSON.stringify({ error: 'Server error' })
          });
        } else {
          console.log('Allowing upload success...');
          await route.continue();
        }
      } else {
        await route.continue();
      }
    });

    // Attempt file upload (should fail first time)
    await uploadFile(page, testDataFile);
    await page.waitForTimeout(2000);

    // Check for error message
    const errorMessage = page.locator('text="error", text="failed", .error-message');
    if (await errorMessage.isVisible({ timeout: 5000 })) {
      console.log('✓ Error message displayed for failed upload');
    }

    // Try upload again (should succeed)
    await uploadFile(page, testDataFile);
    await page.waitForTimeout(3000);

    // Check for success
    const successIndicator = page.locator('text="success", text="completed", .success-message');
    if (await successIndicator.isVisible({ timeout: 5000 })) {
      console.log('✓ Upload succeeded on retry');
    }

    await takeScreenshot(page, 'discovery-network-error-recovery');
  });

  test('Discovery Flow - Invalid File Upload Handling', async ({ page }) => {
    console.log('\n=== TESTING INVALID FILE UPLOAD HANDLING ===');

    await navigateToDiscovery(page);
    await clickWithRetry(page, 'text=Data Import');
    await page.waitForURL('**/discovery/cmdb-import');

    // Test 1: Upload non-CSV file
    const textFile = path.join(process.cwd(), 'tests', 'e2e', 'test-data', 'invalid.txt');
    if (!fs.existsSync(path.dirname(textFile))) {
      fs.mkdirSync(path.dirname(textFile), { recursive: true });
    }
    fs.writeFileSync(textFile, 'This is not a CSV file');

    try {
      await uploadFile(page, textFile);
      await page.waitForTimeout(2000);

      // Check for error message
      const errorSelectors = [
        'text="Invalid file format"',
        'text="Please upload a CSV file"',
        'text="File type not supported"',
        '.error-message',
        '[data-testid="upload-error"]'
      ];

      let errorFound = false;
      for (const selector of errorSelectors) {
        if (await page.locator(selector).isVisible({ timeout: 3000 })) {
          errorFound = true;
          const errorText = await page.locator(selector).textContent();
          console.log(`✓ Error message for invalid file: ${errorText}`);
          break;
        }
      }

      if (!errorFound) {
        console.log('⚠ No error message shown for invalid file type');
      }
    } finally {
      // Clean up test file
      if (fs.existsSync(textFile)) {
        fs.unlinkSync(textFile);
      }
    }

    // Test 2: Upload empty CSV
    const emptyCSV = path.join(process.cwd(), 'tests', 'e2e', 'test-data', 'empty.csv');
    fs.writeFileSync(emptyCSV, 'Name,Type,Status\n');

    try {
      await uploadFile(page, emptyCSV);
      await page.waitForTimeout(2000);

      // Check for appropriate handling
      const emptyDataMessage = page.locator('text="No data", text="Empty file", text="No records"');
      if (await emptyDataMessage.isVisible({ timeout: 3000 })) {
        console.log('✓ Empty file handled appropriately');
      }
    } finally {
      // Clean up test file
      if (fs.existsSync(emptyCSV)) {
        fs.unlinkSync(emptyCSV);
      }
    }

    await takeScreenshot(page, 'discovery-invalid-file-handling');
  });

  test('Discovery Flow - Data Persistence Across Sessions', async ({ page, context }) => {
    console.log('\n=== TESTING DATA PERSISTENCE ACROSS SESSIONS ===');

    // Complete initial upload
    await navigateToDiscovery(page);
    await clickWithRetry(page, 'text=Data Import');
    await page.waitForURL('**/discovery/cmdb-import');
    await uploadFile(page, testDataFile);
    await page.waitForTimeout(3000);

    // Capture flow ID
    const flowIdElement = page.locator('text=/flow-\\d{8}-\\d{6}/');
    if (await flowIdElement.isVisible({ timeout: 10000 })) {
      flowId = await flowIdElement.textContent();
      console.log(`✓ Flow ID captured: ${flowId}`);
    }

    // Navigate away and back
    await page.click('text=Dashboard');
    await page.waitForTimeout(1000);
    await navigateToDiscovery(page);
    await page.waitForTimeout(2000);

    // Check if flow is still accessible
    if (flowId) {
      const flowStillExists = await page.locator(`text=${flowId}`).isVisible({ timeout: 5000 });
      if (flowStillExists) {
        console.log('✓ Flow persisted across navigation');
      } else {
        console.log('⚠ Flow not immediately visible, checking flow selector...');

        // Check if flow is available in dropdown
        const flowSelector = page.locator('select[data-testid="flow-selector"], .flow-selector select');
        if (await flowSelector.isVisible()) {
          const optionWithFlow = await flowSelector.locator(`option:has-text("${flowId}")`).count();
          if (optionWithFlow > 0) {
            console.log('✓ Flow available in selector');
          }
        }
      }
    }

    // Test browser refresh persistence
    await page.reload();
    await page.waitForTimeout(2000);

    // Verify session persistence after refresh
    const dashboardVisible = await page.locator('text=Dashboard').isVisible({ timeout: 5000 });
    if (dashboardVisible) {
      console.log('✓ User session persisted after refresh');
    }

    await takeScreenshot(page, 'discovery-persistence-test');
  });

  test('Discovery Flow - Performance and Loading States', async ({ page }) => {
    console.log('\n=== TESTING PERFORMANCE AND LOADING STATES ===');

    const startTime = Date.now();

    // Monitor loading states
    await navigateToDiscovery(page);
    await clickWithRetry(page, 'text=Data Import');
    await page.waitForURL('**/discovery/cmdb-import');

    const navigationTime = Date.now() - startTime;
    console.log(`✓ Navigation completed in ${navigationTime}ms`);

    // Test loading states during upload
    const uploadStartTime = Date.now();
    await uploadFile(page, testDataFile);

    // Look for loading indicators
    const loadingIndicators = [
      '.loading',
      '.spinner',
      '[data-testid="loading"]',
      'text="Processing"',
      'text="Uploading"'
    ];

    let loadingFound = false;
    for (const selector of loadingIndicators) {
      if (await page.locator(selector).isVisible({ timeout: 1000 })) {
        loadingFound = true;
        console.log('✓ Loading indicator shown during upload');
        break;
      }
    }

    await page.waitForTimeout(3000);
    const uploadTime = Date.now() - uploadStartTime;
    console.log(`✓ Upload processing completed in ${uploadTime}ms`);

    // Test that loading indicators disappear
    if (loadingFound) {
      let loadingHidden = true;
      for (const selector of loadingIndicators) {
        if (await page.locator(selector).isVisible({ timeout: 1000 })) {
          loadingHidden = false;
          break;
        }
      }

      if (loadingHidden) {
        console.log('✓ Loading indicators properly hidden after completion');
      } else {
        console.log('⚠ Loading indicators still visible after completion');
      }
    }

    // Test performance benchmarks
    expect(navigationTime).toBeLessThan(10000); // Navigation should be under 10s
    expect(uploadTime).toBeLessThan(15000); // Upload should be under 15s

    await takeScreenshot(page, 'discovery-performance-test');
  });
});
