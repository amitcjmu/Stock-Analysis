/**
 * Comprehensive Collection Flow E2E Tests
 * Tests the complete collection workflow including adaptive forms and automated collection
 * Covers happy path, error scenarios, and fixes validation for HTTP 500 multiple rows issue
 *
 * Generated by CC
 */

import { test, expect, Page, BrowserContext } from '@playwright/test';
import {
  TEST_CONFIG,
  TEST_USERS,
  TEST_DATA,
  login,
  navigateToCollection,
  waitForAPIResponse,
  checkForConsoleErrors,
  takeScreenshot,
  waitForElement,
  clickWithRetry,
  fillForm,
  expectElementText,
  checkFlowStatus,
  waitForAgents,
  cleanup
} from './helpers/test-helpers';
import path from 'path';
import fs from 'fs';

test.describe('Collection Flow E2E Tests', () => {
  const collectionId: string | null = null;
  let consoleErrors: string[] = [];
  let networkErrors: Array<{ url: string; status: number; statusText?: string; responseBody?: any }> = [];
  let apiResponses: Array<{ url: string; status: number; data?: any }> = [];

  test.beforeEach(async ({ page, context }) => {
    // Reset tracking arrays
    consoleErrors = [];
    networkErrors = [];
    apiResponses = [];

    // Enhanced console error monitoring
    page.on('console', (msg) => {
      if (msg.type() === 'error') {
        consoleErrors.push(msg.text());
        console.log(`Console Error: ${msg.text()}`);
      }
    });

    // Enhanced network monitoring for Collection API issues
    page.on('response', async (response) => {
      const url = response.url();

      if (response.status() >= 400) {
        let responseBody;
        try {
          responseBody = await response.json();
        } catch (e) {
          responseBody = await response.text();
        }

        networkErrors.push({
          url,
          status: response.status(),
          statusText: response.statusText(),
          responseBody
        });

        console.log(`Network Error: ${response.status()} ${url}`);
        if (responseBody) console.log(`Response: ${JSON.stringify(responseBody, null, 2)}`);
      }

      // Track Collection API responses
      if (url.includes('/api/v1/collection') || url.includes('/collection-flow')) {
        let responseData;
        try {
          responseData = await response.json();
        } catch (e) {
          responseData = await response.text();
        }

        apiResponses.push({
          url,
          status: response.status(),
          data: responseData
        });
      }
    });

    // Login before each test
    await login(page, TEST_USERS.demo);
    await takeScreenshot(page, 'collection-logged-in');
  });

  test.afterEach(async ({ page, context }, testInfo) => {
    // Take screenshot on failure
    if (testInfo.status === 'failed') {
      await takeScreenshot(page, `collection-failure-${testInfo.title.replace(/\s+/g, '-')}`);
    }

    // Enhanced test summary
    console.log(`\n=== ${testInfo.title} SUMMARY ===`);
    console.log(`Status: ${testInfo.status}`);
    console.log(`Duration: ${testInfo.duration}ms`);
    console.log(`Console Errors: ${consoleErrors.length}`);
    console.log(`Network Errors: ${networkErrors.length}`);
    console.log(`API Responses: ${apiResponses.length}`);

    // Log Collection API responses for debugging
    if (apiResponses.length > 0) {
      console.log('\nCollection API Responses:');
      apiResponses.forEach((resp, index) => {
        console.log(`  ${index + 1}. ${resp.status} - ${resp.url}`);
      });
    }

    if (consoleErrors.length > 0) {
      console.log('Console Errors:');
      consoleErrors.forEach((error, index) => console.log(`  ${index + 1}. ${error}`));
    }

    if (networkErrors.length > 0) {
      console.log('Network Errors:');
      networkErrors.forEach((error, index) => {
        console.log(`  ${index + 1}. ${error.status} - ${error.url}`);
        if (error.responseBody) {
          console.log(`    Body: ${JSON.stringify(error.responseBody, null, 2)}`);
        }
      });
    }

    // Cleanup browser context
    await cleanup(context);
  });

  test('Complete Collection Flow - Happy Path', async ({ page }) => {
    console.log('\n=== STARTING COMPLETE COLLECTION FLOW - HAPPY PATH ===');

    // Step 1: Navigate to Collection Overview
    console.log('\nStep 1: Navigate to Collection Overview');
    await navigateToCollection(page);
    await takeScreenshot(page, 'collection-overview');

    // Verify we're on the collection page
    await expect(page).toHaveURL(/.*collection\/overview/);

    // Step 2: Check for persistent agents initialization
    console.log('\nStep 2: Verify persistent agents initialization');
    try {
      await waitForAgents(page);
      console.log('✓ Persistent agents initialized successfully');
    } catch (error) {
      console.log('⚠ Persistent agents initialization not detected');
    }

    // Step 3: Start New Collection Flow
    console.log('\nStep 3: Start New Collection Flow');
    const startCollectionButton = page.locator('button:has-text("Start Collection"), button:has-text("New Collection"), [data-testid="start-collection"]');

    if (await startCollectionButton.isVisible({ timeout: 5000 })) {
      await startCollectionButton.click();
      console.log('✓ Started new collection flow');
    } else {
      console.log('⚠ Start collection button not found, trying alternative navigation');
      await clickWithRetry(page, 'text=Adaptive Forms');
    }

    await page.waitForTimeout(2000);
    await takeScreenshot(page, 'collection-flow-started');

    // Step 4: Navigate to Adaptive Forms
    console.log('\nStep 4: Navigate to Adaptive Forms');
    await clickWithRetry(page, 'text=Adaptive Forms');
    await page.waitForTimeout(3000);
    await takeScreenshot(page, 'collection-adaptive-forms');

    // Verify adaptive forms interface
    const formElements = [
      '.adaptive-form',
      '[data-testid="adaptive-form"]',
      '.form-builder',
      '.collection-form'
    ];

    let formFound = false;
    for (const selector of formElements) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        formFound = true;
        console.log('✓ Adaptive forms interface loaded');
        break;
      }
    }

    if (!formFound) {
      console.log('⚠ Adaptive forms interface not immediately visible');
      // Try to trigger form generation
      const generateFormButton = page.locator('button:has-text("Generate Form"), button:has-text("Create Form")');
      if (await generateFormButton.isVisible({ timeout: 5000 })) {
        await generateFormButton.click();
        await page.waitForTimeout(3000);
      }
    }

    // Step 5: Test Adaptive Form Functionality
    console.log('\nStep 5: Test Adaptive Form Functionality');

    // Look for form fields
    const formFields = await page.locator('input, select, textarea, .form-field').count();
    console.log(`✓ Found ${formFields} form fields`);

    if (formFields > 0) {
      // Fill out available form fields
      const textInputs = page.locator('input[type="text"], input[type="email"], textarea');
      const textInputCount = await textInputs.count();

      for (let i = 0; i < Math.min(textInputCount, 3); i++) {
        const input = textInputs.nth(i);
        if (await input.isVisible()) {
          await input.fill(`Test data ${i + 1}`);
          console.log(`✓ Filled form field ${i + 1}`);
        }
      }

      // Handle select dropdowns
      const selects = page.locator('select');
      const selectCount = await selects.count();

      for (let i = 0; i < Math.min(selectCount, 2); i++) {
        const select = selects.nth(i);
        if (await select.isVisible()) {
          const options = await select.locator('option').count();
          if (options > 1) {
            await select.selectOption({ index: 1 });
            console.log(`✓ Selected option in dropdown ${i + 1}`);
          }
        }
      }
    }

    // Step 6: Submit Adaptive Form
    console.log('\nStep 6: Submit Adaptive Form');
    const submitButtons = [
      'button:has-text("Submit")',
      'button:has-text("Continue")',
      'button:has-text("Next")',
      '[data-testid="form-submit"]'
    ];

    let formSubmitted = false;
    for (const buttonSelector of submitButtons) {
      const button = page.locator(buttonSelector);
      if (await button.isVisible({ timeout: 3000 })) {
        await button.click();
        formSubmitted = true;
        console.log('✓ Form submitted successfully');
        await page.waitForTimeout(2000);
        break;
      }
    }

    await takeScreenshot(page, 'collection-form-submitted');

    // Step 7: Test Automated Collection Phase
    console.log('\nStep 7: Test Automated Collection Phase');
    await clickWithRetry(page, 'text=Automated Collection');
    await page.waitForTimeout(3000);
    await takeScreenshot(page, 'collection-automated');

    // Verify automated collection interface
    const automationElements = [
      '.automation-panel',
      '[data-testid="automated-collection"]',
      'text="Collection in Progress"',
      'text="Automated Discovery"'
    ];

    let automationVisible = false;
    for (const selector of automationElements) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        automationVisible = true;
        console.log('✓ Automated collection interface visible');
        break;
      }
    }

    // Check for collection progress indicators
    const progressIndicators = [
      '.progress-bar',
      '.collection-progress',
      '[data-testid="collection-progress"]',
      'text="Progress"'
    ];

    for (const selector of progressIndicators) {
      if (await page.locator(selector).isVisible({ timeout: 3000 })) {
        console.log('✓ Collection progress indicator found');
        break;
      }
    }

    // Step 8: Test Gap Analysis
    console.log('\nStep 8: Test Gap Analysis');
    await clickWithRetry(page, 'text=Gap Analysis');
    await page.waitForTimeout(3000);
    await takeScreenshot(page, 'collection-gap-analysis');

    // Verify gap analysis components
    const gapAnalysisElements = [
      '.gap-analysis',
      '[data-testid="gap-analysis"]',
      'text="Missing Data"',
      'text="Data Gaps"',
      'text="Coverage"'
    ];

    let gapAnalysisVisible = false;
    for (const selector of gapAnalysisElements) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        gapAnalysisVisible = true;
        console.log('✓ Gap analysis interface visible');
        break;
      }
    }

    // Check for gap analysis data
    const gapItems = await page.locator('.gap-item, .missing-data-item, [data-testid="gap-item"]').count();
    console.log(`✓ Found ${gapItems} gap analysis items`);

    // Step 9: Verify Collection Completion
    console.log('\nStep 9: Verify Collection Completion');

    // Look for completion indicators
    const completionIndicators = [
      'text="Collection Complete"',
      'text="Collection Finished"',
      '[data-testid="collection-complete"]',
      '.status-complete'
    ];

    let collectionCompleted = false;
    for (const selector of completionIndicators) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        collectionCompleted = true;
        console.log('✓ Collection marked as completed');
        break;
      }
    }

    // Step 10: Verify Fixed Multiple Rows Issue
    console.log('\nStep 10: Verify Multiple Rows Issue is Fixed');

    // Check that no HTTP 500 errors occurred in collection endpoints
    const collectionAPIErrors = networkErrors.filter(error =>
      error.url.includes('/api/v1/collection') && error.status === 500
    );

    if (collectionAPIErrors.length === 0) {
      console.log('✓ No HTTP 500 errors in collection API - multiple rows issue resolved');
    } else {
      console.log(`✗ Found ${collectionAPIErrors.length} HTTP 500 errors in collection API:`);
      collectionAPIErrors.forEach(error => {
        console.log(`  - ${error.url}: ${JSON.stringify(error.responseBody)}`);
      });
    }

    // Specifically check for database constraint violations
    const constraintErrors = consoleErrors.filter(error =>
      error.includes('duplicate key') ||
      error.includes('multiple rows') ||
      error.includes('constraint violation')
    );

    if (constraintErrors.length === 0) {
      console.log('✓ No database constraint violations detected');
    } else {
      console.log(`✗ Found ${constraintErrors.length} database constraint violations:`);
      constraintErrors.forEach(error => console.log(`  - ${error}`));
    }

    // Final verification - should have minimal errors
    expect(consoleErrors.filter(error => !error.includes('Warning')).length).toBeLessThan(5);
    expect(networkErrors.filter(error => error.status >= 500).length).toBe(0);

    console.log('\n=== COLLECTION FLOW COMPLETED SUCCESSFULLY ===');
  });

  test('Collection Flow - Adaptive Forms Validation', async ({ page }) => {
    console.log('\n=== TESTING ADAPTIVE FORMS VALIDATION ===');

    await navigateToCollection(page);
    await clickWithRetry(page, 'text=Adaptive Forms');
    await page.waitForTimeout(3000);

    // Test form validation with empty fields
    const submitButton = page.locator('button:has-text("Submit"), button:has-text("Continue")').first();

    if (await submitButton.isVisible()) {
      await submitButton.click();
      await page.waitForTimeout(1000);

      // Check for validation messages
      const validationErrors = [
        '.error-message',
        '.field-error',
        'text="Required"',
        'text="Please fill"',
        '[data-testid="validation-error"]'
      ];

      let validationFound = false;
      for (const selector of validationErrors) {
        if (await page.locator(selector).isVisible({ timeout: 3000 })) {
          validationFound = true;
          console.log('✓ Form validation working properly');
          break;
        }
      }

      if (!validationFound) {
        console.log('⚠ No validation errors shown for empty form');
      }
    }

    // Test form field constraints
    const emailInputs = page.locator('input[type="email"]');
    const emailCount = await emailInputs.count();

    if (emailCount > 0) {
      const emailInput = emailInputs.first();
      await emailInput.fill('invalid-email');
      await emailInput.blur();

      // Check for email validation
      const emailError = page.locator('text="Invalid email", text="Enter a valid email"');
      if (await emailError.isVisible({ timeout: 3000 })) {
        console.log('✓ Email validation working');
      }
    }

    await takeScreenshot(page, 'collection-adaptive-forms-validation');
  });

  test('Collection Flow - Multiple Rows Issue Regression Test', async ({ page }) => {
    console.log('\n=== TESTING MULTIPLE ROWS ISSUE REGRESSION ===');

    await navigateToCollection(page);

    // Test multiple rapid form submissions that could cause the multiple rows issue
    console.log('Testing rapid form submissions...');

    for (let i = 0; i < 3; i++) {
      console.log(`Submission attempt ${i + 1}`);

      await clickWithRetry(page, 'text=Adaptive Forms');
      await page.waitForTimeout(1000);

      // Fill form if available
      const textInputs = page.locator('input[type="text"]');
      const inputCount = await textInputs.count();

      if (inputCount > 0) {
        await textInputs.first().fill(`Test submission ${i + 1}`);
      }

      // Submit form
      const submitButton = page.locator('button:has-text("Submit"), button:has-text("Continue")').first();
      if (await submitButton.isVisible()) {
        await submitButton.click();
        await page.waitForTimeout(2000);
      }

      // Check for errors after each submission
      const currentErrors = networkErrors.filter(error =>
        error.url.includes('/collection') && error.status === 500
      );

      if (currentErrors.length > 0) {
        console.log(`✗ HTTP 500 error on submission ${i + 1}`);
        break;
      } else {
        console.log(`✓ Submission ${i + 1} successful`);
      }
    }

    // Verify no multiple rows constraint violations
    const multipleRowsErrors = networkErrors.filter(error =>
      error.responseBody &&
      (error.responseBody.includes?.('multiple rows') ||
       error.responseBody.includes?.('duplicate key'))
    );

    if (multipleRowsErrors.length === 0) {
      console.log('✓ Multiple rows issue regression test passed');
    } else {
      console.log(`✗ Multiple rows issue detected: ${multipleRowsErrors.length} errors`);
      multipleRowsErrors.forEach(error => {
        console.log(`  - ${error.url}: ${JSON.stringify(error.responseBody)}`);
      });
    }

    await takeScreenshot(page, 'collection-multiple-rows-regression');
  });

  test('Collection Flow - Automated Collection Monitoring', async ({ page }) => {
    console.log('\n=== TESTING AUTOMATED COLLECTION MONITORING ===');

    await navigateToCollection(page);
    await clickWithRetry(page, 'text=Automated Collection');
    await page.waitForTimeout(3000);

    // Test collection status monitoring
    const statusIndicators = [
      '.collection-status',
      '[data-testid="collection-status"]',
      'text="In Progress"',
      'text="Running"',
      'text="Collecting"'
    ];

    let statusVisible = false;
    for (const selector of statusIndicators) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        statusVisible = true;
        const statusText = await page.locator(selector).textContent();
        console.log(`✓ Collection status visible: ${statusText}`);
        break;
      }
    }

    // Test real-time updates
    console.log('Monitoring for real-time updates...');
    const initialContent = await page.content();
    await page.waitForTimeout(5000);
    const updatedContent = await page.content();

    if (initialContent !== updatedContent) {
      console.log('✓ Real-time updates detected');
    } else {
      console.log('⚠ No content changes detected (may be normal)');
    }

    // Test collection metrics
    const metricsElements = [
      '.collection-metrics',
      '[data-testid="collection-metrics"]',
      'text="Collected"',
      'text="Items"',
      'text="Progress"'
    ];

    for (const selector of metricsElements) {
      if (await page.locator(selector).isVisible({ timeout: 3000 })) {
        console.log('✓ Collection metrics visible');
        break;
      }
    }

    await takeScreenshot(page, 'collection-automated-monitoring');
  });

  test('Collection Flow - Gap Analysis Accuracy', async ({ page }) => {
    console.log('\n=== TESTING GAP ANALYSIS ACCURACY ===');

    await navigateToCollection(page);
    await clickWithRetry(page, 'text=Gap Analysis');
    await page.waitForTimeout(3000);

    // Test gap identification
    const gapCategories = [
      'text="Missing Applications"',
      'text="Incomplete Data"',
      'text="Configuration Gaps"',
      'text="Dependency Gaps"'
    ];

    let categoriesFound = 0;
    for (const category of gapCategories) {
      if (await page.locator(category).isVisible({ timeout: 3000 })) {
        categoriesFound++;
      }
    }

    console.log(`✓ Found ${categoriesFound} gap analysis categories`);

    // Test gap analysis data quality
    const gapItems = await page.locator('.gap-item, [data-testid="gap-item"]').count();
    if (gapItems > 0) {
      console.log(`✓ ${gapItems} gap items identified for analysis`);

      // Check first gap item for completeness
      const firstGap = page.locator('.gap-item, [data-testid="gap-item"]').first();
      if (await firstGap.isVisible()) {
        const gapText = await firstGap.textContent();
        if (gapText && gapText.trim().length > 0) {
          console.log('✓ Gap items contain descriptive information');
        }
      }
    }

    // Test gap resolution suggestions
    const resolutionElements = [
      'text="Recommended Actions"',
      'text="Resolution Steps"',
      '.gap-resolution',
      '[data-testid="gap-resolution"]'
    ];

    for (const selector of resolutionElements) {
      if (await page.locator(selector).isVisible({ timeout: 3000 })) {
        console.log('✓ Gap resolution suggestions available');
        break;
      }
    }

    await takeScreenshot(page, 'collection-gap-analysis-accuracy');
  });

  test('Collection Flow - Error Recovery and Resilience', async ({ page }) => {
    console.log('\n=== TESTING ERROR RECOVERY AND RESILIENCE ===');

    await navigateToCollection(page);

    // Simulate network interruption during collection
    console.log('Simulating network interruption...');

    await page.route('**/api/v1/collection/**', async route => {
      const url = route.request().url();

      // Simulate intermittent failures
      const shouldFail = Math.random() < 0.3; // 30% failure rate

      if (shouldFail && url.includes('submit')) {
        console.log(`Simulating failure for: ${url}`);
        await route.fulfill({
          status: 503,
          body: JSON.stringify({ error: 'Service temporarily unavailable' })
        });
      } else {
        await route.continue();
      }
    });

    // Test form submission with simulated failures
    await clickWithRetry(page, 'text=Adaptive Forms');
    await page.waitForTimeout(2000);

    const textInput = page.locator('input[type="text"]').first();
    if (await textInput.isVisible()) {
      await textInput.fill('Test resilience data');
    }

    const submitButton = page.locator('button:has-text("Submit")').first();
    if (await submitButton.isVisible()) {
      // Try multiple submissions to test retry logic
      for (let i = 0; i < 3; i++) {
        console.log(`Submission attempt ${i + 1}...`);
        await submitButton.click();
        await page.waitForTimeout(2000);

        // Check for error handling
        const errorMessage = page.locator('.error-message, text="Error", text="Failed"');
        if (await errorMessage.isVisible({ timeout: 3000 })) {
          console.log('✓ Error handling displayed to user');

          // Check for retry mechanism
          const retryButton = page.locator('button:has-text("Retry"), button:has-text("Try Again")');
          if (await retryButton.isVisible({ timeout: 3000 })) {
            console.log('✓ Retry mechanism available');
            await retryButton.click();
            await page.waitForTimeout(1000);
          }
        }

        // Check if submission eventually succeeded
        const successMessage = page.locator('.success-message, text="Success", text="Submitted"');
        if (await successMessage.isVisible({ timeout: 3000 })) {
          console.log(`✓ Submission succeeded on attempt ${i + 1}`);
          break;
        }
      }
    }

    // Remove network simulation
    await page.unroute('**/api/v1/collection/**');

    await takeScreenshot(page, 'collection-error-recovery');
  });

  test('Collection Flow - Data Validation and Integrity', async ({ page }) => {
    console.log('\n=== TESTING DATA VALIDATION AND INTEGRITY ===');

    await navigateToCollection(page);
    await clickWithRetry(page, 'text=Adaptive Forms');
    await page.waitForTimeout(2000);

    // Test data type validation
    const numberInputs = page.locator('input[type="number"]');
    const numberCount = await numberInputs.count();

    if (numberCount > 0) {
      const numberInput = numberInputs.first();
      await numberInput.fill('abc123'); // Invalid number
      await numberInput.blur();

      // Check for number validation
      const numberError = page.locator('text="Invalid number", text="Enter a number"');
      if (await numberError.isVisible({ timeout: 3000 })) {
        console.log('✓ Number validation working');
      }
    }

    // Test URL validation if present
    const urlInputs = page.locator('input[type="url"]');
    const urlCount = await urlInputs.count();

    if (urlCount > 0) {
      const urlInput = urlInputs.first();
      await urlInput.fill('not-a-url');
      await urlInput.blur();

      const urlError = page.locator('text="Invalid URL", text="Enter a valid URL"');
      if (await urlError.isVisible({ timeout: 3000 })) {
        console.log('✓ URL validation working');
      }
    }

    // Test date validation if present
    const dateInputs = page.locator('input[type="date"]');
    const dateCount = await dateInputs.count();

    if (dateCount > 0) {
      console.log('✓ Date input fields available for validation');
    }

    // Test required field validation
    const requiredInputs = page.locator('input[required], select[required], textarea[required]');
    const requiredCount = await requiredInputs.count();

    if (requiredCount > 0) {
      console.log(`✓ ${requiredCount} required fields properly marked`);

      // Test submitting with empty required fields
      const submitButton = page.locator('button:has-text("Submit")').first();
      if (await submitButton.isVisible()) {
        await submitButton.click();

        // Check for required field validation
        const requiredError = page.locator('text="Required", text="This field is required"');
        if (await requiredError.isVisible({ timeout: 3000 })) {
          console.log('✓ Required field validation working');
        }
      }
    }

    await takeScreenshot(page, 'collection-data-validation');
  });
});
