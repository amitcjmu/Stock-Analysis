/**
 * Comprehensive Assessment Flow E2E Tests
 * Tests the complete assessment workflow including risk and modernization assessments
 * Covers happy path, error scenarios, and assessment recommendation validation
 *
 * Generated by CC
 */

import { test, expect, Page, BrowserContext } from '@playwright/test';
import {
  TEST_CONFIG,
  TEST_USERS,
  TEST_DATA,
  login,
  navigateToAssessment,
  waitForAPIResponse,
  checkForConsoleErrors,
  takeScreenshot,
  waitForElement,
  clickWithRetry,
  fillForm,
  expectElementText,
  checkFlowStatus,
  waitForAgents,
  cleanup
} from './helpers/test-helpers';
import path from 'path';
import fs from 'fs';

test.describe('Assessment Flow E2E Tests', () => {
  const assessmentId: string | null = null;
  let consoleErrors: string[] = [];
  let networkErrors: Array<{ url: string; status: number; statusText?: string; responseBody?: any }> = [];
  let assessmentData: any[] = [];

  // Load test assessment data
  const testAssessmentFile = path.join(process.cwd(), 'tests', 'e2e', 'fixtures', 'assessment-test-applications.json');
  let testApplications: any = {};

  test.beforeAll(async () => {
    // Load assessment test data
    try {
      const testDataContent = fs.readFileSync(testAssessmentFile, 'utf8');
      testApplications = JSON.parse(testDataContent);
      console.log(`Loaded ${testApplications.test_applications?.length || 0} test applications for assessment`);
    } catch (error) {
      console.log(`Warning: Could not load test assessment data: ${error}`);
      testApplications = { test_applications: [] };
    }
  });

  test.beforeEach(async ({ page, context }) => {
    // Reset tracking arrays
    consoleErrors = [];
    networkErrors = [];
    assessmentData = [];

    // Enhanced console error monitoring
    page.on('console', (msg) => {
      if (msg.type() === 'error') {
        consoleErrors.push(msg.text());
        console.log(`Console Error: ${msg.text()}`);
      }
    });

    // Enhanced network monitoring for Assessment API
    page.on('response', async (response) => {
      const url = response.url();

      if (response.status() >= 400) {
        let responseBody;
        try {
          responseBody = await response.json();
        } catch (e) {
          responseBody = await response.text();
        }

        networkErrors.push({
          url,
          status: response.status(),
          statusText: response.statusText(),
          responseBody
        });

        console.log(`Network Error: ${response.status()} ${url}`);
        if (responseBody) console.log(`Response: ${JSON.stringify(responseBody, null, 2)}`);
      }

      // Track Assessment API responses
      if (url.includes('/api/v1/assessment') || url.includes('/assessment-flow')) {
        let responseData;
        try {
          responseData = await response.json();
        } catch (e) {
          responseData = await response.text();
        }

        assessmentData.push({
          url,
          status: response.status(),
          data: responseData
        });
      }
    });

    // Login before each test
    await login(page, TEST_USERS.demo);
    await takeScreenshot(page, 'assessment-logged-in');
  });

  test.afterEach(async ({ page, context }, testInfo) => {
    // Take screenshot on failure
    if (testInfo.status === 'failed') {
      await takeScreenshot(page, `assessment-failure-${testInfo.title.replace(/\s+/g, '-')}`);
    }

    // Enhanced test summary
    console.log(`\n=== ${testInfo.title} SUMMARY ===`);
    console.log(`Status: ${testInfo.status}`);
    console.log(`Duration: ${testInfo.duration}ms`);
    console.log(`Console Errors: ${consoleErrors.length}`);
    console.log(`Network Errors: ${networkErrors.length}`);
    console.log(`Assessment API Calls: ${assessmentData.length}`);

    // Log Assessment API responses for debugging
    if (assessmentData.length > 0) {
      console.log('\nAssessment API Responses:');
      assessmentData.forEach((resp, index) => {
        console.log(`  ${index + 1}. ${resp.status} - ${resp.url}`);
      });
    }

    if (consoleErrors.length > 0) {
      console.log('Console Errors:');
      consoleErrors.forEach((error, index) => console.log(`  ${index + 1}. ${error}`));
    }

    if (networkErrors.length > 0) {
      console.log('Network Errors:');
      networkErrors.forEach((error, index) => {
        console.log(`  ${index + 1}. ${error.status} - ${error.url}`);
        if (error.responseBody) {
          console.log(`    Body: ${JSON.stringify(error.responseBody, null, 2)}`);
        }
      });
    }

    // Cleanup browser context
    await cleanup(context);
  });

  test('Complete Assessment Flow - Happy Path', async ({ page }) => {
    console.log('\n=== STARTING COMPLETE ASSESSMENT FLOW - HAPPY PATH ===');

    // Step 1: Navigate to Assessment Overview
    console.log('\nStep 1: Navigate to Assessment Overview');
    await navigateToAssessment(page);
    await takeScreenshot(page, 'assessment-overview');

    // Verify we're on the assessment page
    await expect(page).toHaveURL(/.*assessment\/overview/);

    // Step 2: Check for persistent agents initialization
    console.log('\nStep 2: Verify persistent agents initialization');
    try {
      await waitForAgents(page);
      console.log('✓ Persistent agents initialized successfully');
    } catch (error) {
      console.log('⚠ Persistent agents initialization not detected');
    }

    // Step 3: Start New Assessment
    console.log('\nStep 3: Start New Assessment');
    const startAssessmentButton = page.locator('button:has-text("Start Assessment"), button:has-text("New Assessment"), [data-testid="start-assessment"]');

    if (await startAssessmentButton.isVisible({ timeout: 5000 })) {
      await startAssessmentButton.click();
      console.log('✓ Started new assessment');
      await page.waitForTimeout(2000);
    } else {
      console.log('⚠ Start assessment button not found, continuing to application selection');
    }
    await takeScreenshot(page, 'assessment-started');

    // Step 4: Navigate to Application Selection
    console.log('\nStep 4: Navigate to Application Selection');
    const appSelectionSelectors = [
      'text=Application Selection',
      'text=Select Applications',
      'text=Choose Applications',
      'a[href*="application-selection"]'
    ];

    let navSuccessful = false;
    for (const selector of appSelectionSelectors) {
      if (await page.locator(selector).isVisible({ timeout: 3000 })) {
        await page.locator(selector).click();
        navSuccessful = true;
        break;
      }
    }

    if (!navSuccessful) {
      console.log('⚠ Direct navigation failed, trying URL navigation');
      await page.goto(`${TEST_CONFIG.baseURL}/assessment/application-selection`);
    }

    await page.waitForTimeout(3000);
    await takeScreenshot(page, 'assessment-app-selection');

    // Step 5: Select Applications for Assessment
    console.log('\nStep 5: Select Applications for Assessment');

    // Look for application selection interface
    const appSelectionElements = [
      '.application-list',
      '[data-testid="application-list"]',
      '.app-selection-grid',
      'table tbody tr'
    ];

    let appsFound = false;
    let selectedAppsCount = 0;

    for (const selector of appSelectionElements) {
      const elements = await page.locator(selector);
      const count = await elements.count();

      if (count > 0) {
        appsFound = true;
        console.log(`✓ Found ${count} applications available for selection`);

        // Select first few applications
        const selectableItems = Math.min(count, 3);
        for (let i = 0; i < selectableItems; i++) {
          const checkbox = elements.nth(i).locator('input[type="checkbox"], .selection-checkbox').first();
          if (await checkbox.isVisible()) {
            await checkbox.check();
            selectedAppsCount++;
            console.log(`✓ Selected application ${i + 1}`);
          }
        }
        break;
      }
    }

    if (!appsFound) {
      console.log('⚠ No applications found, will create test applications');

      // Try to add test applications
      const addAppButton = page.locator('button:has-text("Add Application"), button:has-text("Import Applications")');
      if (await addAppButton.isVisible({ timeout: 3000 })) {
        await addAppButton.click();
        await page.waitForTimeout(1000);

        // Fill in test application data if forms are available
        if (testApplications.test_applications?.length > 0) {
          const testApp = testApplications.test_applications[0];

          const nameInput = page.locator('input[name="name"], input[placeholder*="name"]').first();
          if (await nameInput.isVisible({ timeout: 3000 })) {
            await nameInput.fill(testApp.name);
            console.log(`✓ Added test application: ${testApp.name}`);
          }
        }
      }
    }

    console.log(`✓ Selected ${selectedAppsCount} applications for assessment`);

    // Continue to next step
    const continueButton = page.locator('button:has-text("Continue"), button:has-text("Next"), button:has-text("Proceed")');
    if (await continueButton.isVisible({ timeout: 5000 })) {
      await continueButton.click();
      console.log('✓ Proceeded to next step');
      await page.waitForTimeout(2000);
    }

    // Step 6: Complete Risk Assessment
    console.log('\nStep 6: Complete Risk Assessment');
    await clickWithRetry(page, 'text=Risk Assessment');
    await page.waitForTimeout(3000);
    await takeScreenshot(page, 'assessment-risk');

    // Look for risk assessment interface
    const riskElements = [
      '.risk-assessment',
      '[data-testid="risk-assessment"]',
      'text="Risk Score"',
      'text="Risk Level"',
      '.risk-criteria'
    ];

    let riskInterfaceFound = false;
    for (const selector of riskElements) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        riskInterfaceFound = true;
        console.log('✓ Risk assessment interface loaded');
        break;
      }
    }

    // Fill out risk assessment forms
    const riskInputs = page.locator('input[type="range"], select, input[type="number"]');
    const riskInputCount = await riskInputs.count();

    if (riskInputCount > 0) {
      console.log(`✓ Found ${riskInputCount} risk assessment inputs`);

      for (let i = 0; i < Math.min(riskInputCount, 5); i++) {
        const input = riskInputs.nth(i);
        const tagName = await input.evaluate(el => el.tagName);

        if (tagName === 'SELECT') {
          const options = await input.locator('option').count();
          if (options > 1) {
            await input.selectOption({ index: Math.floor(Math.random() * (options - 1)) + 1 });
            console.log(`✓ Selected option for risk criterion ${i + 1}`);
          }
        } else if (tagName === 'INPUT') {
          const inputType = await input.getAttribute('type');
          if (inputType === 'range') {
            await input.fill('5'); // Mid-range value
          } else if (inputType === 'number') {
            await input.fill((Math.floor(Math.random() * 10) + 1).toString());
          }
          console.log(`✓ Set value for risk input ${i + 1}`);
        }
      }
    }

    // Submit risk assessment
    const submitRiskButton = page.locator('button:has-text("Calculate Risk"), button:has-text("Submit"), button:has-text("Analyze")').first();
    if (await submitRiskButton.isVisible({ timeout: 5000 })) {
      await submitRiskButton.click();
      console.log('✓ Submitted risk assessment');
      await page.waitForTimeout(3000);
    }

    // Verify risk results
    const riskResults = [
      'text="Risk Score"',
      'text="High Risk"',
      'text="Medium Risk"',
      'text="Low Risk"',
      '.risk-result'
    ];

    for (const selector of riskResults) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        const resultText = await page.locator(selector).textContent();
        console.log(`✓ Risk assessment result: ${resultText}`);
        break;
      }
    }

    // Step 7: Complete Modernization Assessment
    console.log('\nStep 7: Complete Modernization Assessment');
    await clickWithRetry(page, 'text=Modernization Assessment');
    await page.waitForTimeout(3000);
    await takeScreenshot(page, 'assessment-modernization');

    // Look for modernization assessment interface
    const modernizationElements = [
      '.modernization-assessment',
      '[data-testid="modernization-assessment"]',
      'text="6R Strategy"',
      'text="Migration Strategy"',
      'text="Modernization Score"'
    ];

    let modernizationInterfaceFound = false;
    for (const selector of modernizationElements) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        modernizationInterfaceFound = true;
        console.log('✓ Modernization assessment interface loaded');
        break;
      }
    }

    // Fill out modernization criteria
    const modernizationInputs = page.locator('.modernization-criteria input, .assessment-criteria input, select');
    const modernizationInputCount = await modernizationInputs.count();

    if (modernizationInputCount > 0) {
      console.log(`✓ Found ${modernizationInputCount} modernization assessment inputs`);

      for (let i = 0; i < Math.min(modernizationInputCount, 7); i++) {
        const input = modernizationInputs.nth(i);
        const tagName = await input.evaluate(el => el.tagName);

        if (tagName === 'SELECT') {
          const options = await input.locator('option').count();
          if (options > 1) {
            await input.selectOption({ index: Math.floor(Math.random() * (options - 1)) + 1 });
            console.log(`✓ Selected modernization criterion ${i + 1}`);
          }
        } else if (tagName === 'INPUT') {
          const inputType = await input.getAttribute('type');
          if (inputType === 'range') {
            await input.fill((Math.floor(Math.random() * 8) + 2).toString()); // 2-10 range
          } else if (inputType === 'number') {
            await input.fill((Math.floor(Math.random() * 10) + 1).toString());
          }
          console.log(`✓ Set modernization value ${i + 1}`);
        }
      }
    }

    // Submit modernization assessment
    const submitModernizationButton = page.locator('button:has-text("Calculate Strategy"), button:has-text("Analyze"), button:has-text("Submit")').first();
    if (await submitModernizationButton.isVisible({ timeout: 5000 })) {
      await submitModernizationButton.click();
      console.log('✓ Submitted modernization assessment');
      await page.waitForTimeout(3000);
    }

    // Step 8: Verify Assessment Results and Recommendations
    console.log('\nStep 8: Verify Assessment Results and Recommendations');

    // Check for 6R strategy recommendations
    const sixRStrategies = [
      'text="Rehost"',
      'text="Refactor"',
      'text="Replatform"',
      'text="Repurchase"',
      'text="Retain"',
      'text="Retire"'
    ];

    let strategiesFound = 0;
    for (const strategy of sixRStrategies) {
      if (await page.locator(strategy).isVisible({ timeout: 3000 })) {
        strategiesFound++;
        const strategyText = await page.locator(strategy).textContent();
        console.log(`✓ Found strategy recommendation: ${strategyText}`);
      }
    }

    if (strategiesFound > 0) {
      console.log(`✓ Found ${strategiesFound} 6R strategy recommendations`);
    } else {
      console.log('⚠ No 6R strategy recommendations visible');
    }

    // Check for detailed recommendations
    const recommendationElements = [
      '.recommendation',
      '[data-testid="recommendation"]',
      '.assessment-result',
      'text="Recommendation"',
      'text="Suggested"'
    ];

    let recommendationsFound = false;
    for (const selector of recommendationElements) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        recommendationsFound = true;
        const recCount = await page.locator(selector).count();
        console.log(`✓ Found ${recCount} detailed recommendations`);
        break;
      }
    }

    // Check for confidence scores
    const confidenceElements = [
      'text="Confidence"',
      'text="Certainty"',
      '.confidence-score',
      '[data-testid="confidence"]'
    ];

    for (const selector of confidenceElements) {
      if (await page.locator(selector).isVisible({ timeout: 3000 })) {
        const confidenceText = await page.locator(selector).textContent();
        console.log(`✓ Confidence score displayed: ${confidenceText}`);
        break;
      }
    }

    // Step 9: Verify Flow Completion
    console.log('\nStep 9: Verify Assessment Flow Completion');

    const completionIndicators = [
      'text="Assessment Complete"',
      'text="Assessment Finished"',
      '[data-testid="assessment-complete"]',
      '.status-complete',
      'text="Results Generated"'
    ];

    let assessmentCompleted = false;
    for (const selector of completionIndicators) {
      if (await page.locator(selector).isVisible({ timeout: 5000 })) {
        assessmentCompleted = true;
        console.log('✓ Assessment marked as completed');
        break;
      }
    }

    // Step 10: Test Report Generation
    console.log('\nStep 10: Test Report Generation');

    const reportButtons = [
      'button:has-text("Generate Report")',
      'button:has-text("Export")',
      'button:has-text("Download")',
      '[data-testid="generate-report"]'
    ];

    for (const buttonSelector of reportButtons) {
      if (await page.locator(buttonSelector).isVisible({ timeout: 3000 })) {
        console.log('✓ Report generation available');

        // Test report generation (don't actually download in test)
        const reportButton = page.locator(buttonSelector);
        await reportButton.click();
        await page.waitForTimeout(2000);

        // Check for report generation confirmation
        const reportConfirmation = page.locator('text="Report Generated", text="Export Complete", text="Download Ready"');
        if (await reportConfirmation.isVisible({ timeout: 5000 })) {
          console.log('✓ Report generation confirmed');
        }
        break;
      }
    }

    // Final verification
    expect(consoleErrors.filter(error => !error.includes('Warning')).length).toBeLessThan(5);
    expect(networkErrors.filter(error => error.status >= 500).length).toBe(0);

    console.log('\n=== ASSESSMENT FLOW COMPLETED SUCCESSFULLY ===');
  });

  test('Assessment Flow - Application Selection Validation', async ({ page }) => {
    console.log('\n=== TESTING APPLICATION SELECTION VALIDATION ===');

    await navigateToAssessment(page);

    // Navigate to application selection
    const appSelectionLink = page.locator('text=Application Selection, text=Select Applications').first();
    if (await appSelectionLink.isVisible({ timeout: 5000 })) {
      await appSelectionLink.click();
    } else {
      await page.goto(`${TEST_CONFIG.baseURL}/assessment/application-selection`);
    }

    await page.waitForTimeout(2000);

    // Test proceeding without selections
    const continueButton = page.locator('button:has-text("Continue"), button:has-text("Next")').first();
    if (await continueButton.isVisible()) {
      await continueButton.click();

      // Check for validation message
      const validationMessages = [
        'text="Please select at least one application"',
        'text="No applications selected"',
        '.validation-error',
        '.error-message'
      ];

      let validationFound = false;
      for (const selector of validationMessages) {
        if (await page.locator(selector).isVisible({ timeout: 3000 })) {
          validationFound = true;
          console.log('✓ Application selection validation working');
          break;
        }
      }

      if (!validationFound) {
        console.log('⚠ No validation message for empty application selection');
      }
    }

    // Test bulk selection functionality
    const selectAllButton = page.locator('button:has-text("Select All"), input[type="checkbox"][data-testid="select-all"]');
    if (await selectAllButton.isVisible({ timeout: 3000 })) {
      await selectAllButton.click();
      console.log('✓ Bulk select all functionality available');

      // Test deselect all
      const deselectAllButton = page.locator('button:has-text("Deselect All"), button:has-text("Clear All")');
      if (await deselectAllButton.isVisible({ timeout: 3000 })) {
        await deselectAllButton.click();
        console.log('✓ Bulk deselect functionality working');
      }
    }

    await takeScreenshot(page, 'assessment-app-selection-validation');
  });

  test('Assessment Flow - Risk Assessment Accuracy', async ({ page }) => {
    console.log('\n=== TESTING RISK ASSESSMENT ACCURACY ===');

    await navigateToAssessment(page);
    await clickWithRetry(page, 'text=Risk Assessment');
    await page.waitForTimeout(3000);

    // Test risk calculation with known values
    if (testApplications.test_applications?.length > 0) {
      const testApp = testApplications.test_applications[0]; // Legacy COBOL app
      console.log(`Testing risk assessment for: ${testApp.name}`);

      // Set high risk factors for legacy application
      const complexityInput = page.locator('input[name*="complexity"], select[name*="complexity"]').first();
      if (await complexityInput.isVisible({ timeout: 3000 })) {
        const tagName = await complexityInput.evaluate(el => el.tagName);
        if (tagName === 'SELECT') {
          await complexityInput.selectOption('9'); // High complexity
        } else {
          await complexityInput.fill('9');
        }
        console.log('✓ Set high complexity score');
      }

      const ageInput = page.locator('input[name*="age"], select[name*="age"]').first();
      if (await ageInput.isVisible({ timeout: 3000 })) {
        await ageInput.fill('25'); // 25 years old
        console.log('✓ Set high age value');
      }

      const maintenanceInput = page.locator('select[name*="maintenance"]').first();
      if (await maintenanceInput.isVisible({ timeout: 3000 })) {
        await maintenanceInput.selectOption('very_high');
        console.log('✓ Set very high maintenance cost');
      }

      // Calculate risk
      const calculateButton = page.locator('button:has-text("Calculate"), button:has-text("Analyze")').first();
      if (await calculateButton.isVisible()) {
        await calculateButton.click();
        await page.waitForTimeout(3000);

        // Verify high risk result
        const highRiskIndicators = [
          'text="High Risk"',
          'text="Critical Risk"',
          '.risk-high',
          '.risk-critical'
        ];

        let highRiskFound = false;
        for (const selector of highRiskIndicators) {
          if (await page.locator(selector).isVisible({ timeout: 3000 })) {
            highRiskFound = true;
            console.log('✓ High risk correctly identified for legacy application');
            break;
          }
        }

        if (!highRiskFound) {
          console.log('⚠ Expected high risk not detected for legacy application');
        }
      }
    }

    await takeScreenshot(page, 'assessment-risk-accuracy');
  });

  test('Assessment Flow - 6R Strategy Recommendations', async ({ page }) => {
    console.log('\n=== TESTING 6R STRATEGY RECOMMENDATIONS ===');

    await navigateToAssessment(page);
    await clickWithRetry(page, 'text=Modernization Assessment');
    await page.waitForTimeout(3000);

    // Test different application scenarios from test data
    if (testApplications.test_applications?.length > 0) {
      for (const testApp of testApplications.test_applications.slice(0, 3)) {
        console.log(`\nTesting 6R strategy for: ${testApp.name}`);

        // Set parameters based on test application characteristics
        const businessValueInput = page.locator('input[name*="business"], select[name*="business"]').first();
        if (await businessValueInput.isVisible({ timeout: 2000 })) {
          await businessValueInput.fill('7');
          console.log('✓ Set business value');
        }

        const complexityInput = page.locator('input[name*="complexity"], select[name*="complexity"]').first();
        if (await complexityInput.isVisible({ timeout: 2000 })) {
          await complexityInput.fill(testApp.complexity_score?.toString() || '5');
          console.log('✓ Set technical complexity');
        }

        // Calculate strategy
        const calculateButton = page.locator('button:has-text("Calculate Strategy"), button:has-text("Analyze")').first();
        if (await calculateButton.isVisible()) {
          await calculateButton.click();
          await page.waitForTimeout(2000);

          // Check for expected strategy
          const expectedStrategy = testApp.expected_6r_strategy;
          if (expectedStrategy) {
            const strategyElement = page.locator(`text="${expectedStrategy}", text="${expectedStrategy.charAt(0).toUpperCase() + expectedStrategy.slice(1)}"`);
            if (await strategyElement.isVisible({ timeout: 3000 })) {
              console.log(`✓ Recommended strategy matches expected: ${expectedStrategy}`);
            } else {
              console.log(`⚠ Expected strategy ${expectedStrategy} not found`);
            }
          }
        }

        await page.waitForTimeout(1000);
      }
    }

    // Test that all 6R strategies are available as options
    const allStrategies = ['Rehost', 'Refactor', 'Replatform', 'Repurchase', 'Retain', 'Retire'];
    let strategiesAvailable = 0;

    for (const strategy of allStrategies) {
      if (await page.locator(`text="${strategy}"`).isVisible({ timeout: 2000 })) {
        strategiesAvailable++;
      }
    }

    console.log(`✓ ${strategiesAvailable}/6 6R strategies available in assessment`);

    await takeScreenshot(page, 'assessment-6r-strategies');
  });

  test('Assessment Flow - Recommendation Quality and Details', async ({ page }) => {
    console.log('\n=== TESTING RECOMMENDATION QUALITY AND DETAILS ===');

    await navigateToAssessment(page);

    // Complete a basic assessment to get recommendations
    await clickWithRetry(page, 'text=Modernization Assessment');
    await page.waitForTimeout(2000);

    // Fill assessment with moderate values
    const inputs = page.locator('input[type="range"], input[type="number"], select');
    const inputCount = await inputs.count();

    if (inputCount > 0) {
      for (let i = 0; i < Math.min(inputCount, 5); i++) {
        const input = inputs.nth(i);
        const tagName = await input.evaluate(el => el.tagName);

        if (tagName === 'SELECT') {
          const options = await input.locator('option').count();
          if (options > 1) {
            await input.selectOption({ index: 2 }); // Pick middle option
          }
        } else {
          await input.fill('5'); // Moderate value
        }
      }
    }

    // Generate recommendations
    const analyzeButton = page.locator('button:has-text("Analyze"), button:has-text("Calculate")').first();
    if (await analyzeButton.isVisible()) {
      await analyzeButton.click();
      await page.waitForTimeout(3000);
    }

    // Check recommendation quality
    const recommendationElements = page.locator('.recommendation, [data-testid="recommendation"]');
    const recCount = await recommendationElements.count();

    if (recCount > 0) {
      console.log(`✓ Found ${recCount} recommendations`);

      // Check first recommendation for completeness
      const firstRec = recommendationElements.first();
      if (await firstRec.isVisible()) {
        const recText = await firstRec.textContent();

        // Check for key recommendation components
        const hasStrategy = /rehost|refactor|replatform|repurchase|retain|retire/i.test(recText || '');
        const hasRationale = (recText?.length || 0) > 50; // Substantial text
        const hasConfidence = /confidence|certainty|\d+%/i.test(recText || '');

        if (hasStrategy) console.log('✓ Recommendation includes strategy');
        if (hasRationale) console.log('✓ Recommendation includes rationale');
        if (hasConfidence) console.log('✓ Recommendation includes confidence level');

        if (hasStrategy && hasRationale) {
          console.log('✓ Recommendation quality is adequate');
        }
      }
    }

    // Check for actionable next steps
    const nextStepsElements = [
      'text="Next Steps"',
      'text="Action Items"',
      'text="Implementation"',
      '.next-steps',
      '[data-testid="next-steps"]'
    ];

    for (const selector of nextStepsElements) {
      if (await page.locator(selector).isVisible({ timeout: 3000 })) {
        console.log('✓ Actionable next steps provided');
        break;
      }
    }

    // Check for cost estimates
    const costElements = [
      'text="Cost"',
      'text="Estimate"',
      'text="Budget"',
      'text="$"',
      '.cost-estimate'
    ];

    for (const selector of costElements) {
      if (await page.locator(selector).isVisible({ timeout: 3000 })) {
        console.log('✓ Cost information provided');
        break;
      }
    }

    await takeScreenshot(page, 'assessment-recommendation-quality');
  });

  test('Assessment Flow - Error Handling and Edge Cases', async ({ page }) => {
    console.log('\n=== TESTING ERROR HANDLING AND EDGE CASES ===');

    await navigateToAssessment(page);

    // Test assessment with extreme values
    await clickWithRetry(page, 'text=Risk Assessment');
    await page.waitForTimeout(2000);

    console.log('Testing extreme value handling...');

    // Set extreme values
    const rangeInputs = page.locator('input[type="range"]');
    const rangeCount = await rangeInputs.count();

    if (rangeCount > 0) {
      // Set first input to minimum
      await rangeInputs.nth(0).fill('0');
      console.log('✓ Set minimum extreme value');

      if (rangeCount > 1) {
        // Set second input to maximum
        const maxValue = await rangeInputs.nth(1).getAttribute('max') || '10';
        await rangeInputs.nth(1).fill(maxValue);
        console.log('✓ Set maximum extreme value');
      }
    }

    // Test with invalid data types
    const numberInputs = page.locator('input[type="number"]');
    const numberCount = await numberInputs.count();

    if (numberCount > 0) {
      await numberInputs.first().fill('-999'); // Invalid negative
      await numberInputs.first().blur();

      // Check for validation
      const validationError = page.locator('text="Invalid", .error-message, .validation-error');
      if (await validationError.isVisible({ timeout: 3000 })) {
        console.log('✓ Invalid number input validation working');
      }
    }

    // Test incomplete assessment submission
    const submitButton = page.locator('button:has-text("Calculate"), button:has-text("Submit")').first();
    if (await submitButton.isVisible()) {
      await submitButton.click();

      // Check for incomplete assessment handling
      const incompleteWarning = page.locator('text="Incomplete", text="Missing", .warning-message');
      if (await incompleteWarning.isVisible({ timeout: 3000 })) {
        console.log('✓ Incomplete assessment warning displayed');
      }
    }

    // Test network error recovery
    console.log('Testing network error recovery...');

    await page.route('**/api/v1/assessment/**', async route => {
      // Simulate server error once
      const url = route.request().url();
      if (url.includes('calculate') || url.includes('analyze')) {
        console.log('Simulating assessment API failure...');
        await route.fulfill({
          status: 500,
          body: JSON.stringify({ error: 'Assessment service temporarily unavailable' })
        });
      } else {
        await route.continue();
      }
    });

    // Try assessment calculation with simulated error
    if (await submitButton.isVisible()) {
      await submitButton.click();
      await page.waitForTimeout(2000);

      // Check for error handling
      const errorMessage = page.locator('text="Error", text="Failed", .error-message');
      if (await errorMessage.isVisible({ timeout: 3000 })) {
        console.log('✓ Assessment error handling working');

        // Check for retry mechanism
        const retryButton = page.locator('button:has-text("Retry"), button:has-text("Try Again")');
        if (await retryButton.isVisible({ timeout: 3000 })) {
          console.log('✓ Retry mechanism available');
        }
      }
    }

    // Remove error simulation
    await page.unroute('**/api/v1/assessment/**');

    await takeScreenshot(page, 'assessment-error-handling');
  });

  test('Assessment Flow - Performance and Scalability', async ({ page }) => {
    console.log('\n=== TESTING ASSESSMENT PERFORMANCE AND SCALABILITY ===');

    const startTime = Date.now();

    await navigateToAssessment(page);

    const navigationTime = Date.now() - startTime;
    console.log(`✓ Assessment navigation completed in ${navigationTime}ms`);

    // Test assessment with large dataset simulation
    await clickWithRetry(page, 'text=Modernization Assessment');
    await page.waitForTimeout(2000);

    // Simulate assessing multiple applications
    const assessmentStartTime = Date.now();

    // Fill out comprehensive assessment quickly
    const allInputs = page.locator('input, select');
    const inputCount = await allInputs.count();

    console.log(`Processing ${inputCount} assessment inputs...`);

    for (let i = 0; i < Math.min(inputCount, 10); i++) {
      const input = allInputs.nth(i);
      const tagName = await input.evaluate(el => el.tagName);

      if (tagName === 'SELECT') {
        await input.selectOption({ index: 1 });
      } else {
        await input.fill('5');
      }
    }

    // Submit assessment and measure time
    const submitButton = page.locator('button:has-text("Calculate"), button:has-text("Analyze")').first();
    if (await submitButton.isVisible()) {
      await submitButton.click();

      // Wait for results with timeout
      const resultsVisible = await page.locator('text="Result", text="Recommendation", .assessment-result').isVisible({ timeout: 15000 });

      const assessmentTime = Date.now() - assessmentStartTime;
      console.log(`✓ Assessment calculation completed in ${assessmentTime}ms`);

      if (resultsVisible) {
        console.log('✓ Assessment results generated within timeout');
      } else {
        console.log('⚠ Assessment results not visible within timeout');
      }
    }

    // Performance benchmarks
    expect(navigationTime).toBeLessThan(10000); // Navigation should be under 10s
    expect(Date.now() - assessmentStartTime).toBeLessThan(20000); // Assessment should be under 20s

    await takeScreenshot(page, 'assessment-performance');
  });
});
