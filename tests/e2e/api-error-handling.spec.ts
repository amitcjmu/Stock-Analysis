import { test, expect, Page, APIResponse, Request } from '@playwright/test';
import path from 'path';

/**
 * API Error Handling Test Suite
 * 
 * Tests the API error handling issues that were identified and fixed:
 * 1. Proper HTTP status codes (no unexpected 404s during flow transitions)
 * 2. API error responses with proper error messages
 * 3. Frontend error handling and user feedback
 * 4. Flow transition API consistency
 * 5. Clarifications endpoint functionality
 * 
 * Generated by CC (Claude Code)
 */

const BASE_URL = 'http://localhost:8081';
const API_URL = 'http://localhost:8000';

const TEST_USER = {
  email: 'chocka@gmail.com',
  password: 'Password123!'
};

interface ApiErrorResult {
  endpoint: string;
  expectedStatus: number;
  actualStatus: number;
  method: string;
  hasProperErrorResponse: boolean;
  errorMessage?: string;
  isFixed: boolean;
}

interface ErrorTrackingData {
  phase: string;
  errors: ApiErrorResult[];
  unexpectedErrors: string[];
  networkFailures: Request[];
}

// Helper function to perform login
async function loginUser(page: Page): Promise<void> {
  await page.goto(`${BASE_URL}/login`);
  await page.fill('input[type="email"]', TEST_USER.email);
  await page.fill('input[type="password"]', TEST_USER.password);
  await page.click('button[type="submit"]');
  await page.waitForURL('**/dashboard', { timeout: 10000 });
}

// Helper to validate API error response structure
function validateErrorResponse(response: any): boolean {
  return response && (
    response.error || 
    response.message || 
    response.detail || 
    response.errors ||
    (response.status && response.status !== 200)
  );
}

// Helper to extract flow ID from page
async function extractFlowId(page: Page): Promise<string | null> {
  const strategies = [
    async () => page.locator('text=/flow-\\d{8}-\\d{6}/').textContent(),
    async () => page.locator('[data-testid="flow-id"]').textContent(),
    async () => page.evaluate(() => {
      const keys = Object.keys(localStorage);
      for (const key of keys) {
        if (key.includes('flow')) {
          const value = localStorage.getItem(key);
          try {
            const parsed = JSON.parse(value || '{}');
            return parsed.flow_id || parsed.id;
          } catch {
            return value?.includes('flow-') ? value : null;
          }
        }
      }
      return null;
    })
  ];

  for (const strategy of strategies) {
    try {
      const result = await strategy();
      if (result?.trim()) return result.trim();
    } catch (error) {
      continue;
    }
  }
  return null;
}

test.describe('API Error Handling Validation', () => {
  let errorTracker: ErrorTrackingData;

  test.beforeEach(async ({ page }) => {
    await loginUser(page);
    
    errorTracker = {
      phase: '',
      errors: [],
      unexpectedErrors: [],
      networkFailures: []
    };

    // Set up network monitoring
    page.on('requestfailed', (request) => {
      errorTracker.networkFailures.push(request);
    });
  });

  test('Discovery flow API endpoints return proper status codes', async ({ page }) => {
    const apiEndpoints = [
      { path: '/api/v1/unified-discovery/flow/initialize', method: 'POST', expectedStatus: [200, 201] },
      { path: '/api/v1/unified-discovery/flow/status', method: 'GET', expectedStatus: [200] },
      { path: '/api/v1/flows', method: 'GET', expectedStatus: [200] }
    ];

    errorTracker.phase = 'Discovery Flow Initialization';

    await test.step('Initialize discovery flow and monitor API calls', async () => {
      await page.goto(`${BASE_URL}/discovery`);
      await page.waitForTimeout(2000);

      // Monitor flow initialization API call
      const initButton = page.locator('button').filter({ hasText: /Start New Discovery|New Flow|Initialize/i });
      if (await initButton.isVisible()) {
        const [response] = await Promise.all([
          page.waitForResponse(response => 
            response.url().includes('/flow/initialize') || 
            response.url().includes('/discovery/start')
          ),
          initButton.click()
        ]);

        const result: ApiErrorResult = {
          endpoint: response.url(),
          expectedStatus: 200,
          actualStatus: response.status(),
          method: response.request().method(),
          hasProperErrorResponse: false,
          isFixed: false
        };

        if (response.status() !== 200 && response.status() !== 201) {
          try {
            const errorData = await response.json();
            result.hasProperErrorResponse = validateErrorResponse(errorData);
            result.errorMessage = errorData.error || errorData.message || errorData.detail;
          } catch (error) {
            result.errorMessage = 'Could not parse error response';
          }
          result.isFixed = result.hasProperErrorResponse && response.status() !== 404;
        } else {
          result.isFixed = true;
          result.hasProperErrorResponse = true;
        }

        errorTracker.errors.push(result);

        // Assertion for flow initialization
        expect(response.status(), 
          `Flow initialization should return 200/201, got ${response.status()}`).toBeLessThan(400);
        
        if (response.status() === 404) {
          throw new Error(`Flow initialization returned 404 - API endpoint may be missing or incorrect`);
        }
      }

      await page.waitForTimeout(2000);
    });

    await test.step('Test flow status API endpoint', async () => {
      const flowId = await extractFlowId(page);
      
      if (flowId) {
        try {
          const statusResponse = await page.request.get(`${API_URL}/api/v1/unified-discovery/flow/${flowId}/status`);
          
          const result: ApiErrorResult = {
            endpoint: `/api/v1/unified-discovery/flow/${flowId}/status`,
            expectedStatus: 200,
            actualStatus: statusResponse.status(),
            method: 'GET',
            hasProperErrorResponse: false,
            isFixed: false
          };

          if (statusResponse.status() !== 200) {
            try {
              const errorData = await statusResponse.json();
              result.hasProperErrorResponse = validateErrorResponse(errorData);
              result.errorMessage = errorData.error || errorData.message;
            } catch (error) {
              result.errorMessage = 'Could not parse error response';
            }
          }

          result.isFixed = statusResponse.status() === 200 || (statusResponse.status() !== 404 && result.hasProperErrorResponse);
          errorTracker.errors.push(result);

          // Critical assertion - flow status should not return 404 for valid flow ID
          expect(statusResponse.status(), 
            `Flow status API returned ${statusResponse.status()} for valid flow ID ${flowId}`)
            .not.toBe(404);

          if (statusResponse.status() !== 200) {
            expect(result.hasProperErrorResponse, 
              'Non-200 responses should have proper error structure').toBe(true);
          }
        } catch (error) {
          errorTracker.unexpectedErrors.push(`Flow status API error: ${error}`);
        }
      } else {
        errorTracker.unexpectedErrors.push('Could not extract flow ID for status testing');
      }
    });

    await test.step('Test general flows API endpoint', async () => {
      try {
        const flowsResponse = await page.request.get(`${API_URL}/api/v1/flows`);
        
        const result: ApiErrorResult = {
          endpoint: '/api/v1/flows',
          expectedStatus: 200,
          actualStatus: flowsResponse.status(),
          method: 'GET',
          hasProperErrorResponse: false,
          isFixed: false
        };

        if (flowsResponse.status() !== 200) {
          try {
            const errorData = await flowsResponse.json();
            result.hasProperErrorResponse = validateErrorResponse(errorData);
            result.errorMessage = errorData.error || errorData.message;
          } catch (error) {
            result.errorMessage = 'Could not parse error response';
          }
        }

        result.isFixed = flowsResponse.status() === 200 || result.hasProperErrorResponse;
        errorTracker.errors.push(result);

        // Flows endpoint should return proper status
        expect(flowsResponse.status(), 
          `Flows API should return proper status, got ${flowsResponse.status()}`)
          .toBeLessThan(500);
          
      } catch (error) {
        errorTracker.unexpectedErrors.push(`Flows API error: ${error}`);
      }
    });
  });

  test('Flow transition APIs handle state changes properly', async ({ page }) => {
    errorTracker.phase = 'Flow Transitions';
    let flowId = '';

    await test.step('Create flow and test phase transitions', async () => {
      await page.goto(`${BASE_URL}/discovery`);
      await page.waitForTimeout(2000);

      // Initialize flow
      const initButton = page.locator('button').filter({ hasText: /Start New Discovery|New Flow/i });
      if (await initButton.isVisible()) {
        await initButton.click();
        await page.waitForTimeout(2000);
        flowId = await extractFlowId(page) || '';
      }

      if (!flowId) {
        throw new Error('Could not create flow for transition testing');
      }

      // Test transitions between phases
      const phases = [
        { name: 'CMDB Import', url: '/discovery/cmdb-import', apiPath: '/cmdb-import' },
        { name: 'Attribute Mapping', url: '/discovery/attribute-mapping', apiPath: '/attribute-mapping' },
        { name: 'Asset Inventory', url: '/discovery/asset-inventory', apiPath: '/inventory' }
      ];

      for (const phase of phases) {
        await page.goto(`${BASE_URL}${phase.url}`);
        await page.waitForTimeout(2000);

        // Check if page loads properly (no API errors causing blank pages)
        const pageContent = await page.textContent('body');
        if (!pageContent || pageContent.trim().length < 100) {
          errorTracker.unexpectedErrors.push(`${phase.name} page appears empty - possible API error`);
        }

        // Test flow state API for this phase
        try {
          const phaseResponse = await page.request.get(`${API_URL}/api/v1/unified-discovery/flow/${flowId}${phase.apiPath}`);
          
          const result: ApiErrorResult = {
            endpoint: `/api/v1/unified-discovery/flow/${flowId}${phase.apiPath}`,
            expectedStatus: 200,
            actualStatus: phaseResponse.status(),
            method: 'GET',
            hasProperErrorResponse: false,
            isFixed: false
          };

          if (phaseResponse.status() !== 200) {
            // 404 might be acceptable for some endpoints, but should have proper error structure
            if (phaseResponse.status() === 404) {
              try {
                const errorData = await phaseResponse.json();
                result.hasProperErrorResponse = validateErrorResponse(errorData);
                result.errorMessage = errorData.error || errorData.message || 'Resource not found';
                result.isFixed = result.hasProperErrorResponse;
              } catch {
                result.errorMessage = '404 with no error response body';
                result.isFixed = false;
              }
            } else {
              try {
                const errorData = await phaseResponse.json();
                result.hasProperErrorResponse = validateErrorResponse(errorData);
                result.errorMessage = errorData.error || errorData.message;
                result.isFixed = result.hasProperErrorResponse;
              } catch {
                result.errorMessage = 'Non-JSON error response';
                result.isFixed = false;
              }
            }
          } else {
            result.isFixed = true;
            result.hasProperErrorResponse = true;
          }

          errorTracker.errors.push(result);

        } catch (error) {
          errorTracker.unexpectedErrors.push(`${phase.name} API test error: ${error}`);
        }
      }
    });

    // Assertions
    const criticalErrors = errorTracker.errors.filter(e => 
      e.actualStatus === 404 && !e.hasProperErrorResponse
    );
    
    expect(criticalErrors.length, 
      'Should have no 404 errors without proper error responses').toBe(0);

    const serverErrors = errorTracker.errors.filter(e => e.actualStatus >= 500);
    expect(serverErrors.length, 'Should have no server errors').toBe(0);
  });

  test('File upload API error handling', async ({ page }) => {
    errorTracker.phase = 'File Upload';

    await test.step('Test file upload with various scenarios', async () => {
      await page.goto(`${BASE_URL}/discovery/cmdb-import`);
      await page.waitForTimeout(2000);

      const testFilePath = path.join(__dirname, '../fixtures/test-cmdb-data.csv');

      // Monitor upload API call
      const uploadArea = page.locator('.border-dashed').filter({ hasText: 'Application Discovery' }).first();
      if (await uploadArea.isVisible()) {
        await uploadArea.click();

        const [uploadResponse] = await Promise.all([
          page.waitForResponse(response => 
            response.url().includes('/upload') || 
            response.url().includes('/import') ||
            response.url().includes('/process')
          ),
          page.locator('input[type="file"]').setInputFiles(testFilePath)
        ]);

        const result: ApiErrorResult = {
          endpoint: uploadResponse.url(),
          expectedStatus: 200,
          actualStatus: uploadResponse.status(),
          method: uploadResponse.request().method(),
          hasProperErrorResponse: false,
          isFixed: false
        };

        if (uploadResponse.status() !== 200) {
          try {
            const errorData = await uploadResponse.json();
            result.hasProperErrorResponse = validateErrorResponse(errorData);
            result.errorMessage = errorData.error || errorData.message;
            result.isFixed = result.hasProperErrorResponse && uploadResponse.status() !== 404;
          } catch {
            result.errorMessage = 'Could not parse upload error response';
            result.isFixed = false;
          }
        } else {
          result.isFixed = true;
          result.hasProperErrorResponse = true;
        }

        errorTracker.errors.push(result);

        // Critical: file upload should not return 404
        expect(uploadResponse.status(), 
          `File upload returned ${uploadResponse.status()} - should not be 404`).not.toBe(404);

        if (uploadResponse.status() !== 200) {
          expect(result.hasProperErrorResponse, 
            'Upload errors should have proper error structure').toBe(true);
        }

        await page.waitForTimeout(3000);
      }
    });

    await test.step('Test upload validation errors', async () => {
      // Test with invalid file type if possible
      const invalidFilePath = path.join(__dirname, '../fixtures/invalid-file.txt');
      
      // Create a temporary invalid file for testing
      await page.evaluate(() => {
        const blob = new Blob(['invalid,data,format'], { type: 'text/plain' });
        const file = new File([blob], 'invalid-file.txt', { type: 'text/plain' });
        
        // Simulate file input
        const input = document.createElement('input');
        input.type = 'file';
        input.files = [file] as any;
      });

      // We can't easily test invalid file uploads without actual files,
      // but we can test the error handling structure by checking console errors
      const consoleErrors: string[] = [];
      page.on('console', msg => {
        if (msg.type() === 'error') {
          consoleErrors.push(msg.text());
        }
      });

      // Check for proper error handling in UI
      await page.waitForTimeout(2000);
      
      const errorMessages = await page.locator('.error, .alert-error, [role="alert"]').all();
      let hasUserFriendlyErrors = false;

      for (const errorElement of errorMessages) {
        const errorText = await errorElement.textContent();
        if (errorText && errorText.length > 10) { // Reasonable error message length
          hasUserFriendlyErrors = true;
          break;
        }
      }

      // Don't fail if no errors - this might be a successful case
      if (consoleErrors.length > 0 && !hasUserFriendlyErrors) {
        errorTracker.unexpectedErrors.push('Console errors present but no user-friendly error messages');
      }
    });
  });

  test('Clarifications endpoint functionality', async ({ page }) => {
    errorTracker.phase = 'Clarifications';

    await test.step('Test clarifications API endpoint', async () => {
      const flowId = await extractFlowId(page);
      
      if (!flowId) {
        // Create a flow for testing
        await page.goto(`${BASE_URL}/discovery`);
        const initBtn = page.locator('button').filter({ hasText: /Start New Discovery/i });
        if (await initBtn.isVisible()) {
          await initBtn.click();
          await page.waitForTimeout(2000);
          flowId = await extractFlowId(page) || '';
        }
      }

      if (flowId) {
        // Test clarifications endpoint
        try {
          const clarificationsResponse = await page.request.get(`${API_URL}/api/v1/unified-discovery/flow/${flowId}/clarifications`);
          
          const result: ApiErrorResult = {
            endpoint: `/api/v1/unified-discovery/flow/${flowId}/clarifications`,
            expectedStatus: 200,
            actualStatus: clarificationsResponse.status(),
            method: 'GET',
            hasProperErrorResponse: false,
            isFixed: false
          };

          if (clarificationsResponse.status() === 200) {
            // Test response structure
            try {
              const clarificationsData = await clarificationsResponse.json();
              result.hasProperErrorResponse = true;
              result.isFixed = true;
              
              // Validate clarifications response structure
              if (!Array.isArray(clarificationsData) && !clarificationsData.clarifications) {
                errorTracker.unexpectedErrors.push('Clarifications response has unexpected structure');
              }
            } catch (error) {
              result.errorMessage = 'Could not parse clarifications response';
              result.isFixed = false;
            }
          } else if (clarificationsResponse.status() === 404) {
            // 404 might be acceptable if no clarifications exist
            try {
              const errorData = await clarificationsResponse.json();
              result.hasProperErrorResponse = validateErrorResponse(errorData);
              result.errorMessage = errorData.error || 'No clarifications found';
              result.isFixed = result.hasProperErrorResponse;
            } catch {
              result.errorMessage = '404 with no error response';
              result.isFixed = false;
            }
          } else {
            try {
              const errorData = await clarificationsResponse.json();
              result.hasProperErrorResponse = validateErrorResponse(errorData);
              result.errorMessage = errorData.error || errorData.message;
            } catch {
              result.errorMessage = 'Non-JSON error response';
            }
            result.isFixed = result.hasProperErrorResponse;
          }

          errorTracker.errors.push(result);

          // Clarifications endpoint should handle requests properly
          if (clarificationsResponse.status() >= 500) {
            throw new Error(`Clarifications endpoint returned server error: ${clarificationsResponse.status()}`);
          }

        } catch (error) {
          errorTracker.unexpectedErrors.push(`Clarifications API error: ${error}`);
        }

        // Test POST to clarifications (if applicable)
        try {
          const testClarification = {
            field: 'test_field',
            question: 'What is the purpose of this field?',
            flow_id: flowId
          };

          const postResponse = await page.request.post(`${API_URL}/api/v1/unified-discovery/flow/${flowId}/clarifications`, {
            data: testClarification
          });

          const postResult: ApiErrorResult = {
            endpoint: `/api/v1/unified-discovery/flow/${flowId}/clarifications`,
            expectedStatus: 201,
            actualStatus: postResponse.status(),
            method: 'POST',
            hasProperErrorResponse: false,
            isFixed: false
          };

          if (postResponse.status() === 201 || postResponse.status() === 200) {
            postResult.isFixed = true;
            postResult.hasProperErrorResponse = true;
          } else {
            try {
              const errorData = await postResponse.json();
              postResult.hasProperErrorResponse = validateErrorResponse(errorData);
              postResult.errorMessage = errorData.error || errorData.message;
              postResult.isFixed = postResult.hasProperErrorResponse && postResponse.status() !== 404;
            } catch {
              postResult.errorMessage = 'Could not parse POST error response';
            }
          }

          errorTracker.errors.push(postResult);

        } catch (error) {
          // POST clarifications might not be implemented - that's okay
          console.log('POST clarifications test skipped:', error);
        }
      }
    });
  });

  test.afterEach(async ({ page }) => {
    // Log test results
    console.log(`\n=== API Error Handling Results for ${errorTracker.phase} ===`);
    console.log(`Total API calls tested: ${errorTracker.errors.length}`);
    console.log(`Network failures: ${errorTracker.networkFailures.length}`);
    console.log(`Unexpected errors: ${errorTracker.unexpectedErrors.length}`);

    const fixedErrors = errorTracker.errors.filter(e => e.isFixed);
    const unfixedErrors = errorTracker.errors.filter(e => !e.isFixed);

    console.log(`Fixed API issues: ${fixedErrors.length}`);
    console.log(`Remaining API issues: ${unfixedErrors.length}`);

    if (unfixedErrors.length > 0) {
      console.log('\nRemaining Issues:');
      unfixedErrors.forEach(error => {
        console.log(`- ${error.endpoint}: ${error.actualStatus} (expected ${error.expectedStatus})`);
        if (error.errorMessage) {
          console.log(`  Error: ${error.errorMessage}`);
        }
      });
    }

    if (errorTracker.unexpectedErrors.length > 0) {
      console.log('\nUnexpected Errors:');
      errorTracker.unexpectedErrors.forEach(error => {
        console.log(`- ${error}`);
      });
    }

    // Take screenshot on significant issues
    if (unfixedErrors.length > 3 || errorTracker.networkFailures.length > 0) {
      await page.screenshot({
        path: `test-results/api-errors-${errorTracker.phase.toLowerCase().replace(' ', '-')}-${Date.now()}.png`,
        fullPage: true
      });
    }
  });
});