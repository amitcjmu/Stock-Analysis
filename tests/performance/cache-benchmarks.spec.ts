/**
 * Cache Performance Benchmarks Suite
 *
 * Comprehensive performance benchmarking for Redis cache implementation:
 * - Before/after cache implementation comparisons
 * - Bundle size impact measurement
 * - Memory usage optimization validation
 * - Real-world scenario performance testing
 * - Automated benchmark reporting and validation
 *
 * Generated by CC (Claude Code)
 */

import { test, expect, Page, Browser } from '@playwright/test';
import { CacheTestUtils } from '../e2e/cache/utils/cache-test-utils';
import { PerformanceMonitor } from '../e2e/cache/utils/performance-monitor';
import * as fs from 'fs';
import * as path from 'path';

interface BenchmarkResult {
  name: string;
  baselineMetric: number;
  cachedMetric: number;
  improvement: number;
  improvementPercent: number;
  target: number;
  passed: boolean;
  details?: any;
}

interface BenchmarkSuite {
  timestamp: string;
  environment: string;
  results: BenchmarkResult[];
  summary: {
    totalTests: number;
    passed: number;
    failed: number;
    overallSuccess: boolean;
  };
}

test.describe('Cache Performance Benchmarks', () => {
  const benchmarkResults: BenchmarkResult[] = [];
  let baselineMetrics: any = null;

  test.beforeAll(async () => {
    console.log('Starting Cache Performance Benchmarks...');
    console.log('Environment:', {
      url: process.env.TEST_URL || 'http://localhost:3000',
      redisEnabled: process.env.REDIS_ENABLED || 'true',
      benchmarkMode: process.env.BENCHMARK_MODE || 'comprehensive'
    });
  });

  test.afterAll(async () => {
    // Generate and save benchmark report
    const benchmarkSuite: BenchmarkSuite = {
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || 'test',
      results: benchmarkResults,
      summary: {
        totalTests: benchmarkResults.length,
        passed: benchmarkResults.filter(r => r.passed).length,
        failed: benchmarkResults.filter(r => !r.passed).length,
        overallSuccess: benchmarkResults.every(r => r.passed)
      }
    };

    console.log('Cache Performance Benchmark Results:');
    console.log(JSON.stringify(benchmarkSuite, null, 2));

    // Save to file for CI/CD analysis
    const reportPath = path.join(process.cwd(), 'cache-benchmark-results.json');
    fs.writeFileSync(reportPath, JSON.stringify(benchmarkSuite, null, 2));

    // Generate human-readable report
    generateBenchmarkReport(benchmarkSuite);
  });

  test('should establish baseline metrics without caching', async ({ page }) => {
    const monitor = new PerformanceMonitor(page);
    const cacheUtils = new CacheTestUtils(page);

    // Disable all caching for baseline
    await cacheUtils.setFeatureFlags({
      USE_REDIS_CACHE: false,
      USE_BROWSER_CACHE: false,
      DISABLE_ALL_CACHING: true
    });

    await monitor.startMonitoring();

    // Execute standard workflow for baseline
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'benchmark@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    // Standard user journey
    const journeySteps = [
      '/dashboard',
      '/discovery/flows',
      '/discovery/field-mappings',
      '/dashboard'  // Return for comparison
    ];

    for (const step of journeySteps) {
      await page.goto(step);
      await page.waitForLoadState('networkidle');
      await page.waitForTimeout(1000); // Allow APIs to complete
    }

    baselineMetrics = await monitor.getMetrics();
    monitor.stopMonitoring();

    console.log('Baseline Metrics (No Cache):', {
      totalApiCalls: baselineMetrics.totalApiCalls,
      averageResponseTime: `${baselineMetrics.averageResponseTime.toFixed(0)}ms`,
      pageLoadTime: `${baselineMetrics.pageLoadTime.toFixed(0)}ms`,
      networkBytes: baselineMetrics.totalNetworkBytes
    });

    // Verify baseline was captured
    expect(baselineMetrics.totalApiCalls).toBeGreaterThan(0);
    expect(baselineMetrics.averageResponseTime).toBeGreaterThan(0);
  });

  test('should benchmark page load time improvements (target: 50% reduction)', async ({ page }) => {
    if (!baselineMetrics) {
      test.skip('Baseline metrics not available');
      return;
    }

    const monitor = new PerformanceMonitor(page);
    const cacheUtils = new CacheTestUtils(page);

    // Enable full caching
    await cacheUtils.setFeatureFlags({
      USE_REDIS_CACHE: true,
      USE_BROWSER_CACHE: true,
      DISABLE_ALL_CACHING: false
    });

    await page.reload();
    await cacheUtils.clearAllCaches(); // Start fresh
    await monitor.startMonitoring();

    // Login and warm up cache
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'benchmark@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    // First load (populate cache)
    await page.goto('/discovery/field-mappings');
    await page.waitForLoadState('networkidle');

    // Measure cached page load
    const cachedLoadStart = Date.now();
    await page.goto('/discovery/field-mappings');
    await page.waitForLoadState('networkidle');
    const cachedLoadTime = Date.now() - cachedLoadStart;

    const cachedMetrics = await monitor.getMetrics();
    monitor.stopMonitoring();

    // Calculate improvement
    const improvement = baselineMetrics.pageLoadTime - cachedLoadTime;
    const improvementPercent = (improvement / baselineMetrics.pageLoadTime) * 100;
    const target = 50; // 50% improvement target

    const result: BenchmarkResult = {
      name: 'Page Load Time Improvement',
      baselineMetric: baselineMetrics.pageLoadTime,
      cachedMetric: cachedLoadTime,
      improvement,
      improvementPercent,
      target,
      passed: improvementPercent >= target,
      details: {
        baselineMs: baselineMetrics.pageLoadTime,
        cachedMs: cachedLoadTime,
        improvementMs: improvement
      }
    };

    benchmarkResults.push(result);

    console.log('Page Load Benchmark:', {
      baseline: `${result.baselineMetric.toFixed(0)}ms`,
      cached: `${result.cachedMetric.toFixed(0)}ms`,
      improvement: `${result.improvementPercent.toFixed(1)}%`,
      target: `${target}%`,
      passed: result.passed
    });

    expect(result.passed).toBe(true);
  });

  test('should benchmark API call reduction (target: 70% reduction)', async ({ page }) => {
    if (!baselineMetrics) {
      test.skip('Baseline metrics not available');
      return;
    }

    const monitor = new PerformanceMonitor(page);
    const cacheUtils = new CacheTestUtils(page);

    // Enable caching
    await cacheUtils.setFeatureFlags({
      USE_REDIS_CACHE: true,
      USE_BROWSER_CACHE: true
    });

    await page.reload();
    await cacheUtils.clearAllCaches();
    await monitor.startMonitoring();

    // Login
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'benchmark@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    // Execute same journey as baseline
    const journeySteps = [
      '/dashboard',
      '/discovery/flows',
      '/discovery/field-mappings',
      '/dashboard'  // This should hit cache
    ];

    for (const step of journeySteps) {
      await page.goto(step);
      await page.waitForLoadState('networkidle');
      await page.waitForTimeout(1000);
    }

    const cachedMetrics = await monitor.getMetrics();
    monitor.stopMonitoring();

    // Calculate API call reduction
    const apiCallReduction = baselineMetrics.totalApiCalls - cachedMetrics.totalApiCalls;
    const reductionPercent = (apiCallReduction / baselineMetrics.totalApiCalls) * 100;
    const target = 70; // 70% reduction target

    const result: BenchmarkResult = {
      name: 'API Call Reduction',
      baselineMetric: baselineMetrics.totalApiCalls,
      cachedMetric: cachedMetrics.totalApiCalls,
      improvement: apiCallReduction,
      improvementPercent: reductionPercent,
      target,
      passed: reductionPercent >= target,
      details: {
        baselineApiCalls: baselineMetrics.totalApiCalls,
        cachedApiCalls: cachedMetrics.totalApiCalls,
        cacheHitRatio: cachedMetrics.cacheHitRatio * 100
      }
    };

    benchmarkResults.push(result);

    console.log('API Call Reduction Benchmark:', {
      baseline: result.baselineMetric,
      cached: result.cachedMetric,
      reduction: result.improvement,
      reductionPercent: `${result.improvementPercent.toFixed(1)}%`,
      target: `${target}%`,
      passed: result.passed
    });

    expect(result.passed).toBe(true);
  });

  test('should benchmark cache response times (target: sub-50ms)', async ({ page }) => {
    const cacheUtils = new CacheTestUtils(page);

    // Login and enable caching
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'benchmark@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    const endpoints = [
      '/api/v1/cached-context/me',
      '/api/v1/cached-context/clients',
      '/api/v1/cached-context/engagements?client_id=benchmark-client'
    ];

    // Prime cache
    for (const endpoint of endpoints) {
      await page.request.get(endpoint, {
        headers: { 'X-Client-Account-ID': 'benchmark-client' }
      });
    }

    // Measure cached response times
    const responseTimes: number[] = [];
    const measurements = 10; // Multiple measurements for accuracy

    for (let i = 0; i < measurements; i++) {
      for (const endpoint of endpoints) {
        const startTime = Date.now();
        const response = await page.request.get(endpoint, {
          headers: { 'X-Client-Account-ID': 'benchmark-client' }
        });
        const responseTime = Date.now() - startTime;

        expect(response.status()).toBe(200);

        if (response.headers()['x-cache'] === 'HIT') {
          responseTimes.push(responseTime);
        }
      }
    }

    const avgResponseTime = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;
    const maxResponseTime = Math.max(...responseTimes);
    const target = 50; // Sub-50ms target

    const result: BenchmarkResult = {
      name: 'Cache Response Time',
      baselineMetric: 0, // No baseline needed for this test
      cachedMetric: avgResponseTime,
      improvement: 0,
      improvementPercent: 0,
      target,
      passed: avgResponseTime < target,
      details: {
        avgResponseTime,
        maxResponseTime,
        totalMeasurements: responseTimes.length,
        allResponseTimes: responseTimes
      }
    };

    benchmarkResults.push(result);

    console.log('Cache Response Time Benchmark:', {
      average: `${avgResponseTime.toFixed(1)}ms`,
      max: `${maxResponseTime}ms`,
      target: `<${target}ms`,
      measurements: responseTimes.length,
      passed: result.passed
    });

    expect(result.passed).toBe(true);
  });

  test('should benchmark memory usage optimization', async ({ page }) => {
    const monitor = new PerformanceMonitor(page);

    // Login
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'benchmark@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    await monitor.startMonitoring();

    // Get initial memory
    const initialMemory = await page.evaluate(() => {
      if ('memory' in performance) {
        const mem = (performance as any).memory;
        return mem.usedJSHeapSize;
      }
      return 0;
    });

    if (initialMemory === 0) {
      console.log('Memory API not available, skipping memory benchmark');
      return;
    }

    // Perform cache-intensive operations
    const operations = 100;
    for (let i = 0; i < operations; i++) {
      await page.request.get('/api/v1/cached-context/me', {
        headers: { 'X-Client-Account-ID': `memory-test-${i % 10}` }
      });
    }

    // Navigate through pages to trigger cache usage
    const pages = ['/dashboard', '/discovery/flows', '/discovery/field-mappings'];
    for (const pageUrl of pages) {
      await page.goto(pageUrl);
      await page.waitForLoadState('networkidle');
    }

    // Get final memory
    const finalMemory = await page.evaluate(() => {
      if ('memory' in performance) {
        const mem = (performance as any).memory;
        return mem.usedJSHeapSize;
      }
      return 0;
    });

    const memoryIncrease = finalMemory - initialMemory;
    const memoryIncreaseMB = memoryIncrease / 1024 / 1024;
    const target = 50; // Target: less than 50MB increase

    const result: BenchmarkResult = {
      name: 'Memory Usage Optimization',
      baselineMetric: initialMemory,
      cachedMetric: finalMemory,
      improvement: -memoryIncrease, // Negative because increase is bad
      improvementPercent: 0,
      target,
      passed: memoryIncreaseMB < target,
      details: {
        initialMemoryMB: initialMemory / 1024 / 1024,
        finalMemoryMB: finalMemory / 1024 / 1024,
        increaseMB: memoryIncreaseMB,
        operations
      }
    };

    benchmarkResults.push(result);

    console.log('Memory Usage Benchmark:', {
      initial: `${(initialMemory / 1024 / 1024).toFixed(1)}MB`,
      final: `${(finalMemory / 1024 / 1024).toFixed(1)}MB`,
      increase: `${memoryIncreaseMB.toFixed(1)}MB`,
      target: `<${target}MB`,
      passed: result.passed
    });

    monitor.stopMonitoring();

    expect(result.passed).toBe(true);
  });

  test('should benchmark cache hit ratio (target: 80%+)', async ({ page }) => {
    const cacheUtils = new CacheTestUtils(page);

    // Login
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'benchmark@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    await cacheUtils.clearAllCaches();

    // Perform repeated operations to build and test cache
    const endpoints = [
      '/api/v1/cached-context/me',
      '/api/v1/cached-context/clients'
    ];

    const iterations = 20;
    for (let i = 0; i < iterations; i++) {
      for (const endpoint of endpoints) {
        await page.request.get(endpoint, {
          headers: { 'X-Client-Account-ID': 'hit-ratio-test' }
        });
      }

      // Vary the timing to simulate real usage
      await page.waitForTimeout(Math.random() * 100 + 50);
    }

    const metrics = await cacheUtils.getCacheMetrics();
    const target = 80; // 80% hit ratio target
    const hitRatioPercent = metrics.hitRatio * 100;

    const result: BenchmarkResult = {
      name: 'Cache Hit Ratio',
      baselineMetric: 0, // No baseline for this metric
      cachedMetric: hitRatioPercent,
      improvement: 0,
      improvementPercent: hitRatioPercent,
      target,
      passed: hitRatioPercent >= target,
      details: {
        totalRequests: metrics.totalRequests,
        cacheHits: metrics.cacheHits,
        cacheMisses: metrics.cacheMisses,
        etagMatches: metrics.etagMatches
      }
    };

    benchmarkResults.push(result);

    console.log('Cache Hit Ratio Benchmark:', {
      hitRatio: `${hitRatioPercent.toFixed(1)}%`,
      totalRequests: metrics.totalRequests,
      hits: metrics.cacheHits,
      misses: metrics.cacheMisses,
      target: `${target}%`,
      passed: result.passed
    });

    expect(result.passed).toBe(true);
  });

  test('should benchmark network efficiency (304 responses)', async ({ page }) => {
    const cacheUtils = new CacheTestUtils(page);

    // Login
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'benchmark@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    const endpoint = '/api/v1/cached-context/me';
    const headers = { 'X-Client-Account-ID': 'network-efficiency-test' };

    // First request to get ETag
    const initialResponse = await page.request.get(endpoint, { headers });
    expect(initialResponse.status()).toBe(200);
    const etag = initialResponse.headers()['etag'];
    expect(etag).toBeTruthy();

    // Multiple conditional requests
    const conditionalRequests = 10;
    let etag304Count = 0;
    let totalBytes = 0;

    for (let i = 0; i < conditionalRequests; i++) {
      const response = await page.request.get(endpoint, {
        headers: {
          ...headers,
          'If-None-Match': etag!
        }
      });

      if (response.status() === 304) {
        etag304Count++;
      }

      const contentLength = parseInt(response.headers()['content-length'] || '0');
      totalBytes += contentLength;
    }

    const etag304Ratio = etag304Count / conditionalRequests;
    const target = 80; // 80% of requests should be 304
    const etag304Percent = etag304Ratio * 100;

    const result: BenchmarkResult = {
      name: 'Network Efficiency (304 Responses)',
      baselineMetric: 0,
      cachedMetric: etag304Percent,
      improvement: 0,
      improvementPercent: etag304Percent,
      target,
      passed: etag304Percent >= target,
      details: {
        conditionalRequests,
        etag304Count,
        totalBytes,
        avgBytesPerRequest: totalBytes / conditionalRequests
      }
    };

    benchmarkResults.push(result);

    console.log('Network Efficiency Benchmark:', {
      etag304Ratio: `${etag304Percent.toFixed(1)}%`,
      total304s: etag304Count,
      totalRequests: conditionalRequests,
      avgBytes: Math.round(totalBytes / conditionalRequests),
      target: `${target}%`,
      passed: result.passed
    });

    expect(result.passed).toBe(true);
  });
});

/**
 * Generate human-readable benchmark report
 */
function generateBenchmarkReport(suite: BenchmarkSuite): void {
  const reportLines = [
    '# Cache Performance Benchmark Report',
    '',
    `**Generated:** ${suite.timestamp}`,
    `**Environment:** ${suite.environment}`,
    '',
    '## Summary',
    '',
    `- **Total Tests:** ${suite.summary.totalTests}`,
    `- **Passed:** ${suite.summary.passed}`,
    `- **Failed:** ${suite.summary.failed}`,
    `- **Overall Success:** ${suite.summary.overallSuccess ? 'âœ… PASS' : 'âŒ FAIL'}`,
    '',
    '## Detailed Results',
    ''
  ];

  suite.results.forEach(result => {
    const status = result.passed ? 'âœ… PASS' : 'âŒ FAIL';
    reportLines.push(`### ${result.name} ${status}`);
    reportLines.push('');

    if (result.baselineMetric > 0) {
      reportLines.push(`- **Baseline:** ${result.baselineMetric.toFixed(2)}`);
      reportLines.push(`- **With Cache:** ${result.cachedMetric.toFixed(2)}`);
      reportLines.push(`- **Improvement:** ${result.improvementPercent.toFixed(1)}%`);
    } else {
      reportLines.push(`- **Measured:** ${result.cachedMetric.toFixed(2)}`);
    }

    reportLines.push(`- **Target:** ${result.target}${result.name.includes('Time') ? 'ms' : '%'}`);
    reportLines.push('');

    if (result.details) {
      reportLines.push('**Details:**');
      Object.entries(result.details).forEach(([key, value]) => {
        if (typeof value === 'number') {
          reportLines.push(`- ${key}: ${value.toFixed(2)}`);
        } else if (Array.isArray(value)) {
          reportLines.push(`- ${key}: [${value.length} items]`);
        } else {
          reportLines.push(`- ${key}: ${value}`);
        }
      });
      reportLines.push('');
    }
  });

  reportLines.push('## Recommendations');
  reportLines.push('');

  const failedTests = suite.results.filter(r => !r.passed);
  if (failedTests.length === 0) {
    reportLines.push('ðŸŽ‰ All benchmarks passed! Cache implementation meets performance requirements.');
  } else {
    reportLines.push('The following areas need attention:');
    reportLines.push('');
    failedTests.forEach(test => {
      reportLines.push(`- **${test.name}:** Achieved ${test.improvementPercent || test.cachedMetric}${test.name.includes('Time') ? 'ms' : '%'}, target is ${test.target}${test.name.includes('Time') ? 'ms' : '%'}`);
    });
  }

  const reportContent = reportLines.join('\n');
  const reportPath = path.join(process.cwd(), 'cache-benchmark-report.md');
  fs.writeFileSync(reportPath, reportContent);

  console.log('\nðŸ“Š Benchmark report saved to cache-benchmark-report.md');
}
