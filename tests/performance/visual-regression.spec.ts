/**
 * Visual Regression Testing Suite for Cache Implementation
 *
 * Ensures that caching changes do not affect the visual presentation of the UI:
 * - Page layout consistency with caching enabled/disabled
 * - Loading state visual validation
 * - Component rendering verification
 * - Cross-browser visual consistency
 * - Responsive design validation with cache
 *
 * Generated by CC (Claude Code)
 */

import { test, expect, Page } from '@playwright/test';
import { CacheTestUtils } from '../e2e/cache/utils/cache-test-utils';

interface VisualTestConfig {
  name: string;
  url: string;
  waitForSelector?: string;
  hideElements?: string[];
  maskElements?: string[];
  threshold: number;
}

test.describe('Visual Regression Tests for Cache Implementation', () => {
  let cacheUtils: CacheTestUtils;

  const visualTests: VisualTestConfig[] = [
    {
      name: 'dashboard-page',
      url: '/dashboard',
      waitForSelector: '[data-testid="dashboard-content"]',
      hideElements: ['[data-testid="timestamp"]', '[data-testid="cache-status-indicator"]'],
      threshold: 0.1
    },
    {
      name: 'discovery-flows-page',
      url: '/discovery/flows',
      waitForSelector: '[data-testid="flows-list"]',
      hideElements: ['[data-testid="last-updated"]', '[data-testid="flow-timestamps"]'],
      threshold: 0.1
    },
    {
      name: 'field-mappings-page',
      url: '/discovery/field-mappings',
      waitForSelector: '[data-testid="field-mappings-container"]',
      hideElements: ['[data-testid="import-date"]', '[data-testid="progress-indicators"]'],
      threshold: 0.1
    },
    {
      name: 'admin-clients-page',
      url: '/admin/clients',
      waitForSelector: '[data-testid="clients-table"]',
      hideElements: ['[data-testid="created-date"]', '[data-testid="last-activity"]'],
      threshold: 0.1
    },
    {
      name: 'login-page',
      url: '/login',
      waitForSelector: '[data-testid="login-form"]',
      threshold: 0.05
    }
  ];

  test.beforeEach(async ({ page }) => {
    cacheUtils = new CacheTestUtils(page);
  });

  test.afterEach(async () => {
    cacheUtils.cleanup();
  });

  // Test each page with cache disabled vs enabled
  for (const visualTest of visualTests) {
    test(`should maintain visual consistency for ${visualTest.name}`, async ({ page }) => {
      // Login first if not login page
      if (visualTest.url !== '/login') {
        await page.goto('/login');
        await page.fill('[data-testid="email-input"]', 'visual-test@example.com');
        await page.fill('[data-testid="password-input"]', 'demo123');
        await page.click('[data-testid="login-button"]');
        await page.waitForURL('**/dashboard', { timeout: 10000 });
      }

      // Test 1: Without cache
      await cacheUtils.setFeatureFlags({
        USE_REDIS_CACHE: false,
        USE_BROWSER_CACHE: false,
        DISABLE_ALL_CACHING: true
      });

      await page.reload();
      await page.goto(visualTest.url);

      if (visualTest.waitForSelector) {
        await page.waitForSelector(visualTest.waitForSelector, { timeout: 10000 });
      }
      await page.waitForLoadState('networkidle');

      // Hide dynamic elements
      if (visualTest.hideElements) {
        for (const selector of visualTest.hideElements) {
          await page.locator(selector).evaluateAll(elements => {
            elements.forEach(el => {
              (el as HTMLElement).style.visibility = 'hidden';
            });
          }).catch(() => {
            // Element might not exist, that's ok
          });
        }
      }

      // Take screenshot without cache
      const screenshotWithoutCache = await page.screenshot({
        fullPage: true,
        animations: 'disabled'
      });

      // Test 2: With cache enabled
      await cacheUtils.setFeatureFlags({
        USE_REDIS_CACHE: true,
        USE_BROWSER_CACHE: true,
        DISABLE_ALL_CACHING: false
      });

      await page.reload();
      await page.goto(visualTest.url);

      if (visualTest.waitForSelector) {
        await page.waitForSelector(visualTest.waitForSelector, { timeout: 10000 });
      }
      await page.waitForLoadState('networkidle');

      // Hide same dynamic elements
      if (visualTest.hideElements) {
        for (const selector of visualTest.hideElements) {
          await page.locator(selector).evaluateAll(elements => {
            elements.forEach(el => {
              (el as HTMLElement).style.visibility = 'hidden';
            });
          }).catch(() => {
            // Element might not exist, that's ok
          });
        }
      }

      // Take screenshot with cache
      const screenshotWithCache = await page.screenshot({
        fullPage: true,
        animations: 'disabled'
      });

      // Compare screenshots - they should be identical
      expect.soft(screenshotWithCache).toMatchSnapshot(
        `${visualTest.name}-with-cache.png`,
        {
          threshold: visualTest.threshold,
          // Allow for small differences in timing-dependent elements
          maxDiffPixels: 100
        }
      );

      // Also verify against baseline if it exists
      expect.soft(screenshotWithoutCache).toMatchSnapshot(
        `${visualTest.name}-without-cache.png`,
        { threshold: visualTest.threshold }
      );
    });
  }

  test('should show loading states consistently with cache', async ({ page }) => {
    // Login
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'visual-test@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    // Test loading states with cache enabled
    await cacheUtils.setFeatureFlags({
      USE_REDIS_CACHE: true,
      USE_BROWSER_CACHE: true
    });

    // Clear cache to ensure we see loading states
    await cacheUtils.clearAllCaches();

    // Navigate to a data-heavy page
    await page.goto('/discovery/field-mappings');

    // Try to capture loading state (may be too fast with cache)
    try {
      await page.waitForSelector('[data-testid="loading-indicator"]', { timeout: 1000 });

      const loadingScreenshot = await page.screenshot({
        animations: 'disabled'
      });

      expect.soft(loadingScreenshot).toMatchSnapshot('loading-state-with-cache.png', {
        threshold: 0.2 // Loading states may vary slightly
      });
    } catch {
      console.log('Loading state too fast to capture (this is expected with effective caching)');
    }

    // Verify final loaded state
    await page.waitForSelector('[data-testid="field-mappings-container"]', { timeout: 10000 });
    await page.waitForLoadState('networkidle');

    const loadedScreenshot = await page.screenshot({
      fullPage: true,
      animations: 'disabled'
    });

    expect.soft(loadedScreenshot).toMatchSnapshot('field-mappings-loaded-with-cache.png', {
      threshold: 0.1
    });
  });

  test('should maintain responsive design with cache', async ({ page }) => {
    const viewports = [
      { name: 'mobile', width: 375, height: 667 },
      { name: 'tablet', width: 768, height: 1024 },
      { name: 'desktop', width: 1920, height: 1080 }
    ];

    // Login
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'visual-test@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    // Enable cache
    await cacheUtils.setFeatureFlags({
      USE_REDIS_CACHE: true,
      USE_BROWSER_CACHE: true
    });

    for (const viewport of viewports) {
      await page.setViewportSize({ width: viewport.width, height: viewport.height });

      // Test dashboard responsiveness
      await page.goto('/dashboard');
      await page.waitForSelector('[data-testid="dashboard-content"]', { timeout: 10000 });
      await page.waitForLoadState('networkidle');

      // Hide dynamic elements
      await page.locator('[data-testid="timestamp"]').evaluateAll(elements => {
        elements.forEach(el => {
          (el as HTMLElement).style.visibility = 'hidden';
        });
      }).catch(() => {});

      const responsiveScreenshot = await page.screenshot({
        fullPage: true,
        animations: 'disabled'
      });

      expect.soft(responsiveScreenshot).toMatchSnapshot(
        `dashboard-${viewport.name}-with-cache.png`,
        { threshold: 0.1 }
      );
    }
  });

  test('should render cache status indicators correctly', async ({ page }) => {
    // Login
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'visual-test@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    // Test with cache enabled - should show cache indicators
    await cacheUtils.setFeatureFlags({
      USE_REDIS_CACHE: true,
      USE_BROWSER_CACHE: true,
      SHOW_CACHE_STATUS: true // Dev feature flag
    });

    await page.reload();
    await page.goto('/dashboard');
    await page.waitForSelector('[data-testid="dashboard-content"]', { timeout: 10000 });

    // Look for cache status indicators
    const cacheStatusExists = await page.locator('[data-testid="cache-status-indicator"]').isVisible();

    if (cacheStatusExists) {
      const cacheIndicatorScreenshot = await page.screenshot();

      expect.soft(cacheIndicatorScreenshot).toMatchSnapshot('cache-status-indicators.png', {
        threshold: 0.1
      });
    }

    // Test with cache disabled - should not show cache indicators
    await cacheUtils.setFeatureFlags({
      USE_REDIS_CACHE: false,
      USE_BROWSER_CACHE: false,
      SHOW_CACHE_STATUS: false
    });

    await page.reload();
    await page.goto('/dashboard');
    await page.waitForSelector('[data-testid="dashboard-content"]', { timeout: 10000 });

    const noCacheIndicatorScreenshot = await page.screenshot();

    expect.soft(noCacheIndicatorScreenshot).toMatchSnapshot('no-cache-indicators.png', {
      threshold: 0.1
    });
  });

  test('should handle error states visually with cache', async ({ page }) => {
    // Login
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'visual-test@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    // Simulate Redis failure
    await page.route('**/health/redis', route =>
      route.fulfill({
        status: 503,
        body: JSON.stringify({ status: 'unhealthy', message: 'Redis connection failed' })
      })
    );

    // Navigate to a page that would use cache
    await page.goto('/discovery/flows');
    await page.waitForLoadState('networkidle');

    // Look for error boundary or degraded mode indicators
    const errorBoundaryExists = await page.locator('[data-testid="error-boundary"]').isVisible();
    const degradedModeExists = await page.locator('[data-testid="degraded-mode"]').isVisible();

    if (errorBoundaryExists || degradedModeExists) {
      const errorStateScreenshot = await page.screenshot({
        fullPage: true,
        animations: 'disabled'
      });

      expect.soft(errorStateScreenshot).toMatchSnapshot('cache-error-state.png', {
        threshold: 0.2 // Error states may have more variation
      });
    }

    // Verify the page still functions
    const pageContent = await page.locator('[data-testid="flows-list"], [data-testid="error-message"]').isVisible();
    expect(pageContent).toBe(true);
  });

  test('should maintain visual consistency across different browsers', async ({ page, browserName }) => {
    // This test will run across different browsers configured in playwright.config.ts

    // Login
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'visual-test@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    // Enable cache
    await cacheUtils.setFeatureFlags({
      USE_REDIS_CACHE: true,
      USE_BROWSER_CACHE: true
    });

    // Test key pages in each browser
    const testPages = ['/dashboard', '/discovery/flows'];

    for (const testPage of testPages) {
      await page.goto(testPage);
      await page.waitForLoadState('networkidle');

      // Hide dynamic elements
      await page.locator('[data-testid="timestamp"], [data-testid="last-updated"]').evaluateAll(elements => {
        elements.forEach(el => {
          (el as HTMLElement).style.visibility = 'hidden';
        });
      }).catch(() => {});

      const crossBrowserScreenshot = await page.screenshot({
        fullPage: true,
        animations: 'disabled'
      });

      const pageName = testPage.replace('/', '').replace('/', '-') || 'root';
      expect.soft(crossBrowserScreenshot).toMatchSnapshot(
        `${pageName}-${browserName}-with-cache.png`,
        { threshold: 0.2 } // Allow for browser differences
      );
    }
  });

  test('should validate component performance visual indicators', async ({ page }) => {
    // Login
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'visual-test@example.com');
    await page.fill('[data-testid="password-input"]', 'demo123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard', { timeout: 10000 });

    // Enable performance indicators if available
    await cacheUtils.setFeatureFlags({
      USE_REDIS_CACHE: true,
      USE_BROWSER_CACHE: true,
      SHOW_PERFORMANCE_METRICS: true
    });

    await page.reload();
    await page.goto('/discovery/field-mappings');
    await page.waitForLoadState('networkidle');

    // Look for performance indicators (if implemented)
    const perfIndicators = await page.locator('[data-testid="performance-indicator"], [data-testid="cache-metrics"]').count();

    if (perfIndicators > 0) {
      const perfScreenshot = await page.screenshot();

      expect.soft(perfScreenshot).toMatchSnapshot('performance-indicators.png', {
        threshold: 0.1
      });
    }

    // Test without performance indicators
    await cacheUtils.setFeatureFlags({
      SHOW_PERFORMANCE_METRICS: false
    });

    await page.reload();
    await page.goto('/discovery/field-mappings');
    await page.waitForLoadState('networkidle');

    const noPerfScreenshot = await page.screenshot();

    expect.soft(noPerfScreenshot).toMatchSnapshot('no-performance-indicators.png', {
      threshold: 0.1
    });
  });
});

// Configure Playwright for visual testing
test.use({
  // Ensure consistent font rendering
  launchOptions: {
    args: [
      '--font-render-hinting=none',
      '--disable-font-subpixel-positioning',
      '--disable-gpu-sandbox'
    ]
  }
});
