"""
Discovery Flow Integration Tests

This module provides comprehensive integration tests for the Discovery Flow fixes:
- Complete discovery flow execution from start to finish
- API endpoint availability and responses  
- Database persistence and retrieval
- Error handling across the stack
- Flow transition scenarios
- Data integrity validation throughout the flow

Generated by CC for ADCS Backend Testing Framework
"""

import asyncio
import uuid
from datetime import datetime, timedelta
from typing import Any, Dict, List
from unittest.mock import AsyncMock, Mock, patch

import pytest
from fastapi.testclient import TestClient
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.context import RequestContext
from app.models.discovery_flow import DiscoveryFlow
from app.services.master_flow_orchestrator import MasterFlowOrchestrator


class TestDiscoveryFlowEndToEnd:
    """Test complete discovery flow execution from initialization to completion"""

    @pytest.fixture
    def client(self):
        """Create test client"""
        from main import app
        return TestClient(app)

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.fixture
    def auth_headers(self, mock_context):
        """Create authentication headers"""
        return {
            "Authorization": "Bearer test_token",
            "Content-Type": "application/json",
            "X-Client-Account-ID": str(mock_context.client_account_id),
            "X-Engagement-ID": str(mock_context.engagement_id),
            "X-User-ID": mock_context.user_id,
        }

    @pytest.fixture
    def sample_discovery_data(self):
        """Create sample discovery data for testing"""
        return {
            "flow_id": str(uuid.uuid4()),
            "engagement_id": str(uuid.uuid4()),
            "client_account_id": str(uuid.uuid4()),
            "data_source": "cmdb_import",
            "raw_data": [
                {
                    "hostname": "web-server-01",
                    "ip_address": "192.168.1.10",
                    "os_type": "Linux",
                    "application": "Web Application",
                    "environment": "Production",
                    "business_criticality": "High"
                },
                {
                    "hostname": "db-server-01", 
                    "ip_address": "192.168.1.20",
                    "os_type": "Windows",
                    "application": "Database Server",
                    "environment": "Production",
                    "business_criticality": "Critical"
                },
                {
                    "hostname": "app-server-01",
                    "ip_address": "192.168.1.30", 
                    "os_type": "Linux",
                    "application": "Application Server",
                    "environment": "Staging",
                    "business_criticality": "Medium"
                }
            ],
            "configuration": {
                "enable_field_mapping": True,
                "enable_data_cleansing": True,
                "enable_dependency_analysis": True,
                "parallel_execution": False,
                "confidence_threshold": 0.8
            }
        }

    @pytest.mark.asyncio
    async def test_complete_discovery_flow_execution(self, client, auth_headers, sample_discovery_data):
        """Test complete discovery flow from initialization to completion"""
        with patch('app.core.auth.get_current_context') as mock_get_context:
            mock_get_context.return_value = RequestContext(
                client_account_id=uuid.UUID(sample_discovery_data["client_account_id"]),
                engagement_id=uuid.UUID(sample_discovery_data["engagement_id"]),
                user_id=str(uuid.uuid4()),
            )
            
            # Step 1: Initialize discovery flow
            init_response = client.post(
                "/api/v1/discovery/flow/initialize",
                headers=auth_headers,
                json=sample_discovery_data
            )
            
            if init_response.status_code == 200:
                flow_id = init_response.json()["flow_id"]
                
                # Step 2: Check initial status
                status_response = client.get(
                    f"/api/v1/discovery/flows/{flow_id}/status",
                    headers=auth_headers
                )
                
                if status_response.status_code == 200:
                    status_data = status_response.json()
                    assert status_data["flow_id"] == flow_id
                    assert status_data["type"] == "discovery"
                    assert "current_phase" in status_data
                    assert "progress_percentage" in status_data
                
                # Step 3: Execute flow phases
                execute_response = client.post(
                    f"/api/v1/discovery/flow/{flow_id}/execute",
                    headers=auth_headers,
                    json={"phases": ["field_mapping", "data_cleansing"]}
                )
                
                # Should handle execution request gracefully
                assert execute_response.status_code in [200, 202, 404]
                
                # Step 4: Get final results
                results_response = client.get(
                    f"/api/v1/discovery/flow/{flow_id}/results",
                    headers=auth_headers
                )
                
                # Should handle results request gracefully
                assert results_response.status_code in [200, 404]

    @pytest.mark.asyncio
    async def test_discovery_flow_phase_transitions(self, client, auth_headers, sample_discovery_data):
        """Test discovery flow phase transitions"""
        with patch('app.core.auth.get_current_context') as mock_get_context:
            mock_get_context.return_value = RequestContext(
                client_account_id=uuid.UUID(sample_discovery_data["client_account_id"]),
                engagement_id=uuid.UUID(sample_discovery_data["engagement_id"]),
                user_id=str(uuid.uuid4()),
            )
            
            # Initialize flow
            init_response = client.post(
                "/api/v1/discovery/flow/initialize",
                headers=auth_headers,
                json=sample_discovery_data
            )
            
            if init_response.status_code == 200:
                flow_id = init_response.json()["flow_id"]
                
                # Test phase transitions
                phases = [
                    "field_mapping",
                    "data_cleansing", 
                    "asset_inventory",
                    "dependency_analysis",
                    "tech_debt_assessment"
                ]
                
                for phase in phases:
                    phase_response = client.post(
                        f"/api/v1/discovery/flow/{flow_id}/phase/{phase}",
                        headers=auth_headers,
                        json={"action": "start"}
                    )
                    
                    # Should handle phase transitions gracefully
                    assert phase_response.status_code in [200, 202, 404, 405]

    @pytest.mark.asyncio
    async def test_discovery_flow_data_persistence(self, client, auth_headers, sample_discovery_data):
        """Test that discovery flow data is properly persisted"""
        with patch('app.core.auth.get_current_context') as mock_get_context:
            mock_get_context.return_value = RequestContext(
                client_account_id=uuid.UUID(sample_discovery_data["client_account_id"]),
                engagement_id=uuid.UUID(sample_discovery_data["engagement_id"]),
                user_id=str(uuid.uuid4()),
            )
            
            # Initialize flow
            init_response = client.post(
                "/api/v1/discovery/flow/initialize",
                headers=auth_headers,
                json=sample_discovery_data
            )
            
            if init_response.status_code == 200:
                flow_id = init_response.json()["flow_id"]
                
                # Get flow status multiple times to verify persistence
                for i in range(3):
                    status_response = client.get(
                        f"/api/v1/discovery/flows/{flow_id}/status",
                        headers=auth_headers
                    )
                    
                    if status_response.status_code == 200:
                        status_data = status_response.json()
                        assert status_data["flow_id"] == flow_id
                        # Data should be consistent across calls
                        assert "current_phase" in status_data
                        assert "progress_percentage" in status_data
                    
                    # Small delay between calls
                    await asyncio.sleep(0.1)


class TestDiscoveryFlowAPIIntegration:
    """Test discovery flow API endpoint integration"""

    @pytest.fixture
    def client(self):
        """Create test client"""
        from main import app
        return TestClient(app)

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.fixture
    def auth_headers(self, mock_context):
        """Create authentication headers"""
        return {
            "Authorization": "Bearer test_token",
            "Content-Type": "application/json",
            "X-Client-Account-ID": str(mock_context.client_account_id),
        }

    def test_get_active_flows_endpoint_integration(self, client, auth_headers):
        """Test get active flows endpoint integration"""
        with patch('app.core.auth.get_current_context') as mock_get_context:
            mock_get_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            response = client.get(
                "/api/v1/discovery/flows/active",
                headers=auth_headers
            )
            
            # Should handle request gracefully
            assert response.status_code in [200, 403, 500]
            
            if response.status_code == 200:
                flows = response.json()
                assert isinstance(flows, list)
                
                # Verify each flow has required fields
                for flow in flows:
                    assert "flow_id" in flow
                    assert "status" in flow
                    assert "type" in flow
                    assert flow["type"] == "discovery"

    def test_get_flow_status_endpoint_integration(self, client, auth_headers):
        """Test get flow status endpoint integration"""
        flow_id = str(uuid.uuid4())
        
        with patch('app.core.auth.get_current_context') as mock_get_context:
            mock_get_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            response = client.get(
                f"/api/v1/discovery/flows/{flow_id}/status",
                headers=auth_headers
            )
            
            # Should handle non-existent flow gracefully
            assert response.status_code in [200, 404, 500]
            
            if response.status_code == 404:
                error_data = response.json()
                assert "not found" in error_data["detail"].lower()

    def test_get_agent_insights_endpoint_integration(self, client, auth_headers):
        """Test get agent insights endpoint integration"""
        flow_id = str(uuid.uuid4())
        
        with patch('app.core.auth.get_current_context') as mock_get_context:
            mock_get_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            response = client.get(
                f"/api/v1/discovery/flow/{flow_id}/agent-insights",
                headers=auth_headers
            )
            
            # Should handle request gracefully
            assert response.status_code in [200, 404, 500]
            
            if response.status_code == 200:
                insights = response.json()
                assert isinstance(insights, list)

    def test_api_endpoints_with_invalid_flow_ids(self, client, auth_headers):
        """Test API endpoints with various invalid flow ID formats"""
        invalid_flow_ids = [
            "not-a-uuid",
            "12345",
            "",
            "null",
            "undefined"
        ]
        
        with patch('app.core.auth.get_current_context') as mock_get_context:
            mock_get_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            for invalid_id in invalid_flow_ids:
                # Test status endpoint
                status_response = client.get(
                    f"/api/v1/discovery/flows/{invalid_id}/status",
                    headers=auth_headers
                )
                assert status_response.status_code in [400, 404, 422, 500]
                
                # Test agent insights endpoint
                insights_response = client.get(
                    f"/api/v1/discovery/flow/{invalid_id}/agent-insights",
                    headers=auth_headers
                )
                assert insights_response.status_code in [400, 404, 422, 500]


class TestDiscoveryFlowDatabaseIntegration:
    """Test discovery flow database integration"""

    @pytest.fixture
    async def test_session(self):
        """Create test database session"""
        from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
        from sqlalchemy.orm import sessionmaker
        from app.models.base import Base
        
        engine = create_async_engine(
            "sqlite+aiosqlite:///:memory:",
            echo=False,
            future=True
        )
        
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
        
        session_factory = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
        
        async with session_factory() as session:
            yield session
            await session.rollback()
        
        await engine.dispose()

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.mark.asyncio
    async def test_flow_creation_with_valid_data(self, test_session, mock_context):
        """Test flow creation with valid data persists correctly"""
        from app.repositories.discovery_flow_repository.commands.flow_commands import FlowCommands
        
        flow_commands = FlowCommands(
            test_session,
            mock_context.client_account_id,
            mock_context.engagement_id
        )
        
        flow_data = {
            "flow_id": str(uuid.uuid4()),
            "description": "Test Discovery Flow",
            "user_id": mock_context.user_id,
            "initial_state_data": {
                "status": "initialized",
                "current_phase": "initialization",
                "progress_percentage": 0.0
            },
            "raw_data": [
                {"hostname": "test-server", "ip": "192.168.1.1"}
            ]
        }
        
        flow = await flow_commands.create_discovery_flow(**flow_data)
        
        # Verify flow was created correctly
        assert flow is not None
        assert str(flow.flow_id) == flow_data["flow_id"]
        assert flow.client_account_id == mock_context.client_account_id
        assert flow.engagement_id == mock_context.engagement_id
        assert flow.status == "initialized"
        assert flow.current_phase == "initialization"
        assert flow.progress_percentage == 0.0

    @pytest.mark.asyncio
    async def test_flow_retrieval_excludes_null_flow_ids(self, test_session, mock_context):
        """Test that flow retrieval excludes flows with null flow_ids"""
        from app.repositories.discovery_flow_repository.queries.flow_queries import FlowQueries
        
        # Create flow with null flow_id directly in database (bypassing validation)
        invalid_flow = DiscoveryFlow(
            id=uuid.uuid4(),
            flow_id=None,  # This should be filtered out
            client_account_id=mock_context.client_account_id,
            engagement_id=mock_context.engagement_id,
            status="active",
            current_phase="field_mapping"
        )
        test_session.add(invalid_flow)
        
        # Create valid flow
        valid_flow = DiscoveryFlow(
            id=uuid.uuid4(),
            flow_id=uuid.uuid4(),
            client_account_id=mock_context.client_account_id,
            engagement_id=mock_context.engagement_id,
            status="active",
            current_phase="field_mapping"
        )
        test_session.add(valid_flow)
        
        await test_session.commit()
        
        # Query flows
        flow_queries = FlowQueries(
            test_session,
            mock_context.client_account_id,
            mock_context.engagement_id
        )
        
        active_flows = await flow_queries.get_active_flows()
        
        # Should only return the valid flow
        assert len(active_flows) == 1
        assert active_flows[0].flow_id is not None
        assert active_flows[0].flow_id == valid_flow.flow_id

    @pytest.mark.asyncio
    async def test_flow_update_operations_maintain_integrity(self, test_session, mock_context):
        """Test that flow update operations maintain data integrity"""
        from app.repositories.discovery_flow_repository.commands.flow_commands import FlowCommands
        
        flow_commands = FlowCommands(
            test_session,
            mock_context.client_account_id,
            mock_context.engagement_id
        )
        
        # Create initial flow
        flow_id = str(uuid.uuid4())
        flow = await flow_commands.create_discovery_flow(
            flow_id=flow_id,
            description="Test Flow"
        )
        
        # Test phase completion update
        updated_flow = await flow_commands.update_phase_completion(
            flow_id=flow_id,
            phase="field_mapping",
            completed=True,
            data={"mappings_created": 5}
        )
        
        assert updated_flow is not None
        assert updated_flow.field_mapping_completed is True
        assert updated_flow.current_phase == "field_mapping"
        
        # Test status update
        updated_flow = await flow_commands.update_flow_status(
            flow_id=flow_id,
            status="processing",
            progress_percentage=25.0
        )
        
        assert updated_flow is not None
        assert updated_flow.status == "processing"
        assert updated_flow.progress_percentage == 25.0


class TestDiscoveryFlowErrorHandling:
    """Test discovery flow error handling and recovery"""

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.fixture
    def mock_db_session(self):
        """Create mock database session"""
        return AsyncMock(spec=AsyncSession)

    @pytest.mark.asyncio
    async def test_orchestrator_handles_invalid_flow_ids(self, mock_db_session, mock_context):
        """Test that orchestrator handles invalid flow IDs gracefully"""
        orchestrator = MasterFlowOrchestrator(mock_db_session, mock_context)
        
        # Test with invalid flow ID
        result = await orchestrator.get_flow_status("invalid-uuid")
        
        # Should return None or handle gracefully
        assert result is None or "error" in result

    @pytest.mark.asyncio
    async def test_orchestrator_handles_missing_flows(self, mock_db_session, mock_context):
        """Test that orchestrator handles missing flows gracefully"""
        orchestrator = MasterFlowOrchestrator(mock_db_session, mock_context)
        
        # Mock database to return no results
        mock_result = Mock()
        mock_result.scalar_one_or_none.return_value = None
        mock_db_session.execute.return_value = mock_result
        
        # Test with valid but non-existent flow ID
        result = await orchestrator.get_flow_status(str(uuid.uuid4()))
        
        # Should return None for missing flows
        assert result is None

    @pytest.mark.asyncio
    async def test_flow_recovery_after_failure(self, mock_db_session, mock_context):
        """Test flow recovery mechanisms after failures"""
        from app.repositories.discovery_flow_repository.commands.flow_commands import FlowCommands
        
        flow_commands = FlowCommands(
            mock_db_session,
            mock_context.client_account_id,
            mock_context.engagement_id
        )
        
        # Test cleanup of stuck flows
        cleanup_count = await flow_commands.cleanup_stuck_flows(hours_threshold=1)
        
        # Should handle cleanup gracefully (returns 0 if no stuck flows)
        assert isinstance(cleanup_count, int)
        assert cleanup_count >= 0

    @pytest.mark.asyncio
    async def test_concurrent_flow_operations(self, mock_db_session, mock_context):
        """Test handling of concurrent flow operations"""
        from app.repositories.discovery_flow_repository.commands.flow_commands import FlowCommands
        
        flow_commands = FlowCommands(
            mock_db_session,
            mock_context.client_account_id,
            mock_context.engagement_id
        )
        
        # Mock database operations
        flow_commands.db.add = Mock()
        flow_commands.db.commit = AsyncMock()
        flow_commands.db.refresh = AsyncMock()
        
        # Create multiple flows concurrently
        tasks = []
        for i in range(5):
            task = flow_commands.create_discovery_flow(
                flow_id=str(uuid.uuid4()),
                description=f"Concurrent Flow {i}"
            )
            tasks.append(task)
        
        # Execute concurrently
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # All should succeed or fail gracefully
        for result in results:
            assert isinstance(result, (DiscoveryFlow, Exception))
            if isinstance(result, Exception):
                # Exceptions should be handled gracefully
                assert "flow_id" not in str(result) or "Invalid UUID" in str(result)


class TestDiscoveryFlowPerformance:
    """Test discovery flow performance characteristics"""

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.fixture
    def client(self):
        """Create test client"""
        from main import app
        return TestClient(app)

    @pytest.fixture
    def auth_headers(self, mock_context):
        """Create authentication headers"""
        return {
            "Authorization": "Bearer test_token",
            "Content-Type": "application/json",
            "X-Client-Account-ID": str(mock_context.client_account_id),
        }

    def test_get_active_flows_performance(self, client, auth_headers):
        """Test get active flows endpoint performance"""
        with patch('app.core.auth.get_current_context') as mock_get_context:
            mock_get_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            start_time = datetime.utcnow()
            response = client.get(
                "/api/v1/discovery/flows/active",
                headers=auth_headers
            )
            end_time = datetime.utcnow()
            
            execution_time = (end_time - start_time).total_seconds()
            
            # Should complete within reasonable time
            assert execution_time < 5.0
            assert response.status_code in [200, 403, 500]

    def test_flow_status_query_performance(self, client, auth_headers):
        """Test flow status query performance"""
        flow_id = str(uuid.uuid4())
        
        with patch('app.core.auth.get_current_context') as mock_get_context:
            mock_get_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            start_time = datetime.utcnow()
            response = client.get(
                f"/api/v1/discovery/flows/{flow_id}/status",
                headers=auth_headers
            )
            end_time = datetime.utcnow()
            
            execution_time = (end_time - start_time).total_seconds()
            
            # Should complete within reasonable time
            assert execution_time < 3.0
            assert response.status_code in [200, 404, 500]

    @pytest.mark.asyncio
    async def test_bulk_flow_operations_performance(self, mock_context):
        """Test performance with bulk flow operations"""
        from app.repositories.discovery_flow_repository.commands.flow_commands import FlowCommands
        
        mock_db = AsyncMock()
        mock_db.add = Mock()
        mock_db.commit = AsyncMock()
        mock_db.refresh = AsyncMock()
        
        flow_commands = FlowCommands(
            mock_db,
            mock_context.client_account_id,
            mock_context.engagement_id
        )
        
        # Test creating multiple flows
        start_time = datetime.utcnow()
        
        tasks = []
        for i in range(10):
            task = flow_commands.create_discovery_flow(
                flow_id=str(uuid.uuid4()),
                description=f"Bulk Flow {i}"
            )
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        end_time = datetime.utcnow()
        execution_time = (end_time - start_time).total_seconds()
        
        # Should complete bulk operations within reasonable time
        assert execution_time < 10.0
        assert len(results) == 10


if __name__ == "__main__":
    pytest.main([__file__, "-v"])