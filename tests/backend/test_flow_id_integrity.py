"""
Flow ID Data Integrity Tests

This module tests the fixes implemented to prevent flow ID data integrity issues:
- Flow creation validation to prevent null/undefined flow_id values
- Database-level filtering for flows with valid IDs
- Response mapper validation logic
- Flow state persistence integrity

Generated by CC for ADCS Backend Testing Framework
"""

import asyncio
import uuid
from datetime import datetime
from typing import Any, Dict
from unittest.mock import AsyncMock, Mock, patch

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.context import RequestContext
from app.models.discovery_flow import DiscoveryFlow
from app.repositories.discovery_flow_repository.commands.flow_commands import FlowCommands
from app.repositories.discovery_flow_repository.queries.flow_queries import FlowQueries
from app.api.v1.endpoints.discovery_flows.response_mappers import ResponseMappers


class TestFlowIdIntegrityValidation:
    """Test flow ID validation and data integrity fixes"""

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.fixture
    def mock_db_session(self):
        """Create mock database session"""
        session = AsyncMock(spec=AsyncSession)
        session.add = Mock()
        session.commit = AsyncMock()
        session.refresh = AsyncMock()
        session.execute = AsyncMock()
        session.rollback = AsyncMock()
        return session

    @pytest.fixture
    def flow_commands(self, mock_db_session, mock_context):
        """Create FlowCommands instance"""
        return FlowCommands(
            mock_db_session,
            mock_context.client_account_id,
            mock_context.engagement_id
        )

    @pytest.fixture
    def flow_queries(self, mock_db_session, mock_context):
        """Create FlowQueries instance"""
        return FlowQueries(
            mock_db_session,
            mock_context.client_account_id,
            mock_context.engagement_id
        )

    @pytest.fixture
    def valid_flow_data(self):
        """Create valid flow creation data"""
        return {
            "flow_id": str(uuid.uuid4()),
            "master_flow_id": str(uuid.uuid4()),
            "flow_type": "primary",
            "description": "Test Discovery Flow",
            "user_id": str(uuid.uuid4()),
            "initial_state_data": {"status": "initialized", "progress": 0.0},
            "raw_data": [
                {"hostname": "test-server-1", "ip": "192.168.1.1"},
                {"hostname": "test-server-2", "ip": "192.168.1.2"}
            ],
            "metadata": {"test": True}
        }

    @pytest.mark.asyncio
    async def test_create_flow_with_null_flow_id_raises_error(self, flow_commands):
        """Test that creating a flow with null flow_id raises ValueError"""
        with pytest.raises(ValueError, match="flow_id cannot be null or empty"):
            await flow_commands.create_discovery_flow(
                flow_id=None,
                description="Test Flow"
            )

    @pytest.mark.asyncio
    async def test_create_flow_with_empty_flow_id_raises_error(self, flow_commands):
        """Test that creating a flow with empty flow_id raises ValueError"""
        with pytest.raises(ValueError, match="flow_id cannot be null or empty"):
            await flow_commands.create_discovery_flow(
                flow_id="",
                description="Test Flow"
            )

    @pytest.mark.asyncio
    async def test_create_flow_with_whitespace_flow_id_raises_error(self, flow_commands):
        """Test that creating a flow with whitespace-only flow_id raises ValueError"""
        with pytest.raises(ValueError, match="flow_id cannot be null or empty"):
            await flow_commands.create_discovery_flow(
                flow_id="   ",
                description="Test Flow"
            )

    @pytest.mark.asyncio
    async def test_create_flow_with_invalid_uuid_raises_error(self, flow_commands):
        """Test that creating a flow with invalid UUID raises ValueError"""
        with pytest.raises(ValueError, match="Invalid UUID"):
            await flow_commands.create_discovery_flow(
                flow_id="invalid-uuid-format",
                description="Test Flow"
            )

    @pytest.mark.asyncio
    async def test_create_flow_with_valid_flow_id_succeeds(self, flow_commands, valid_flow_data):
        """Test that creating a flow with valid flow_id succeeds"""
        # Mock database interactions
        flow_commands.db.add = Mock()
        flow_commands.db.commit = AsyncMock()
        flow_commands.db.refresh = AsyncMock()

        result = await flow_commands.create_discovery_flow(**valid_flow_data)

        assert isinstance(result, DiscoveryFlow)
        assert str(result.flow_id) == valid_flow_data["flow_id"]
        assert result.status == "initialized"
        assert result.current_phase == "initialization"
        flow_commands.db.add.assert_called_once()
        flow_commands.db.commit.assert_called_once()

    @pytest.mark.asyncio
    async def test_ensure_uuid_with_valid_string_uuid(self, flow_commands):
        """Test _ensure_uuid with valid string UUID"""
        test_uuid = str(uuid.uuid4())
        result = flow_commands._ensure_uuid(test_uuid)
        assert isinstance(result, uuid.UUID)
        assert str(result) == test_uuid

    @pytest.mark.asyncio
    async def test_ensure_uuid_with_uuid_object(self, flow_commands):
        """Test _ensure_uuid with UUID object"""
        test_uuid = uuid.uuid4()
        result = flow_commands._ensure_uuid(test_uuid)
        assert isinstance(result, uuid.UUID)
        assert result == test_uuid

    @pytest.mark.asyncio
    async def test_ensure_uuid_with_invalid_input_raises_error(self, flow_commands):
        """Test _ensure_uuid with invalid input raises ValueError"""
        with pytest.raises(ValueError, match="Invalid UUID"):
            flow_commands._ensure_uuid("not-a-uuid")

        with pytest.raises(ValueError, match="Invalid UUID"):
            flow_commands._ensure_uuid(123)

        with pytest.raises(ValueError, match="Invalid UUID"):
            flow_commands._ensure_uuid(None)


class TestResponseMapperFlowIdValidation:
    """Test response mapper flow ID validation fixes"""

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.fixture
    def mock_flow_with_valid_id(self):
        """Create mock flow with valid flow_id"""
        flow = Mock(spec=DiscoveryFlow)
        flow.flow_id = uuid.uuid4()
        flow.id = uuid.uuid4()
        flow.flow_name = "Test Flow"
        flow.status = "active"
        flow.current_phase = "field_mapping"
        flow.progress_percentage = 25.0
        flow.client_account_id = uuid.uuid4()
        flow.engagement_id = uuid.uuid4()
        flow.created_at = datetime.utcnow()
        flow.updated_at = datetime.utcnow()
        flow.data_import_id = uuid.uuid4()
        flow.crewai_state_data = {"test": "data"}
        flow.flow_state = {"metadata": "test"}
        
        # Set phase completion flags
        flow.data_import_completed = True
        flow.field_mapping_completed = False
        flow.data_cleansing_completed = False
        flow.asset_inventory_completed = False
        flow.dependency_analysis_completed = False
        flow.tech_debt_assessment_completed = False
        
        return flow

    @pytest.fixture
    def mock_flow_with_null_id(self):
        """Create mock flow with null flow_id"""
        flow = Mock(spec=DiscoveryFlow)
        flow.flow_id = None
        flow.id = uuid.uuid4()
        flow.flow_name = "Test Flow"
        flow.status = "active"
        flow.client_account_id = uuid.uuid4()
        return flow

    @pytest.fixture
    def mock_flow_with_empty_id(self):
        """Create mock flow with empty flow_id"""
        flow = Mock(spec=DiscoveryFlow)
        flow.flow_id = ""
        flow.id = uuid.uuid4()
        flow.flow_name = "Test Flow"
        flow.status = "active"
        flow.client_account_id = uuid.uuid4()
        return flow

    def test_map_flow_to_response_with_valid_flow_id(self, mock_flow_with_valid_id, mock_context):
        """Test response mapping with valid flow_id succeeds"""
        result = ResponseMappers.map_flow_to_response(mock_flow_with_valid_id, mock_context)

        assert result is not None
        assert result["flow_id"] == str(mock_flow_with_valid_id.flow_id)
        assert result["status"] == "active"
        assert result["type"] == "discovery"
        assert result["current_phase"] == "field_mapping"
        assert result["progress_percentage"] == 25.0

    def test_map_flow_to_response_with_null_flow_id_returns_none(self, mock_flow_with_null_id, mock_context):
        """Test response mapping with null flow_id returns None"""
        with patch('app.api.v1.endpoints.discovery_flows.response_mappers.logger') as mock_logger:
            result = ResponseMappers.map_flow_to_response(mock_flow_with_null_id, mock_context)

            assert result is None
            mock_logger.error.assert_called_once()
            error_call_args = mock_logger.error.call_args[0][0]
            assert "CRITICAL: Flow with null/undefined flow_id detected!" in error_call_args

    def test_map_flow_to_response_with_empty_flow_id_returns_none(self, mock_flow_with_empty_id, mock_context):
        """Test response mapping with empty flow_id returns None"""
        with patch('app.api.v1.endpoints.discovery_flows.response_mappers.logger') as mock_logger:
            result = ResponseMappers.map_flow_to_response(mock_flow_with_empty_id, mock_context)

            assert result is None
            mock_logger.error.assert_called_once()
            error_call_args = mock_logger.error.call_args[0][0]
            assert "CRITICAL: Flow with null/undefined flow_id detected!" in error_call_args

    @pytest.mark.asyncio
    async def test_map_flow_to_status_response_with_null_flow_id_returns_none(self, mock_flow_with_null_id, mock_context):
        """Test status response mapping with null flow_id returns None"""
        with patch('app.api.v1.endpoints.discovery_flows.response_mappers.logger') as mock_logger:
            result = await ResponseMappers.map_flow_to_status_response(
                mock_flow_with_null_id, None, mock_context, None
            )

            assert result is None
            mock_logger.error.assert_called_once()
            error_call_args = mock_logger.error.call_args[0][0]
            assert "CRITICAL: Status request for flow with null flow_id!" in error_call_args

    @pytest.mark.asyncio
    async def test_map_flow_to_status_response_with_valid_flow_id(self, mock_flow_with_valid_id, mock_context):
        """Test status response mapping with valid flow_id succeeds"""
        result = await ResponseMappers.map_flow_to_status_response(
            mock_flow_with_valid_id, None, mock_context, None
        )

        assert result is not None
        assert result["flow_id"] == str(mock_flow_with_valid_id.flow_id)
        assert result["status"] == "active"
        assert result["type"] == "discovery"
        assert result["current_phase"] == "field_mapping"

    def test_response_mapper_handles_exception_gracefully(self, mock_context):
        """Test response mapper handles exceptions gracefully"""
        # Create a flow that will cause an exception during mapping
        bad_flow = Mock(spec=DiscoveryFlow)
        bad_flow.flow_id = uuid.uuid4()
        bad_flow.status = "active"
        # Remove required attributes to cause exception
        del bad_flow.client_account_id

        with patch('app.api.v1.endpoints.discovery_flows.response_mappers.logger') as mock_logger:
            result = ResponseMappers.map_flow_to_response(bad_flow, mock_context)

            # Should return error response, not None
            assert result is not None
            assert result["status"] == "error"
            assert result["flow_id"] == str(bad_flow.flow_id)
            assert "error" in result
            mock_logger.error.assert_called()


class TestDatabaseFlowIdFiltering:
    """Test database-level filtering for flows with valid IDs"""

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.fixture
    def mock_db_session(self):
        """Create mock database session"""
        session = AsyncMock(spec=AsyncSession)
        return session

    @pytest.mark.asyncio
    async def test_query_filters_flows_with_null_flow_id(self, mock_db_session, mock_context):
        """Test that database queries filter out flows with null flow_id"""
        from sqlalchemy import and_, or_, select
        from app.models.discovery_flow import DiscoveryFlow

        # Create the query that should filter out null flow_ids
        stmt = select(DiscoveryFlow).where(
            and_(
                DiscoveryFlow.client_account_id == mock_context.client_account_id,
                DiscoveryFlow.flow_id.is_not(None),  # This is the critical filter
                DiscoveryFlow.status != "deleted",
                DiscoveryFlow.status != "cancelled",
                or_(
                    DiscoveryFlow.status == "active",
                    DiscoveryFlow.status == "running",
                    DiscoveryFlow.status == "initialized"
                ),
            )
        )

        # Verify the query structure includes the null filter
        where_clause = str(stmt.compile(compile_kwargs={"literal_binds": True}))
        assert "flow_id IS NOT NULL" in where_clause

    @pytest.mark.asyncio
    async def test_flow_queries_exclude_null_flow_ids(self, mock_db_session, mock_context):
        """Test that FlowQueries methods exclude flows with null flow_ids"""
        flow_queries = FlowQueries(
            mock_db_session,
            mock_context.client_account_id,
            mock_context.engagement_id
        )

        # Mock database result with mixed flows
        mock_valid_flow = Mock(spec=DiscoveryFlow)
        mock_valid_flow.flow_id = uuid.uuid4()
        mock_valid_flow.status = "active"

        mock_result = Mock()
        mock_result.scalars.return_value.all.return_value = [mock_valid_flow]
        mock_db_session.execute.return_value = mock_result

        flows = await flow_queries.get_active_flows()

        # Verify the query was executed
        mock_db_session.execute.assert_called_once()
        
        # Verify the returned flow has valid flow_id
        assert len(flows) == 1
        assert flows[0].flow_id is not None


class TestFlowStateIntegrity:
    """Test flow state persistence and integrity"""

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.fixture
    def mock_db_session(self):
        """Create mock database session"""
        session = AsyncMock(spec=AsyncSession)
        session.execute = AsyncMock()
        session.commit = AsyncMock()
        return session

    @pytest.fixture
    def flow_commands(self, mock_db_session, mock_context):
        """Create FlowCommands instance"""
        return FlowCommands(
            mock_db_session,
            mock_context.client_account_id,
            mock_context.engagement_id
        )

    @pytest.mark.asyncio
    async def test_update_flow_status_validates_flow_id(self, flow_commands):
        """Test that flow status updates validate flow_id"""
        invalid_flow_id = "invalid-uuid"

        with pytest.raises(ValueError, match="Invalid UUID"):
            await flow_commands.update_flow_status(invalid_flow_id, "running")

    @pytest.mark.asyncio
    async def test_update_phase_completion_validates_flow_id(self, flow_commands):
        """Test that phase completion updates validate flow_id"""
        invalid_flow_id = "invalid-uuid"

        with pytest.raises(ValueError, match="Invalid UUID"):
            await flow_commands.update_phase_completion(
                invalid_flow_id, "field_mapping", completed=True
            )

    @pytest.mark.asyncio
    async def test_mark_flow_complete_validates_flow_id(self, flow_commands):
        """Test that flow completion validates flow_id"""
        invalid_flow_id = "invalid-uuid"

        with pytest.raises(ValueError, match="Invalid UUID"):
            await flow_commands.mark_flow_complete(invalid_flow_id)

    @pytest.mark.asyncio
    async def test_delete_flow_validates_flow_id(self, flow_commands):
        """Test that flow deletion validates flow_id"""
        invalid_flow_id = "invalid-uuid"

        with pytest.raises(ValueError, match="Invalid UUID"):
            await flow_commands.delete_flow(invalid_flow_id)


class TestFlowIdIntegrityEdgeCases:
    """Test edge cases for flow ID integrity"""

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.fixture
    def mock_db_session(self):
        """Create mock database session"""
        return AsyncMock(spec=AsyncSession)

    @pytest.fixture
    def flow_commands(self, mock_db_session, mock_context):
        """Create FlowCommands instance"""
        return FlowCommands(
            mock_db_session,
            mock_context.client_account_id,
            mock_context.engagement_id
        )

    @pytest.mark.asyncio
    async def test_create_flow_with_uppercase_uuid(self, flow_commands):
        """Test creating flow with uppercase UUID string"""
        uppercase_uuid = str(uuid.uuid4()).upper()
        
        # Mock database operations
        flow_commands.db.add = Mock()
        flow_commands.db.commit = AsyncMock()
        flow_commands.db.refresh = AsyncMock()

        result = await flow_commands.create_discovery_flow(
            flow_id=uppercase_uuid,
            description="Test Flow"
        )

        assert isinstance(result, DiscoveryFlow)
        assert str(result.flow_id).lower() == uppercase_uuid.lower()

    @pytest.mark.asyncio
    async def test_create_flow_with_uuid_with_hyphens(self, flow_commands):
        """Test creating flow with UUID containing hyphens"""
        uuid_with_hyphens = str(uuid.uuid4())
        
        # Mock database operations
        flow_commands.db.add = Mock()
        flow_commands.db.commit = AsyncMock()
        flow_commands.db.refresh = AsyncMock()

        result = await flow_commands.create_discovery_flow(
            flow_id=uuid_with_hyphens,
            description="Test Flow"
        )

        assert isinstance(result, DiscoveryFlow)
        assert str(result.flow_id) == uuid_with_hyphens

    @pytest.mark.asyncio
    async def test_create_flow_with_uuid_without_hyphens_fails(self, flow_commands):
        """Test creating flow with UUID string without hyphens fails"""
        uuid_no_hyphens = str(uuid.uuid4()).replace("-", "")
        
        with pytest.raises(ValueError, match="Invalid UUID"):
            await flow_commands.create_discovery_flow(
                flow_id=uuid_no_hyphens,
                description="Test Flow"
            )

    def test_response_mapper_with_flow_missing_attributes(self, mock_context):
        """Test response mapper handles flows with missing attributes"""
        incomplete_flow = Mock(spec=DiscoveryFlow)
        incomplete_flow.flow_id = uuid.uuid4()
        incomplete_flow.status = "active"
        # Missing other required attributes
        
        with patch('app.api.v1.endpoints.discovery_flows.response_mappers.logger') as mock_logger:
            result = ResponseMappers.map_flow_to_response(incomplete_flow, mock_context)
            
            # Should return error response with valid flow_id
            assert result is not None
            assert result["flow_id"] == str(incomplete_flow.flow_id)
            assert result["status"] == "error"
            mock_logger.error.assert_called()

    def test_response_mapper_logs_detailed_error_info(self, mock_context):
        """Test that response mapper logs detailed error information"""
        flow_with_null_id = Mock(spec=DiscoveryFlow)
        flow_with_null_id.flow_id = None
        flow_with_null_id.id = uuid.uuid4()
        flow_with_null_id.flow_name = "Test Flow"
        flow_with_null_id.status = "active"
        flow_with_null_id.client_account_id = uuid.uuid4()

        with patch('app.api.v1.endpoints.discovery_flows.response_mappers.logger') as mock_logger:
            result = ResponseMappers.map_flow_to_response(flow_with_null_id, mock_context)

            assert result is None
            mock_logger.error.assert_called_once()
            
            # Verify detailed logging information
            error_call_args = mock_logger.error.call_args[0][0]
            assert str(flow_with_null_id.id) in error_call_args
            assert "Test Flow" in error_call_args
            assert "active" in error_call_args
            assert str(flow_with_null_id.client_account_id) in error_call_args


if __name__ == "__main__":
    pytest.main([__file__, "-v"])