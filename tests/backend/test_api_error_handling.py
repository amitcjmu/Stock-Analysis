"""
API Error Handling Tests

This module tests the API error handling fixes implemented for Discovery and Assessment flows:
- Proper HTTP status codes for different flow states
- Flow transition error scenarios
- Centralized validation helper functions
- 404 errors during flow transitions
- Recovery from various error conditions

Generated by CC for ADCS Backend Testing Framework
"""

import asyncio
import uuid
from datetime import datetime
from typing import Any, Dict, List
from unittest.mock import AsyncMock, Mock, patch

import pytest
from fastapi import HTTPException
from fastapi.testclient import TestClient
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.context import RequestContext
from app.models.discovery_flow import DiscoveryFlow


class TestAPIErrorStatusCodes:
    """Test proper HTTP status codes for various error scenarios"""

    @pytest.fixture
    def client(self):
        """Create test client"""
        from main import app
        return TestClient(app)

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.fixture
    def auth_headers(self):
        """Create authentication headers"""
        return {
            "Authorization": "Bearer test_token",
            "Content-Type": "application/json",
            "X-Client-Account-ID": str(uuid.uuid4()),
        }

    def test_get_nonexistent_flow_returns_404(self, client, auth_headers):
        """Test that requesting a non-existent flow returns 404"""
        nonexistent_flow_id = str(uuid.uuid4())
        
        with patch('app.core.auth.get_current_context') as mock_context:
            mock_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            response = client.get(
                f"/api/v1/discovery/flows/{nonexistent_flow_id}/status",
                headers=auth_headers
            )
            
            assert response.status_code == 404
            assert "not found" in response.json()["detail"].lower()

    def test_get_flow_with_invalid_uuid_format_returns_404(self, client, auth_headers):
        """Test that requesting a flow with invalid UUID format returns proper error"""
        invalid_flow_id = "not-a-uuid"
        
        with patch('app.core.auth.get_current_context') as mock_context:
            mock_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            response = client.get(
                f"/api/v1/discovery/flows/{invalid_flow_id}/status",
                headers=auth_headers
            )
            
            # Should handle invalid UUID gracefully
            assert response.status_code in [404, 422, 500]

    def test_get_processing_flow_returns_202(self, client, auth_headers):
        """Test that requesting a flow being processed returns 202"""
        processing_flow_id = str(uuid.uuid4())
        
        with patch('app.core.auth.get_current_context') as mock_context:
            mock_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            # Mock the database query to simulate a processing error
            with patch('app.api.v1.endpoints.discovery_flows.query_endpoints.select') as mock_select:
                mock_select.side_effect = Exception("Flow is currently being processed")
                
                response = client.get(
                    f"/api/v1/discovery/flows/{processing_flow_id}/status",
                    headers=auth_headers
                )
                
                if response.status_code == 202:
                    assert "currently being processed" in response.json()["detail"].lower()

    def test_unauthorized_request_returns_401(self, client):
        """Test that requests without authentication return 401"""
        flow_id = str(uuid.uuid4())
        
        response = client.get(f"/api/v1/discovery/flows/{flow_id}/status")
        
        assert response.status_code == 401

    def test_insufficient_permissions_returns_403(self, client):
        """Test that requests with insufficient permissions return 403"""
        flow_id = str(uuid.uuid4())
        limited_headers = {
            "Authorization": "Bearer limited_token",
            "Content-Type": "application/json",
            "X-User-Role": "viewer",  # Read-only role
        }
        
        response = client.get(
            f"/api/v1/discovery/flows/{flow_id}/status",
            headers=limited_headers
        )
        
        assert response.status_code in [401, 403]

    def test_internal_server_error_returns_500(self, client, auth_headers):
        """Test that internal server errors return 500"""
        flow_id = str(uuid.uuid4())
        
        with patch('app.core.auth.get_current_context') as mock_context:
            mock_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            # Mock a database error
            with patch('app.api.v1.endpoints.discovery_flows.query_endpoints.select') as mock_select:
                mock_select.side_effect = Exception("Database connection failed")
                
                response = client.get(
                    f"/api/v1/discovery/flows/{flow_id}/status",
                    headers=auth_headers
                )
                
                if response.status_code == 500:
                    assert "failed" in response.json()["detail"].lower()


class TestFlowTransitionErrorHandling:
    """Test error handling during flow transitions"""

    @pytest.fixture
    def mock_db_session(self):
        """Create mock database session"""
        session = AsyncMock(spec=AsyncSession)
        return session

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.mark.asyncio
    async def test_flow_transition_with_missing_context_raises_error(self):
        """Test that flow transitions without proper context raise errors"""
        from app.api.v1.endpoints.discovery_flows.query_endpoints import get_active_flows
        
        # Mock missing context
        with pytest.raises(HTTPException) as exc_info:
            await get_active_flows(
                response=Mock(),
                if_none_match=None,
                context=None,  # Missing context
                db=AsyncMock()
            )
        
        assert exc_info.value.status_code == 403
        assert "context is required" in str(exc_info.value.detail).lower()

    @pytest.mark.asyncio
    async def test_flow_transition_with_invalid_client_id_raises_error(self, mock_db_session):
        """Test that flow transitions with invalid client ID raise errors"""
        from app.api.v1.endpoints.discovery_flows.query_endpoints import get_active_flows
        
        invalid_context = RequestContext(
            client_account_id=None,  # Invalid client ID
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )
        
        with pytest.raises(HTTPException) as exc_info:
            await get_active_flows(
                response=Mock(),
                if_none_match=None,
                context=invalid_context,
                db=mock_db_session
            )
        
        assert exc_info.value.status_code == 403
        assert "client account context is required" in str(exc_info.value.detail).lower()

    @pytest.mark.asyncio
    async def test_flow_status_query_handles_database_errors(self, mock_db_session, mock_context):
        """Test that flow status queries handle database errors gracefully"""
        from app.api.v1.endpoints.discovery_flows.query_endpoints import get_flow_status
        
        flow_id = str(uuid.uuid4())
        mock_db_session.execute.side_effect = Exception("Database connection lost")
        
        with pytest.raises(HTTPException) as exc_info:
            await get_flow_status(
                flow_id=flow_id,
                response=Mock(),
                if_none_match=None,
                context=mock_context,
                db=mock_db_session
            )
        
        # Should be either 404 (flow not found) or 500 (internal error)
        assert exc_info.value.status_code in [404, 500]

    @pytest.mark.asyncio
    async def test_flow_status_query_with_orchestrator_fallback_failure(self, mock_db_session, mock_context):
        """Test flow status query when all fallback methods fail"""
        from app.api.v1.endpoints.discovery_flows.query_endpoints import get_flow_status
        
        flow_id = str(uuid.uuid4())
        
        # Mock database returning no flows
        mock_result = Mock()
        mock_result.scalar_one_or_none.return_value = None
        mock_db_session.execute.return_value = mock_result
        
        # Mock flow state store failure
        with patch('app.services.crewai_flows.persistence.postgres_store.PostgresFlowStateStore') as mock_store_class:
            mock_store = Mock()
            mock_store.load_state.side_effect = Exception("Store unavailable")
            mock_store_class.return_value = mock_store
            
            # Mock orchestrator failure
            with patch('app.services.master_flow_orchestrator.MasterFlowOrchestrator') as mock_orchestrator_class:
                mock_orchestrator = Mock()
                mock_orchestrator.get_flow_status.return_value = None
                mock_orchestrator_class.return_value = mock_orchestrator
                
                with pytest.raises(HTTPException) as exc_info:
                    await get_flow_status(
                        flow_id=flow_id,
                        response=Mock(),
                        if_none_match=None,
                        context=mock_context,
                        db=mock_db_session
                    )
                
                assert exc_info.value.status_code == 404
                assert "not found" in str(exc_info.value.detail).lower()


class TestValidationHelperFunctions:
    """Test centralized validation helper functions"""

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    def test_response_mapper_validation_with_null_flow_id(self, mock_context):
        """Test response mapper validation rejects null flow_id"""
        from app.api.v1.endpoints.discovery_flows.response_mappers import ResponseMappers
        
        flow_with_null_id = Mock()
        flow_with_null_id.flow_id = None
        flow_with_null_id.id = uuid.uuid4()
        flow_with_null_id.flow_name = "Test Flow"
        flow_with_null_id.status = "active"
        
        result = ResponseMappers.map_flow_to_response(flow_with_null_id, mock_context)
        
        # Should return None for invalid flows
        assert result is None

    def test_response_mapper_validation_with_valid_flow_id(self, mock_context):
        """Test response mapper validation accepts valid flow_id"""
        from app.api.v1.endpoints.discovery_flows.response_mappers import ResponseMappers
        
        valid_flow = Mock()
        valid_flow.flow_id = uuid.uuid4()
        valid_flow.id = uuid.uuid4()
        valid_flow.flow_name = "Test Flow"
        valid_flow.status = "active"
        valid_flow.current_phase = "field_mapping"
        valid_flow.progress_percentage = 25.0
        valid_flow.client_account_id = uuid.uuid4()
        valid_flow.engagement_id = uuid.uuid4()
        valid_flow.created_at = datetime.utcnow()
        valid_flow.updated_at = datetime.utcnow()
        valid_flow.data_import_id = uuid.uuid4()
        valid_flow.crewai_state_data = {}
        valid_flow.flow_state = {}
        
        # Mock phase completion flags
        valid_flow.data_import_completed = False
        valid_flow.field_mapping_completed = False
        valid_flow.data_cleansing_completed = False
        valid_flow.asset_inventory_completed = False
        valid_flow.dependency_analysis_completed = False
        valid_flow.tech_debt_assessment_completed = False
        
        result = ResponseMappers.map_flow_to_response(valid_flow, mock_context)
        
        # Should return valid response
        assert result is not None
        assert result["flow_id"] == str(valid_flow.flow_id)
        assert result["status"] == "active"

    def test_flow_commands_validation_rejects_invalid_uuid(self):
        """Test flow commands validation rejects invalid UUIDs"""
        from app.repositories.discovery_flow_repository.commands.flow_commands import FlowCommands
        
        flow_commands = FlowCommands(
            AsyncMock(),
            uuid.uuid4(),
            uuid.uuid4()
        )
        
        with pytest.raises(ValueError, match="Invalid UUID"):
            flow_commands._ensure_uuid("not-a-uuid")
        
        with pytest.raises(ValueError, match="Invalid UUID"):
            flow_commands._ensure_uuid(12345)
        
        with pytest.raises(ValueError, match="Invalid UUID"):
            flow_commands._ensure_uuid(None)

    def test_flow_commands_validation_accepts_valid_uuid(self):
        """Test flow commands validation accepts valid UUIDs"""
        from app.repositories.discovery_flow_repository.commands.flow_commands import FlowCommands
        
        flow_commands = FlowCommands(
            AsyncMock(),
            uuid.uuid4(),
            uuid.uuid4()
        )
        
        test_uuid = uuid.uuid4()
        
        # Test UUID object
        result = flow_commands._ensure_uuid(test_uuid)
        assert result == test_uuid
        
        # Test string UUID
        result = flow_commands._ensure_uuid(str(test_uuid))
        assert str(result) == str(test_uuid)


class TestClarificationsEndpointErrorHandling:
    """Test error handling for the missing clarifications endpoint functionality"""

    @pytest.fixture
    def client(self):
        """Create test client"""
        from main import app
        return TestClient(app)

    @pytest.fixture
    def auth_headers(self):
        """Create authentication headers"""
        return {
            "Authorization": "Bearer test_token",
            "Content-Type": "application/json",
            "X-Client-Account-ID": str(uuid.uuid4()),
        }

    def test_agent_insights_endpoint_error_handling(self, client, auth_headers):
        """Test agent insights endpoint error handling"""
        flow_id = str(uuid.uuid4())
        
        with patch('app.core.auth.get_current_context') as mock_context:
            mock_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            # Test nonexistent flow
            response = client.get(
                f"/api/v1/discovery/flow/{flow_id}/agent-insights",
                headers=auth_headers
            )
            
            # Should handle missing flow gracefully
            assert response.status_code in [200, 404]
            
            if response.status_code == 200:
                # Should return empty list or valid data structure
                data = response.json()
                assert isinstance(data, list)

    def test_agent_insights_with_invalid_page_context(self, client, auth_headers):
        """Test agent insights with invalid page context parameter"""
        flow_id = str(uuid.uuid4())
        
        with patch('app.core.auth.get_current_context') as mock_context:
            mock_context.return_value = RequestContext(
                client_account_id=uuid.uuid4(),
                engagement_id=uuid.uuid4(),
                user_id=str(uuid.uuid4()),
            )
            
            response = client.get(
                f"/api/v1/discovery/flow/{flow_id}/agent-insights?page_context=invalid_context",
                headers=auth_headers
            )
            
            # Should handle invalid page context gracefully
            assert response.status_code in [200, 400, 404]


class TestErrorRecoveryScenarios:
    """Test error recovery scenarios"""

    @pytest.fixture
    def mock_db_session(self):
        """Create mock database session"""
        session = AsyncMock(spec=AsyncSession)
        return session

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    @pytest.mark.asyncio
    async def test_database_recovery_after_connection_loss(self, mock_db_session, mock_context):
        """Test recovery after database connection loss"""
        from app.api.v1.endpoints.discovery_flows.query_endpoints import get_active_flows
        
        # First call fails due to database error
        mock_db_session.execute.side_effect = Exception("Connection lost")
        
        with pytest.raises(HTTPException) as exc_info:
            await get_active_flows(
                response=Mock(),
                if_none_match=None,
                context=mock_context,
                db=mock_db_session
            )
        
        assert exc_info.value.status_code == 500
        assert "failed" in str(exc_info.value.detail).lower()

    @pytest.mark.asyncio
    async def test_multiple_fallback_attempts(self, mock_db_session, mock_context):
        """Test multiple fallback attempts when primary methods fail"""
        from app.api.v1.endpoints.discovery_flows.query_endpoints import get_flow_status
        
        flow_id = str(uuid.uuid4())
        
        # Mock primary database query failure
        mock_result = Mock()
        mock_result.scalar_one_or_none.return_value = None
        mock_db_session.execute.return_value = mock_result
        
        # Mock state store failure
        with patch('app.services.crewai_flows.persistence.postgres_store.PostgresFlowStateStore') as mock_store_class:
            mock_store = Mock()
            mock_store.load_state.side_effect = Exception("Store error")
            mock_store_class.return_value = mock_store
            
            # Mock orchestrator failure
            with patch('app.services.master_flow_orchestrator.MasterFlowOrchestrator') as mock_orchestrator_class:
                mock_orchestrator = Mock()
                mock_orchestrator.get_flow_status.side_effect = Exception("Orchestrator error")
                mock_orchestrator_class.return_value = mock_orchestrator
                
                with pytest.raises(HTTPException) as exc_info:
                    await get_flow_status(
                        flow_id=flow_id,
                        response=Mock(),
                        if_none_match=None,
                        context=mock_context,
                        db=mock_db_session
                    )
                
                # Should eventually return 404 when all methods fail
                assert exc_info.value.status_code == 404

    @pytest.mark.asyncio
    async def test_partial_data_recovery(self, mock_db_session, mock_context):
        """Test recovery when only partial data is available"""
        from app.api.v1.endpoints.discovery_flows.query_endpoints import get_flow_status
        
        flow_id = str(uuid.uuid4())
        
        # Mock flow with minimal data
        partial_flow = Mock(spec=DiscoveryFlow)
        partial_flow.flow_id = uuid.UUID(flow_id)
        partial_flow.status = "active"
        partial_flow.current_phase = None  # Missing data
        partial_flow.progress_percentage = None  # Missing data
        partial_flow.client_account_id = mock_context.client_account_id
        partial_flow.engagement_id = mock_context.engagement_id
        partial_flow.created_at = datetime.utcnow()
        partial_flow.updated_at = datetime.utcnow()
        partial_flow.crewai_state_data = {}
        
        # Set all phase completions to False
        for phase in ['data_import', 'field_mapping', 'data_cleansing', 
                      'asset_inventory', 'dependency_analysis', 'tech_debt_assessment']:
            setattr(partial_flow, f"{phase}_completed", False)
        
        mock_result = Mock()
        mock_result.scalar_one_or_none.return_value = partial_flow
        mock_db_session.execute.return_value = mock_result
        
        response = await get_flow_status(
            flow_id=flow_id,
            response=Mock(),
            if_none_match=None,
            context=mock_context,
            db=mock_db_session
        )
        
        # Should handle partial data gracefully
        assert response is not None
        assert response["flow_id"] == flow_id
        assert response["status"] == "active"
        # Should provide defaults for missing data
        assert "current_phase" in response
        assert "progress_percentage" in response


class TestResponseValidation:
    """Test response validation and formatting"""

    @pytest.fixture
    def mock_context(self):
        """Create mock request context"""
        return RequestContext(
            client_account_id=uuid.uuid4(),
            engagement_id=uuid.uuid4(),
            user_id=str(uuid.uuid4()),
        )

    def test_error_response_format_consistency(self, mock_context):
        """Test that error responses have consistent format"""
        from app.api.v1.endpoints.discovery_flows.response_mappers import ResponseMappers
        
        flow_id = str(uuid.uuid4())
        error_message = "Test error message"
        
        error_response = ResponseMappers.create_error_response(flow_id, error_message, 500)
        
        # Verify error response structure
        assert error_response["flow_id"] == flow_id
        assert error_response["status"] == "error"
        assert error_response["type"] == "discovery"
        assert error_response["error"] == error_message
        assert error_response["error_code"] == 500
        assert "timestamp" in error_response
        assert "metadata" in error_response

    def test_success_response_format_consistency(self, mock_context):
        """Test that success responses have consistent format"""
        from app.api.v1.endpoints.discovery_flows.response_mappers import ResponseMappers
        
        flow_id = str(uuid.uuid4())
        message = "Operation successful"
        data = {"additional": "data"}
        
        success_response = ResponseMappers.create_success_response(flow_id, message, data)
        
        # Verify success response structure
        assert success_response["success"] is True
        assert success_response["flow_id"] == flow_id
        assert success_response["message"] == message
        assert success_response["additional"] == "data"
        assert "timestamp" in success_response

    def test_response_contains_required_fields(self, mock_context):
        """Test that all responses contain required fields"""
        from app.api.v1.endpoints.discovery_flows.response_mappers import ResponseMappers
        
        # Create minimal valid flow
        flow = Mock()
        flow.flow_id = uuid.uuid4()
        flow.status = "active"
        flow.current_phase = "field_mapping"
        flow.progress_percentage = 25.0
        flow.client_account_id = uuid.uuid4()
        flow.engagement_id = uuid.uuid4()
        flow.created_at = datetime.utcnow()
        flow.updated_at = datetime.utcnow()
        flow.data_import_id = None
        flow.crewai_state_data = {}
        flow.flow_state = {}
        flow.flow_name = "Test Flow"
        
        # Mock phase completion flags
        for phase in ['data_import', 'field_mapping', 'data_cleansing', 
                      'asset_inventory', 'dependency_analysis', 'tech_debt_assessment']:
            setattr(flow, f"{phase}_completed", False)
        
        response = ResponseMappers.map_flow_to_response(flow, mock_context)
        
        # Verify required fields are present
        required_fields = [
            'flow_id', 'status', 'type', 'current_phase', 'progress_percentage',
            'client_account_id', 'engagement_id', 'created_at', 'updated_at',
            'phases_completed', 'metadata'
        ]
        
        for field in required_fields:
            assert field in response, f"Required field '{field}' missing from response"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])