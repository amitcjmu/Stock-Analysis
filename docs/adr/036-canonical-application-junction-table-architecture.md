# ADR-036: Canonical Application Junction Table Architecture

**Status**: Accepted
**Date**: 2025-11-12
**Context**: Bug #999 - Assessment flow 6R recommendations not persisting to assets table
**Deciders**: Engineering Team
**Related**: Bug #999, ADR-034 (Asset-Centric Questionnaire Deduplication)

## Context and Problem Statement

During Bug #999 investigation, we discovered that 6R migration recommendations generated by assessment flows were not being persisted to the assets table. Root cause analysis revealed a **critical architectural gap**: the questionnaire submission path was not creating canonical application records or junction table entries, causing assets to be orphaned from the canonicalization system.

**Evidence**:
- 134 total assets in test tenant
- Only 24 assets (18%) have `collection_flow_applications` junction records
- 110 assets (82%) orphaned - no link to canonical applications
- Assessment flows cannot reliably map 6R recommendations to assets

**Symptoms**:
```
WARNING - [ISSUE-999] ⚠️ No assets found for application 'Analytics Engine'
```

The original Bug #999 fix attempted to update assets by `application_name` field, but this approach is fundamentally flawed because:
1. Assets may have empty `application_name` fields
2. Application names vary (e.g., "SAP ERP" vs "SAP-ERP" vs "SAP ERP System")
3. No deduplication occurs, causing fragmentation

## Decision Drivers

1. **Data Integrity**: Single source of truth for application canonicalization
2. **Multi-Path Support**: Bulk import AND questionnaire submission must create junction records
3. **Race Condition Safety**: Concurrent collection flows must not create duplicate canonical apps
4. **Backward Compatibility**: Existing 110 orphaned assets require migration path
5. **Assessment Flow Integration**: 6R recommendations must reliably persist to correct assets

## Considered Options

### Option 1: Direct Foreign Key (Assets → Canonical Applications)
**Rejected**: Violates separation of concerns. Assets must exist before canonicalization.

### Option 2: Application Name Field Only
**Rejected**: Current broken state. No deduplication, unreliable matching, data fragmentation.

### Option 3: Junction Table Architecture (SELECTED)
**Accepted**: Preserves audit trail, supports multi-path flows, enables proper deduplication.

## Decision

We will implement a **complete junction table architecture** with the following components:

### Architecture Overview

```
Assets Table (application_name field)
         ↓ (linked via)
collection_flow_applications (junction table)
         ├─ asset_id (FK → assets.id)
         ├─ collection_flow_id (FK → collection_flows.id, NOT NULL)
         ├─ canonical_application_id (FK → canonical_applications.id)
         ├─ deduplication_method (VARCHAR - tracks how mapping was made)
         ├─ match_confidence (FLOAT - deduplication confidence score)
         └─ collection_status (VARCHAR - pending/validated/rejected)
                  ↓ (points to)
    canonical_applications (master registry)
         ├─ normalized_name (UNIQUE per tenant)
         ├─ name_hash (for exact matching)
         └─ name_embedding (vector for fuzzy matching)
```

### Implementation Phases

#### Phase 1: Fix Race Condition in Canonical App Creation
**File**: `backend/app/models/canonical_applications/canonical_application.py`

**Problem**: Multiple concurrent collection flows creating same canonical app → IntegrityError

**Solution**: Add retry logic with up to 3 attempts:
```python
@classmethod
async def find_or_create_canonical(cls, db, application_name, ...):
    for attempt in range(3):
        try:
            # Try exact hash match
            existing = await db.execute(select(cls).where(...))
            if existing:
                return existing

            # Create new canonical app
            new_canonical = cls(...)
            db.add(new_canonical)
            await db.commit()
            return new_canonical

        except IntegrityError as e:
            await db.rollback()
            if "uq_canonical_apps_tenant_name" in str(e):
                continue  # Race condition - retry SELECT
            else:
                raise  # Different error - propagate

    raise RuntimeError("Failed after 3 retries")
```

**Benefits**:
- Handles concurrent collection flows safely
- No duplicate canonical apps created
- Failed attempts don't orphan assets

#### Phase 2: Add Canonicalization to Questionnaire Path
**File**: `backend/app/api/v1/endpoints/collection_crud_update_commands/questionnaire_submission.py`

**Problem**: Questionnaire submissions update `Asset.application_name` but don't create canonical app or junction record

**Solution**: Add canonicalization after questionnaire processing:
```python
# After line 159 in questionnaire_submission.py

# Extract application name from responses or asset
application_name = form_metadata.get("application_name") or asset.application_name

if application_name:
    try:
        # Create/find canonical application (with retry logic from Phase 1)
        canonical_app, is_new, variant = await CanonicalApplication.find_or_create_canonical(
            db=db,
            application_name=application_name,
            client_account_id=context.client_account_id,
            engagement_id=context.engagement_id,
            user_id=current_user.id,
        )

        # Create junction record
        junction_record = CollectionFlowApplication(
            collection_flow_id=flow.id,
            asset_id=asset_id,
            application_name=application_name,
            canonical_application_id=canonical_app.id,
            name_variant_id=variant.id if variant else None,
            deduplication_method="questionnaire_auto",
            match_confidence=canonical_app.confidence_score,
            collection_status="pending",
            client_account_id=context.client_account_id,
            engagement_id=context.engagement_id,
        )
        db.add(junction_record)

    except Exception as e:
        logger.error(f"Canonical app creation failed for questionnaire: {e}")
        # Continue - don't fail entire submission
```

**Benefits**:
- Questionnaire path now at parity with bulk import
- All collection flow paths create junction records
- Deduplication metadata tracked

#### Phase 3: Update Asset Update Logic to Use Junction Table
**File**: `backend/app/services/flow_orchestration/execution_engine_crew_assessment/recommendation_executor_asset_update.py`

**Problem**: Current logic updates assets by `application_name` field (unreliable)

**Solution**: Use junction table to find asset IDs:
```python
async def _update_assets_with_recommendations(
    self,
    parsed_result: Dict[str, Any],
    assessment_flow_id: str,
    master_flow: CrewAIFlowStateExtensions,
) -> int:
    """Update assets with 6R recommendations via junction table lookup."""

    # Get database session
    db = self.crew_utils.db

    # Query junction table for asset mappings
    for app in parsed_result.get("applications", []):
        canonical_app_id = app.get("application_id")  # This is canonical_application_id
        six_r_strategy = app.get("six_r_strategy")
        confidence_score = app.get("confidence_score", 0.0)

        # Get asset IDs from junction table
        result = await db.execute(
            select(CollectionFlowApplication.asset_id)
            .where(
                CollectionFlowApplication.canonical_application_id == canonical_app_id,
                CollectionFlowApplication.client_account_id == master_flow.client_account_id,
                CollectionFlowApplication.engagement_id == master_flow.engagement_id,
            )
        )
        asset_ids = [row[0] for row in result.fetchall()]

        # Update assets by asset_id (reliable!)
        if asset_ids:
            update_stmt = (
                update(Asset)
                .where(
                    Asset.id.in_(asset_ids),
                    Asset.client_account_id == master_flow.client_account_id,
                    Asset.engagement_id == master_flow.engagement_id,
                )
                .values(
                    six_r_strategy=six_r_strategy.lower(),
                    confidence_score=confidence_score,
                    assessment_flow_id=assessment_flow_id,
                    # Backfill application_name if empty
                    application_name=app.get("application_name"),
                )
            )
            result = await db.execute(update_stmt)
            total_updated += result.rowcount

    await db.commit()
    return total_updated
```

**Benefits**:
- Reliable updates using asset_id (primary key)
- Works for bulk import AND questionnaire paths
- Backfills `application_name` if missing
- Supports one-to-many (one canonical app → multiple assets)

#### Phase 4: Data Migration for Orphaned Assets
**File**: `backend/alembic/versions/093_backfill_canonical_applications.py`

**Problem**: 110 existing assets have no junction records

**Solution**: Create migration script with "System Migration" collection flow:
```python
def upgrade():
    # Step 1: Create "System Migration" collection flow
    conn.execute("""
        INSERT INTO migration.collection_flows (
            id,
            client_account_id,
            engagement_id,
            flow_name,
            status,
            created_at,
            updated_at
        )
        SELECT
            gen_random_uuid(),
            DISTINCT client_account_id,
            engagement_id,
            'System Migration - Canonical App Backfill',
            'completed',
            NOW(),
            NOW()
        FROM migration.assets
        WHERE NOT EXISTS (
            SELECT 1 FROM migration.collection_flows
            WHERE flow_name = 'System Migration - Canonical App Backfill'
        )
        GROUP BY client_account_id, engagement_id;
    """)

    # Step 2: For each orphaned asset, create canonical app + junction record
    conn.execute("""
        WITH orphaned_assets AS (
            SELECT
                a.id as asset_id,
                a.application_name,
                a.client_account_id,
                a.engagement_id
            FROM migration.assets a
            LEFT JOIN migration.collection_flow_applications cfa
                ON a.id = cfa.asset_id
            WHERE cfa.id IS NULL
                AND a.application_name IS NOT NULL
                AND a.application_name != ''
        ),
        canonical_apps AS (
            -- Create canonical applications for orphaned assets
            INSERT INTO migration.canonical_applications (
                id,
                canonical_name,
                normalized_name,
                name_hash,
                client_account_id,
                engagement_id,
                confidence_score,
                is_verified,
                usage_count,
                created_at,
                updated_at
            )
            SELECT
                gen_random_uuid(),
                application_name,
                LOWER(REGEXP_REPLACE(application_name, '[^a-zA-Z0-9]', '', 'g')),
                MD5(LOWER(REGEXP_REPLACE(application_name, '[^a-zA-Z0-9]', '', 'g'))),
                client_account_id,
                engagement_id,
                0.5,  -- Lower confidence for backfilled apps
                FALSE,
                1,
                NOW(),
                NOW()
            FROM orphaned_assets
            ON CONFLICT (client_account_id, engagement_id, normalized_name) DO NOTHING
            RETURNING id, normalized_name, client_account_id, engagement_id
        )
        -- Create junction records
        INSERT INTO migration.collection_flow_applications (
            id,
            collection_flow_id,
            asset_id,
            application_name,
            canonical_application_id,
            deduplication_method,
            match_confidence,
            collection_status,
            client_account_id,
            engagement_id,
            created_at,
            updated_at
        )
        SELECT
            gen_random_uuid(),
            (SELECT id FROM migration.collection_flows WHERE flow_name = 'System Migration - Canonical App Backfill' LIMIT 1),
            oa.asset_id,
            oa.application_name,
            ca.id,
            'migration_backfill',
            0.5,
            'validated',
            oa.client_account_id,
            oa.engagement_id,
            NOW(),
            NOW()
        FROM orphaned_assets oa
        JOIN canonical_apps ca
            ON ca.normalized_name = LOWER(REGEXP_REPLACE(oa.application_name, '[^a-zA-Z0-9]', '', 'g'))
            AND ca.client_account_id = oa.client_account_id
            AND ca.engagement_id = oa.engagement_id;
    """)

def downgrade():
    # Remove backfilled junction records
    conn.execute("""
        DELETE FROM migration.collection_flow_applications
        WHERE deduplication_method = 'migration_backfill';
    """)

    # Remove System Migration collection flows
    conn.execute("""
        DELETE FROM migration.collection_flows
        WHERE flow_name = 'System Migration - Canonical App Backfill';
    """)
```

**Benefits**:
- Preserves data integrity (creates proper junction records)
- Audit trail preserved (marked as 'migration_backfill')
- Idempotent (can be run multiple times safely)
- Reversible (downgrade removes backfilled data)

## Consequences

### Positive

1. **Single Source of Truth**: Junction table is authoritative mapping
2. **Reliable Updates**: 6R recommendations persist correctly via asset_id lookup
3. **Race Condition Safe**: Concurrent flows don't create duplicate canonical apps
4. **Audit Trail**: Deduplication metadata tracked (method, confidence, timestamp)
5. **Backward Compatible**: Migration preserves existing data
6. **Multi-Path Support**: Works for bulk import AND questionnaire submissions

### Negative

1. **Data Migration Required**: 110 orphaned assets need backfill (one-time cost)
2. **Increased Complexity**: Additional junction table to maintain
3. **Query Changes**: Assessment flows must query junction table instead of assets directly
4. **Testing Overhead**: Must test concurrent flows, race conditions, migration

### Risks

1. **Migration Failure**: If migration script fails, 110 assets remain orphaned
   - **Mitigation**: Idempotent script, can be re-run safely

2. **Race Condition Regression**: If retry logic removed/broken, duplicate canonical apps created
   - **Mitigation**: Unit tests for concurrent flows

3. **Performance**: Additional JOIN required for asset → canonical app lookups
   - **Mitigation**: Indexed `collection_flow_applications.canonical_application_id`

## Implementation Notes

### Database Indexes Required

Already exist (verified in schema):
```sql
-- Junction table indexes
idx_cfa_asset_lookup (asset_id)
idx_cfa_tenant_canonical (client_account_id, engagement_id, canonical_application_id)
idx_collection_flow_apps_canonical (canonical_application_id, collection_flow_id)

-- Canonical apps indexes
idx_canonical_apps_tenant_isolation UNIQUE (client_account_id, engagement_id, normalized_name)
idx_canonical_apps_hash_lookup (name_hash, client_account_id, engagement_id)
```

### Testing Strategy

1. **Unit Tests**:
   - Race condition handling (10 concurrent flows creating same canonical app)
   - IntegrityError retry logic
   - Junction record creation for questionnaire submissions

2. **Integration Tests**:
   - Questionnaire → Canonical App → Junction Record → Assessment Flow
   - 6R recommendation → Junction table lookup → Asset update
   - Data migration script (idempotency, reversibility)

3. **E2E Tests**:
   - Complete collection flow → assessment flow → 6R recommendations persist
   - Verify 110 orphaned assets become accessible after migration

### Rollout Plan

1. **Phase 1 Deploy**: Race condition fix (non-breaking, safe to deploy immediately)
2. **Phase 2 Deploy**: Questionnaire canonicalization (creates junction records going forward)
3. **Phase 3 Deploy**: Asset update logic change (requires Phase 1+2, enables 6R persistence)
4. **Phase 4 Deploy**: Data migration (backfills orphaned assets, run in maintenance window)

## References

- **Bug #999**: Assessment flow reaches 100% without generating 6R recommendations
- **Investigation**: `/docs/analysis/Bug999_Investigation.md` (Explore agent findings)
- **Related ADR**: ADR-034 (Asset-Centric Questionnaire Deduplication)
- **Database Schema**: `migration.collection_flow_applications`, `migration.canonical_applications`

## Approval

- **Author**: CC (Claude Code)
- **Reviewers**: Engineering Team
- **Status**: Accepted
- **Date**: 2025-11-12
