# Collection Flow: 02 - Adaptive Forms

This document provides a complete, end-to-end data flow analysis for the `Adaptive Forms` page in the Collection phase of the AI Modernize Migration Platform.

**Analysis Date:** 2025-08-27 (Updated for Asset-Questionnaire Architecture)

**Key Architectural Changes:**
*   Questionnaire responses now properly link to specific assets via `asset_id` foreign key
*   Application name pre-filling from asset inventory when users navigate from application selection
*   Flexible questionnaire system supports both asset-linked and standalone responses
*   Bootstrap questionnaire generation with smart pre-population from collection flow config

**Assumptions:**
*   The analysis focuses on the `src/pages/collection/AdaptiveForms.tsx` page and its core hook, `useAdaptiveFormFlow`.
*   The platform operates entirely within a Docker environment.
*   All API calls require authentication and multi-tenant context headers.
*   Users may arrive via asset selection (with applicationId) or direct navigation (new applications).

---

## 1. Frontend: Components and API Calls

The Adaptive Forms page provides a dynamic, questionnaire-based approach to data collection. It polls the backend for a questionnaire that is generated by a background CrewAI process.

### Key Components & Hooks
*   **Page Component:** `src/pages/collection/AdaptiveForms.tsx`
*   **Core Logic Hook:** `useAdaptiveFormFlow` from `src/hooks/collection/useAdaptiveFormFlow.ts` encapsulates all the logic for managing the adaptive form flow with asset pre-population.
*   **Form Components:**
    *   `AdaptiveFormContainer`: Main form container with Save Progress functionality 
    *   `AdaptiveForm`: Dynamic form renderer with question numbering
    *   `FormField`: Individual form field component with pre-populated values
*   **API Client:** `collectionFlowApi` from `src/services/api/collection-flow.ts` is used for all API interactions.
*   **Data Architecture:**
    *   Asset selection flow: URL param `applicationId` → collection flow `selected_application_ids` → questionnaire pre-population
    *   Response persistence: form values → `CollectionQuestionnaireResponse` with optional `asset_id` linkage

### API Call Summary

| # | Method | Endpoint                                      | Trigger                                   | Description                                      |
|---|--------|-----------------------------------------------|-------------------------------------------|--------------------------------------------------|
| 1 | `GET`  | `/api/v1/collection/incomplete`              | `useIncompleteCollectionFlows` hook       | Fetches incomplete flows to check for blockers |
| 2 | `GET`  | `/api/v1/collection/status`                  | `initializeFlow` in `useAdaptiveFormFlow` | Gets current collection flow status             |
| 3 | `POST` | `/api/v1/collection/flows/ensure`            | `initializeFlow` if no active flow        | Creates or returns active collection flow       |
| 4 | `POST` | `/api/v1/collection/flows`                   | `initializeFlow` (flow creation)          | Creates new collection flow with selected apps  |
| 5 | `GET`  | `/api/v1/collection/flows/{flow_id}`         | `initializeFlow` (flow details)           | Fetches existing flow details                   |
| 6 | `POST` | `/api/v1/collection/flows/{flow_id}/execute` | `initializeFlow` (MFO trigger)            | Triggers CrewAI agents for questionnaire generation |
| 7 | `GET`  | `/api/v1/collection/flows/{flow_id}/questionnaires` | Polling in `initializeFlow`        | Fetches adaptive questionnaires (with bootstrap fallback) |
| 8 | `POST` | `/api/v1/collection/flows/{flow_id}/questionnaires/{questionnaire_id}/responses` | `handleSave` in `useAdaptiveFormFlow` | Saves form progress with asset linkage |
| 9 | `GET`  | `/api/v1/collection/flows/{flow_id}/questionnaires/{questionnaire_id}/responses` | Form initialization | Retrieves saved responses for pre-population |

---

## 2. Backend, CrewAI, ORM, and Database Trace

The backend implements a sophisticated asset-questionnaire architecture with flexible data collection and proper multi-tenant isolation.

### Core Backend Files

*   **Router:** `app/api/v1/endpoints/collection.py` - Main collection flow API endpoints
*   **CRUD Operations:** `app/api/v1/endpoints/collection_crud.py` - Core collection flow logic  
*   **Questionnaire Queries:** `app/api/v1/endpoints/collection_crud_questionnaires.py` - Bootstrap questionnaire generation with asset pre-population
*   **Response Management:** `app/api/v1/endpoints/collection_crud_update_commands.py` - Questionnaire response submission with asset validation
*   **Models:** 
    *   `app/models/collection_flow.py` - Collection flow state and configuration
    *   `app/models/collection_questionnaire_response.py` - Individual response records with asset linkage
    *   `app/models/asset.py` - Asset inventory with questionnaire relationships

### Database Architecture: Asset-Questionnaire Relationships

*   **Core Tables:**
    *   `migration.collection_flows` - Flow state and selected application IDs
    *   `migration.collection_questionnaire_responses` - Individual responses with optional `asset_id` FK
    *   `migration.assets` - Asset inventory with proper multi-tenant isolation
*   **Key Relationships:**
    ```sql
    -- Asset to Questionnaire Responses (1:Many, Optional)
    collection_questionnaire_responses.asset_id → assets.id
    
    -- Collection Flow to Responses (1:Many, Required)  
    collection_questionnaire_responses.collection_flow_id → collection_flows.id
    
    -- Multi-tenant Isolation (All tables scoped by)
    *.client_account_id → client_accounts.id
    *.engagement_id → engagements.id
    ```

### CrewAI Integration: Master Flow Orchestrator (MFO)

*   **Flow Trigger:** `POST /api/v1/collection/flows/{flow_id}/execute` starts MFO processing
*   **Phase Sequence:** `PLATFORM_DETECTION` → `AUTOMATED_COLLECTION` → `GAP_ANALYSIS` → `QUESTIONNAIRE_GENERATION`
*   **Persistence:** Questionnaires stored in `crewai_flow_state_extensions.flow_persistence_data` JSON field
*   **Fallback Strategy:** Bootstrap questionnaire generated if MFO fails or times out (10s limit)

### API Endpoint: `POST /api/v1/collection/flows/{flow_id}/questionnaires/{questionnaire_id}/responses`

*   **FastAPI Route:** `submit_questionnaire_response` function in `collection_crud_update_commands.py`
*   **Asset Validation Logic:**
    ```python
    # Extract asset_id from form_metadata (optional)
    asset_id = form_metadata.get("application_id") or form_metadata.get("asset_id")
    
    # Validate asset exists and belongs to engagement (if provided)
    if asset_id:
        validate_asset_in_engagement_scope()
    
    # Create response records with optional asset linkage
    response = CollectionQuestionnaireResponse(
        collection_flow_id=flow.id,
        asset_id=asset_id,  # Optional FK to assets table
        question_id=field_id,
        response_value=value,
        ...
    )
    ```
*   **Database Operations:**
    *   **Table:** `migration.collection_questionnaire_responses`
    *   **Query:** `INSERT INTO collection_questionnaire_responses (collection_flow_id, asset_id, ...) VALUES (...);`

---

## 3. End-to-End Flow Sequence: Asset-Linked Adaptive Forms

### Scenario A: User Navigates from Asset Selection 

1.  **Asset Selection:** User selects application from discovery inventory → navigates to `/collection/adaptive-forms?applicationId={asset_id}`
2.  **Page Load:** `AdaptiveForms.tsx` component mounts, extracts `applicationId` from URL parameters
3.  **Blocker Check:** `useIncompleteCollectionFlows` hook checks for conflicting active flows
4.  **Flow Initialization:** `useAdaptiveFormFlow` creates collection flow with `selected_application_ids: [applicationId]`
5.  **MFO Trigger:** `POST /api/v1/collection/flows/{flow_id}/execute` starts CrewAI agents
6.  **Questionnaire Generation:** System attempts MFO questionnaire generation (10s timeout)
7.  **Bootstrap Fallback:** If MFO times out, generates bootstrap questionnaire with asset pre-population:
    ```python
    # Backend fetches asset details and pre-fills questionnaire
    selected_asset = get_asset_by_id(applicationId)
    bootstrap_questionnaire.questions["application_name"].default_value = selected_asset.name
    bootstrap_questionnaire.responses_collected["application_name"] = selected_asset.name
    ```
8.  **Form Rendering:** `AdaptiveFormContainer` renders form with pre-populated application name
9.  **Save Progress:** User clicks "Save Progress" → `POST /api/v1/collection/.../responses` with `asset_id` linkage
10. **Form Completion:** User submits final form → responses saved with proper asset relationship

### Scenario B: User Enters New Application Data

1.  **Direct Navigation:** User navigates directly to `/collection/adaptive-forms` (no applicationId)
2.  **Flow Creation:** Collection flow created without `selected_application_ids`
3.  **Bootstrap Questionnaire:** Generated without pre-population (empty application_name field)
4.  **Manual Entry:** User manually enters new application information
5.  **Response Storage:** Responses saved without `asset_id` linkage (flow-level only)
6.  **Future Enhancement:** Could auto-create asset record from questionnaire responses

---

## 4. Troubleshooting Breakpoints

| Breakpoint                        | Diagnostic Check                                                                                               | Platform-Specific Fix                                                                                             |
|-----------------------------------|----------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------|
| **Application Name Not Pre-filled** | Check browser developer tools: URL should contain `?applicationId={uuid}`. Check network tab for `/questionnaires` response - should include `responses_collected.application_name`. | Verify asset exists in database with correct `engagement_id`. Check backend logs for asset lookup failures in `get_adaptive_questionnaires`. Ensure collection flow has `selected_application_ids` in `collection_config`. |
| **Save Progress Button Not Working** | Check console for "Save Progress" debug logs and network tab for `POST .../responses` calls. Verify response includes asset validation messages. | Check backend logs in `submit_questionnaire_response` for asset validation errors. Ensure `applicationId` is passed in `form_metadata`. If asset_id validation fails, responses saved without asset linkage (not an error). |
| **Page Stuck Loading Questionnaires** | Check network tab for `/questionnaires` polling requests. Should fallback to bootstrap questionnaire within 10s if MFO times out. | Check MFO execution logs for CrewAI agent failures. Bootstrap questionnaire should always be returned as fallback - if not, check `get_adaptive_questionnaires` function errors. |
| **Form Submission 404 Asset Error** | Error indicates asset_id provided but asset not found or not accessible in current engagement scope. | Verify asset exists: `SELECT * FROM assets WHERE id = '{asset_id}' AND engagement_id = '{engagement_id}'`. Check multi-tenant isolation - asset must belong to same client_account_id and engagement_id. |
| **Responses Not Persisting** | Check that responses are being saved to `collection_questionnaire_responses` table with correct `collection_flow_id` and optional `asset_id`. | Verify database schema has `asset_id` column (migration 017). Check foreign key constraints. Ensure transaction commits in `submit_questionnaire_response`. |
| **Multiple Active Flows Error** | Database contains multiple non-completed collection flows for current engagement, blocking new flow creation. | Use flow management endpoints to clean up: `GET /api/v1/collection/flows/analysis` then `POST /api/v1/collection/flows/manage` with appropriate cleanup action. |

### Key Backend Log Patterns

```bash
# Asset pre-population success
"Pre-populating questionnaire with application: MyApp (ID: uuid-here)"

# Asset validation during save
"Linking questionnaire responses to existing asset: MyApp (ID: uuid-here)"
"No asset_id provided - questionnaire responses will be flow-level only"

# Bootstrap questionnaire fallback
"No questionnaires found yet for flow {flow_id}"
"Returning bootstrap questionnaire to enable in-form application selection"
```

---

## 5. Database Migration Requirements

### Required Migration: Add Asset-Questionnaire Relationship

**Migration File:** `backend/alembic/versions/017_add_asset_id_to_questionnaire_responses.py`

```sql
-- Add asset_id foreign key to collection_questionnaire_responses
ALTER TABLE migration.collection_questionnaire_responses 
ADD COLUMN asset_id UUID REFERENCES migration.assets(id) ON DELETE CASCADE;

-- Add performance indexes
CREATE INDEX ix_collection_questionnaire_responses_asset_id 
ON migration.collection_questionnaire_responses(asset_id);

CREATE INDEX ix_collection_questionnaire_responses_flow_asset 
ON migration.collection_questionnaire_responses(collection_flow_id, asset_id);
```

**Model Updates:**
- ✅ `CollectionQuestionnaireResponse.asset_id` - Optional foreign key to assets table
- ✅ `Asset.questionnaire_responses` - Back-reference to response records  
- ✅ Proper SQLAlchemy relationships for ORM queries

### Deployment Checklist

1. **Run Migration:** `alembic upgrade head` to add `asset_id` column
2. **Test Asset Linkage:** Verify responses can be linked to existing assets
3. **Test Standalone Mode:** Verify responses work without asset_id for new applications
4. **Verify Indexes:** Check query performance for asset-scoped response lookups
5. **Multi-tenant Validation:** Ensure asset validation respects client/engagement boundaries
