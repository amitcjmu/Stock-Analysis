
# E2E Data Flow Analysis: Attribute Mapping

**Analysis Date:** 2025-07-30
**Status:** Updated to reflect current implementation and known issues

This document provides a complete, end-to-end data flow analysis for the `Attribute Mapping` page, a critical phase in the discovery workflow where AI-powered agents suggest mappings between source data and the platform's schema.

**Core Architecture:**
*   **Orchestrator-Driven Phases:** The entire attribute mapping process is a distinct phase managed by the `MasterFlowOrchestrator`. The frontend does not drive phase transitions; it only provides input when requested.
*   **Phase Controller Execution:** Uses PhaseController to manage phase execution with pause/resume capabilities for user approval.
*   **Unified Discovery Flow:** Field mapping suggestions are generated by the UnifiedDiscoveryFlow's field_mapping_phase.
*   **Asynchronous Suggestion & Approval:** The flow first runs in a "suggestions-only" mode to populate the UI, then pauses. It only resumes and applies the mappings after receiving explicit user approval.

**RECENTLY FIXED:** 
The attribute mapping page was broken due to missing `discovery_flows` records. The MFO two-table design requires both master and child flow records. This has been fixed by restoring the DiscoveryFlowService call in flow_trigger_service.py.

---

## 1. Frontend: Review and Approval Interface

The `AttributeMapping` page is a user interface for reviewing, approving, or modifying the field mapping suggestions generated by the backend CrewAI agents.

### Key Components & Hooks
*   **Page Component:** `src/pages/discovery/AttributeMapping/index.tsx`
*   **Core Business Logic:** `src/hooks/discovery/useAttributeMappingLogic.ts`
*   **Flow Detection & State:** `useAttributeMappingFlowDetection` and `useUnifiedDiscoveryFlow` hooks.

### API Call Mapping Table

| #  | HTTP Call                                                           | Trigger                                                        | Key Parameters              | Expected Response                                                             | Current Status |
|----|---------------------------------------------------------------------|----------------------------------------------------------------|-----------------------------|-------------------------------------------------------------------------------|----------------|
| 1  | `GET /api/v1/data-import/latest-import`                             | Page load - gets the latest import for context                | `clientAccountId`, `engagementId` | Latest data import information                                          | ✅ Working     |
| 2  | `GET /api/v1/data-import/flow/{flowId}/import-data`                 | `useAttributeMappingLogic` (after flow detection).             | `flowId`                    | JSON object with import metadata and sample data for the identified flow.     | ✅ Fixed - DiscoveryFlow now created |
| 3  | `GET /api/v1/unified-discovery/flows/active`                                | Page load - gets active discovery flows                        | `clientAccountId`, `engagementId` | Active flows list                                                    | ✅ Working     |
| 4  | `GET /api/v1/data-import/critical-attributes-status`                | Gets field mapping status and critical attributes              | Context headers             | Field mapping analysis and agent insights                                     | ⚠️ Partial - Falls back to re-analysis |
| 5  | `GET /api/v1/agents/discovery/agent-questions?page=attribute_mapping` | Gets agent questions for the page                             | `page` param                | Agent questions for user guidance                                              | ✅ Working     |

---

## 2. Backend: Agentic Mapping and Decision-Making

The backend execution is a multi-step process orchestrated by the `MasterFlowOrchestrator`.

### Phase 1: Generating Suggestions (Field Mapping Phase)

1.  **Phase Controller Trigger:** When the discovery flow reaches the `field_mapping_suggestions` phase, the PhaseController executes the field mapping phase.
2.  **CrewAI Execution:**
    *   The `generate_field_mapping_suggestions` method in UnifiedDiscoveryFlow is called.
    *   The field_mapping_phase executor analyzes the validated data from the previous phase.
    *   Intelligent mapping helpers are used to suggest target fields based on source field names.
3.  **Phase Result:**
    *   The phase returns a PhaseExecutionResult with `requires_user_input=True`.
    *   This causes the PhaseController to pause execution.
4.  **State Update & Pause:**
    *   The suggestions are saved to the `import_field_mappings` table with `status='suggested'`.
    *   The flow's status is updated to `waiting_for_approval` in `crewai_flow_state_extensions`.
    *   An approval request notification is sent via agent-ui-bridge.

### Phase 2: Applying User Approval

1.  **Frontend Action:** The user reviews the suggestions in the UI and clicks "Approve Mappings."
2.  **API Call:** The frontend sends a resume request via `/api/v1/master-flows/{flowId}/resume`.
3.  **Flow Resumption:**
    *   The PhaseController resumes from `field_mapping_approval` phase.
    *   User input with approved mappings is provided.
    *   The flow proceeds to `data_cleansing` phase.

### Database Schema

| ORM Model         | PostgreSQL Table            | Relevant Columns                                                                     | Purpose in This Flow                                                                       | Current Status |
|-------------------|-----------------------------|--------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|----------------|
| `ImportFieldMapping`| `import_field_mappings`     | `source_field`, `target_field`, `confidence_score`, `status`, `master_flow_id` | Stores the suggestions from the agents and tracks user approvals.                           | ✅ Working     |
| `CrewAIFlowStateExtensions`| `crewai_flow_state_extensions` | `flow_id`, `flow_status` (`processing`, `waiting_for_approval`), `current_phase`, `phase_data` | The master record for the flow, used by the orchestrator to manage state.                  | ✅ Working     |
| `DiscoveryFlow`   | `discovery_flows`           | `flow_id`, `data_import_id`, `master_flow_id`, `field_mapping_completed` | Discovery-specific tracking table - part of MFO two-table design                           | ✅ Working     |
| `DataImport`      | `data_imports`              | `id`, `master_flow_id`, `status`                                                    | Links import data to the master flow                                                        | ✅ Working     |

---

## 3. End-to-End Flow Sequence

### Normal Flow Operation:
1.  **Backend (Initial Analysis):** The PhaseController executes field mapping suggestions phase. Results are stored, flow pauses with `waiting_for_approval`.
2.  **Frontend (Page Load):** User navigates to Attribute Mapping page, sees field mapping suggestions retrieved from both master and child flow records.
3.  **Frontend (User Action):** User reviews and approves mappings.
4.  **Backend (Resumption):** PhaseController resumes, applies mappings, proceeds to data cleansing.

### MFO Two-Table Design:
- **Master Table** (`crewai_flow_state_extensions`): Stores orchestration state, flow status, and phase data
- **Child Table** (`discovery_flows`): Stores discovery-specific fields like `data_import_id` and phase completion flags
- Both records are created during flow initialization to ensure proper operation

---

## 4. Troubleshooting Breakpoints

| Stage      | Potential Failure Point                                                                                               | Diagnostic Checks                                                                                                                                                                                                                                                                                  |
|------------|-----------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Frontend** | **No Suggestions Shown:** The page loads, but the mapping table is empty. <br/> **"Discovery flow not found" errors:** Multiple API calls fail with flow lookup errors.                                                                  | **Browser DevTools (Network Tab):** Check responses from `/flow/{flowId}/import-data` - returns 200 but with error message about discovery flow not found. The critical-attributes-status endpoint shows fallback behavior. |
| **Backend**  | **DiscoveryFlow lookup fails:** The code looks in wrong table (discovery_flows instead of crewai_flow_state_extensions). <br/> **Multiple fallback attempts:** System tries data_import_id, master_flow_id, and configuration lookups. | **Docker Logs:** See "Discovery flow not found" warnings followed by multiple lookup attempts. <br/> **Database:** Check `crewai_flow_state_extensions` table for the actual flow with given flow_id. The discovery_flows table may be empty or not have matching records. |
| **Database** | **Mappings Not Saved:** The suggestions from the agent crew are not correctly written to the `import_field_mappings` table. | **Direct DB Query:** Connect to the database (`docker exec -it migration_db psql ...`) and run `SELECT * FROM import_field_mappings WHERE data_import_id = 'your-import-id';` to see if the suggestions exist. |

---

## 5. Technical Implementation Details

### MFO Two-Table Design Pattern

The Discovery flow follows the Master Flow Orchestrator's two-table design pattern:

1. **Master Flow Creation**: The MasterFlowOrchestrator creates the orchestration record in `crewai_flow_state_extensions`
   ```python
   # In MasterFlowOrchestrator
   flow_result = await orchestrator.create_flow(
       flow_type="discovery",
       configuration=configuration,
       initial_state=initial_state,
       atomic=True
   )
   ```

2. **Child Flow Creation**: The flow-specific service creates the child record in `discovery_flows`
   ```python
   # In FlowTriggerService
   discovery_service = DiscoveryFlowService(db, context)
   await discovery_service.create_discovery_flow(
       flow_id=str(master_flow_id),
       master_flow_id=str(master_flow_id),
       data_import_id=data_import_id,
       raw_data=file_data
   )
   ```

3. **API Data Access**: The import storage handler queries the child table for discovery-specific data:
   ```python
   from app.models.discovery_flow import DiscoveryFlow
   flow_query = select(DiscoveryFlow).where(DiscoveryFlow.flow_id == flow_id)
   ```

### Why Both Tables Are Required

The two-table design serves specific purposes:
- **Master Table**: Generic flow orchestration, status tracking, phase management
- **Child Table**: Flow-type-specific data that doesn't fit the generic model
- **Separation of Concerns**: Keeps the master table clean while allowing flow-specific extensions

### Data Flow for Attribute Mapping

1. **PhaseController** reads from master table for orchestration state
2. **Import Storage Handler** reads from child table for `data_import_id`
3. **Field Mapping Service** reads from `import_field_mappings` using master flow ID
4. **UI Components** combine data from multiple sources for display 