#!/usr/bin/env python3
"""
Redis Security Audit Tool
Generated by CC DevSecOps Engineer

Comprehensive security audit for Redis deployments including:
- Configuration validation
- ACL verification
- Encryption checks
- Network security assessment
- Compliance reporting
"""

import asyncio
import json
import logging
import os
import sys
try:
    import yaml
    YAML_AVAILABLE = True
except ImportError:
    YAML_AVAILABLE = False
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict

# Add backend to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "backend"))

# Try to import settings, but fallback to defaults if not available
try:
    from app.core.config import settings
except ImportError:
    # Use defaults for CI environment
    class Settings:
        REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379/0")
        REDIS_ENABLED = os.getenv("REDIS_ENABLED", "true").lower() == "true"
        REDIS_PASSWORD = os.getenv("REDIS_PASSWORD", "")
    settings = Settings()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class SecurityIssue:
    """Security issue found during audit"""

    severity: str  # critical, high, medium, low
    category: str  # config, acl, network, encryption, etc.
    title: str
    description: str
    remediation: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    cve_reference: Optional[str] = None


@dataclass
class AuditReport:
    """Complete security audit report"""

    timestamp: str
    redis_version: Optional[str]
    deployment_type: str  # docker, upstash, standalone
    total_issues: int
    critical_issues: int
    high_issues: int
    medium_issues: int
    low_issues: int
    issues: List[SecurityIssue]
    compliance_score: float
    recommendations: List[str]


class RedisSecurityAuditor:
    """Comprehensive Redis security auditor"""

    def __init__(self):
        self.project_root = Path(__file__).parent.parent.parent
        self.issues: List[SecurityIssue] = []
        self.redis_config_path = self.project_root / "redis" / "redis.conf"
        self.acl_config_path = self.project_root / "redis" / "users.acl"
        self.docker_compose_paths = [
            self.project_root / "docker-compose.dev.yml",
            self.project_root / "docker-compose.prod.yml",
        ]

    async def run_full_audit(self) -> AuditReport:
        """Run complete security audit"""
        logger.info("üîç Starting Redis Security Audit")

        # Configuration audits
        await self.audit_redis_configuration()
        await self.audit_acl_configuration()
        await self.audit_docker_configuration()

        # Network security audits
        await self.audit_network_security()
        await self.audit_ssl_configuration()

        # Operational security audits
        await self.audit_logging_configuration()
        await self.audit_backup_security()
        await self.audit_monitoring_security()

        # Environment security
        await self.audit_environment_variables()
        await self.audit_container_security()

        # Generate report
        report = self._generate_report()

        logger.info(f"‚úÖ Audit complete: {report.total_issues} issues found")
        return report

    async def audit_redis_configuration(self):
        """Audit Redis configuration file for security issues"""
        logger.info("Auditing Redis configuration...")

        if not self.redis_config_path.exists():
            self.issues.append(
                SecurityIssue(
                    severity="critical",
                    category="config",
                    title="Missing Redis Configuration",
                    description="Redis configuration file not found",
                    remediation="Create secure Redis configuration file",
                    file_path=str(self.redis_config_path),
                )
            )
            return

        try:
            config_content = self.redis_config_path.read_text()
            config_lines = config_content.split("\n")

            # Check for password authentication
            if "requirepass" not in config_content:
                self.issues.append(
                    SecurityIssue(
                        severity="critical",
                        category="config",
                        title="Missing Password Authentication",
                        description="Redis is configured without password authentication",
                        remediation="Add 'requirepass ${REDIS_PASSWORD}' to configuration",
                        file_path=str(self.redis_config_path),
                    )
                )

            # Check for bind configuration
            bind_configured = False
            for i, line in enumerate(config_lines, 1):
                if line.strip().startswith("bind "):
                    bind_configured = True
                    if "0.0.0.0" in line:  # nosec
                        self.issues.append(
                            SecurityIssue(
                                severity="high",
                                category="config",
                                title="Insecure Bind Configuration",
                                description="Redis is configured to bind to all interfaces (0.0.0.0)",
                                remediation="Bind only to specific interfaces: 'bind 127.0.0.1 ::1'",
                                file_path=str(self.redis_config_path),
                                line_number=i,
                            )
                        )

            if not bind_configured:
                self.issues.append(
                    SecurityIssue(
                        severity="high",
                        category="config",
                        title="Missing Bind Configuration",
                        description="Redis bind configuration not specified",
                        remediation="Add 'bind 127.0.0.1 ::1' to limit network access",
                        file_path=str(self.redis_config_path),
                    )
                )

            # Check for protected mode
            if "protected-mode yes" not in config_content:
                self.issues.append(
                    SecurityIssue(
                        severity="high",
                        category="config",
                        title="Protected Mode Disabled",
                        description="Redis protected mode is not enabled",
                        remediation="Add 'protected-mode yes' to configuration",
                        file_path=str(self.redis_config_path),
                    )
                )

            # Check for dangerous commands
            dangerous_commands = [
                "FLUSHDB",
                "FLUSHALL",
                "KEYS",
                "CONFIG",
                "DEBUG",
                "EVAL",
                "SCRIPT",
            ]
            disabled_commands = set()

            for line in config_lines:
                if line.strip().startswith("rename-command"):
                    parts = line.split()
                    if len(parts) >= 3:
                        command = parts[1]
                        new_name = parts[2]
                        if new_name == '""':  # Disabled
                            disabled_commands.add(command)

            for command in dangerous_commands:
                if command not in disabled_commands:
                    self.issues.append(
                        SecurityIssue(
                            severity="medium",
                            category="config",
                            title=f"Dangerous Command Not Disabled: {command}",
                            description=f"Command {command} should be disabled or renamed",
                            remediation=f"Add 'rename-command {command} \"\"' to disable command",
                            file_path=str(self.redis_config_path),
                        )
                    )

            # Check for memory limits
            if "maxmemory " not in config_content:
                self.issues.append(
                    SecurityIssue(
                        severity="medium",
                        category="config",
                        title="Missing Memory Limit",
                        description="Redis memory limit not configured",
                        remediation="Add 'maxmemory 256mb' (adjust as needed)",
                        file_path=str(self.redis_config_path),
                    )
                )

            # Check for logging configuration
            if "logfile" not in config_content:
                self.issues.append(
                    SecurityIssue(
                        severity="low",
                        category="config",
                        title="Missing Log File Configuration",
                        description="Redis log file not configured",
                        remediation="Add 'logfile /var/log/redis/redis.log'",
                        file_path=str(self.redis_config_path),
                    )
                )

        except Exception as e:
            self.issues.append(
                SecurityIssue(
                    severity="high",
                    category="config",
                    title="Configuration File Read Error",
                    description=f"Failed to read Redis configuration: {e}",
                    remediation="Ensure Redis configuration file is readable",
                    file_path=str(self.redis_config_path),
                )
            )

    async def audit_acl_configuration(self):
        """Audit Redis ACL configuration"""
        logger.info("Auditing Redis ACL configuration...")

        if not self.acl_config_path.exists():
            self.issues.append(
                SecurityIssue(
                    severity="high",
                    category="acl",
                    title="Missing ACL Configuration",
                    description="Redis ACL configuration file not found",
                    remediation="Create ACL configuration file with user roles",
                    file_path=str(self.acl_config_path),
                )
            )
            return

        try:
            acl_content = self.acl_config_path.read_text()
            acl_lines = acl_content.split("\n")

            # Check if default user is disabled
            default_user_disabled = False
            for line in acl_lines:
                if line.strip().startswith("user default") and "off" in line:
                    default_user_disabled = True
                    break

            if not default_user_disabled:
                self.issues.append(
                    SecurityIssue(
                        severity="high",
                        category="acl",
                        title="Default User Not Disabled",
                        description="Default Redis user should be disabled in production",
                        remediation="Add 'user default off' to ACL configuration",
                        file_path=str(self.acl_config_path),
                    )
                )

            # Check for service-specific users
            required_users = ["app_service", "monitor_user", "backup_user"]
            defined_users = set()

            for line in acl_lines:
                if line.strip().startswith("user ") and not line.strip().startswith(
                    "user default"
                ):
                    user_name = line.split()[1]
                    defined_users.add(user_name)

            for required_user in required_users:
                if required_user not in defined_users:
                    self.issues.append(
                        SecurityIssue(
                            severity="medium",
                            category="acl",
                            title=f"Missing Service User: {required_user}",
                            description=f"Service user {required_user} not defined in ACL",
                            remediation=f"Define user {required_user} with appropriate permissions",
                            file_path=str(self.acl_config_path),
                        )
                    )

            # Check for password placeholders
            if "${" in acl_content:
                # Count password variables
                password_vars = acl_content.count("${")
                if password_vars < len(defined_users):
                    self.issues.append(
                        SecurityIssue(
                            severity="medium",
                            category="acl",
                            title="Hardcoded Passwords in ACL",
                            description="Some users may have hardcoded passwords",
                            remediation="Use environment variables for all passwords",
                            file_path=str(self.acl_config_path),
                        )
                    )

        except Exception as e:
            self.issues.append(
                SecurityIssue(
                    severity="medium",
                    category="acl",
                    title="ACL File Read Error",
                    description=f"Failed to read ACL configuration: {e}",
                    remediation="Ensure ACL configuration file is readable",
                    file_path=str(self.acl_config_path),
                )
            )

    async def audit_docker_configuration(self):
        """Audit Docker Compose configuration for Redis security"""
        logger.info("Auditing Docker configuration...")

        if not YAML_AVAILABLE:
            logger.warning("PyYAML not available, skipping Docker configuration audit")
            return

        for compose_path in self.docker_compose_paths:
            if not compose_path.exists():
                continue

            try:
                with open(compose_path, "r") as f:
                    compose_config = yaml.safe_load(f)

                redis_service = compose_config.get("services", {}).get("redis", {})
                if not redis_service:
                    continue

                # Check port binding
                ports = redis_service.get("ports", [])
                for port in ports:
                    if isinstance(port, str) and ":" in port:
                        host_binding = port.split(":")[0]
                        if host_binding not in ["127.0.0.1", "localhost"] or host_binding == "":
                            self.issues.append(
                                SecurityIssue(
                                    severity="high",
                                    category="network",
                                    title="Insecure Port Binding",
                                    description=f"Redis port bound to {host_binding or 'all interfaces'} instead of localhost",
                                    remediation="Bind Redis port to 127.0.0.1 only",
                                    file_path=str(compose_path),
                                )
                            )

                # Check for security options
                security_opt = redis_service.get("security_opt", [])
                if "no-new-privileges:true" not in security_opt:
                    self.issues.append(
                        SecurityIssue(
                            severity="medium",
                            category="container",
                            title="Missing Security Option",
                            description="Container missing 'no-new-privileges:true' security option",
                            remediation="Add 'no-new-privileges:true' to security_opt",
                            file_path=str(compose_path),
                        )
                    )

                # Check for resource limits
                deploy_config = redis_service.get("deploy", {})
                resources = deploy_config.get("resources", {})
                if not resources.get("limits"):
                    self.issues.append(
                        SecurityIssue(
                            severity="low",
                            category="container",
                            title="Missing Resource Limits",
                            description="Redis container has no resource limits configured",
                            remediation="Add memory and CPU limits to prevent resource exhaustion",
                            file_path=str(compose_path),
                        )
                    )

                # Check for read-only filesystem
                if redis_service.get("read_only") is True:
                    # This is actually good for security, but Redis needs write access to /data
                    tmpfs = redis_service.get("tmpfs", [])
                    if "/data" not in str(tmpfs) and "/var/log/redis" not in str(tmpfs):
                        self.issues.append(
                            SecurityIssue(
                                severity="medium",
                                category="container",
                                title="Read-Only Filesystem Without Write Mounts",
                                description="Container is read-only but lacks necessary write mounts",
                                remediation="Add tmpfs mounts for /data and /var/log/redis",
                                file_path=str(compose_path),
                            )
                        )

            except Exception as e:
                self.issues.append(
                    SecurityIssue(
                        severity="medium",
                        category="config",
                        title="Docker Compose Parse Error",
                        description=f"Failed to parse Docker Compose file: {e}",
                        remediation="Ensure Docker Compose file is valid YAML",
                        file_path=str(compose_path),
                    )
                )

    async def audit_network_security(self):
        """Audit network security configuration"""
        logger.info("Auditing network security...")

        if not YAML_AVAILABLE:
            logger.warning("PyYAML not available, skipping network security audit")
            return

        # Check for network isolation in Docker Compose
        for compose_path in self.docker_compose_paths:
            if not compose_path.exists():
                continue

            try:
                with open(compose_path, "r") as f:
                    compose_config = yaml.safe_load(f)

                networks = compose_config.get("networks", {})
                redis_service = compose_config.get("services", {}).get("redis", {})

                if redis_service:
                    service_networks = redis_service.get("networks", [])
                    if not service_networks:
                        self.issues.append(
                            SecurityIssue(
                                severity="medium",
                                category="network",
                                title="Missing Network Configuration",
                                description="Redis service not assigned to specific networks",
                                remediation="Assign Redis to dedicated network for isolation",
                                file_path=str(compose_path),
                            )
                        )

                    # Check for custom network configuration
                    for network_name in service_networks:
                        network_config = networks.get(network_name, {})
                        if not network_config.get("driver"):
                            self.issues.append(
                                SecurityIssue(
                                    severity="low",
                                    category="network",
                                    title="Default Network Driver",
                                    description=f"Network {network_name} using default driver",
                                    remediation="Explicitly specify network driver (bridge recommended)",
                                    file_path=str(compose_path),
                                )
                            )

            except Exception as e:
                logger.error(f"Error auditing network config in {compose_path}: {e}")

    async def audit_ssl_configuration(self):
        """Audit SSL/TLS configuration"""
        logger.info("Auditing SSL/TLS configuration...")

        # Check if SSL is configured in Redis config
        if self.redis_config_path.exists():
            config_content = self.redis_config_path.read_text()

            if "tls-port" not in config_content:
                self.issues.append(
                    SecurityIssue(
                        severity="medium",
                        category="encryption",
                        title="TLS Not Configured",
                        description="Redis TLS encryption is not configured",
                        remediation="Configure TLS for production deployments",
                        file_path=str(self.redis_config_path),
                    )
                )
            else:
                # Check for strong TLS configuration
                if "tls-protocols" in config_content:
                    config_lines = config_content.split('\n')
                    for line in config_lines:
                        line = line.strip()
                        if line.startswith('tls-protocols') and not line.startswith('#'):
                            if 'TLSv1.0' in line or 'TLSv1.1' in line:
                                self.issues.append(
                                    SecurityIssue(
                                        severity="high",
                                        category="encryption",
                                        title="Weak TLS Protocols",
                                        description="Weak TLS protocols (1.0/1.1) are enabled",
                                        remediation="Use only TLSv1.2 and TLSv1.3",
                                        file_path=str(self.redis_config_path),
                                    )
                                )
                                break

                # Check for certificate configuration
                if "tls-cert-file" not in config_content:
                    self.issues.append(
                        SecurityIssue(
                            severity="medium",
                            category="encryption",
                            title="Missing TLS Certificate Configuration",
                            description="TLS certificate file not configured",
                            remediation="Configure TLS certificate and key files",
                            file_path=str(self.redis_config_path),
                        )
                    )

    async def audit_logging_configuration(self):
        """Audit logging and monitoring configuration"""
        logger.info("Auditing logging configuration...")

        if self.redis_config_path.exists():
            config_content = self.redis_config_path.read_text()

            # Check for syslog
            if "syslog-enabled yes" not in config_content:
                self.issues.append(
                    SecurityIssue(
                        severity="low",
                        category="logging",
                        title="Syslog Not Enabled",
                        description="Redis syslog integration not enabled",
                        remediation="Enable syslog for centralized logging",
                        file_path=str(self.redis_config_path),
                    )
                )

            # Check for slow log configuration
            if "slowlog-log-slower-than" not in config_content:
                self.issues.append(
                    SecurityIssue(
                        severity="low",
                        category="logging",
                        title="Slow Log Not Configured",
                        description="Redis slow log not configured",
                        remediation="Configure slow log for performance monitoring",
                        file_path=str(self.redis_config_path),
                    )
                )

    async def audit_backup_security(self):
        """Audit backup security configuration"""
        logger.info("Auditing backup security...")

        # Check if backup scripts exist and are secure
        backup_scripts = [
            self.project_root / "scripts" / "backup-db.sh",
            self.project_root / "scripts" / "restore-db.sh",
        ]

        for script_path in backup_scripts:
            if script_path.exists():
                try:
                    script_content = script_path.read_text()

                    # Check for hardcoded credentials
                    if any(
                        cred in script_content.lower()
                        for cred in ["password=", "passwd=", "pwd="]
                    ):
                        self.issues.append(
                            SecurityIssue(
                                severity="high",
                                category="backup",
                                title="Hardcoded Credentials in Backup Script",
                                description=f"Backup script {script_path.name} contains hardcoded credentials",
                                remediation="Use environment variables for credentials",
                                file_path=str(script_path),
                            )
                        )

                    # Check for secure file permissions (if we could check them)
                    # This would require additional system calls

                except Exception as e:
                    logger.error(f"Error reading backup script {script_path}: {e}")

    async def audit_monitoring_security(self):
        """Audit monitoring and metrics security"""
        logger.info("Auditing monitoring security...")

        if not YAML_AVAILABLE:
            logger.warning("PyYAML not available, skipping monitoring security audit")
            return

        # Check for metrics exposure
        for compose_path in self.docker_compose_paths:
            if not compose_path.exists():
                continue

            try:
                with open(compose_path, "r") as f:
                    compose_config = yaml.safe_load(f)

                # Check Redis exporter configuration
                exporter_service = compose_config.get("services", {}).get(
                    "redis-exporter", {}
                )
                if exporter_service:
                    ports = exporter_service.get("ports", [])
                    for port in ports:
                        if isinstance(port, str) and ":" in port:
                            host_binding = port.split(":")[0]
                            if not host_binding or host_binding in ["0.0.0.0", ""]:  # nosec
                                self.issues.append(
                                    SecurityIssue(
                                        severity="medium",
                                        category="monitoring",
                                        title="Metrics Exposed to All Interfaces",
                                        description="Redis metrics endpoint accessible from all interfaces",
                                        remediation="Bind metrics endpoint to localhost only",
                                        file_path=str(compose_path),
                                    )
                                )

            except Exception as e:
                logger.error(f"Error auditing monitoring config in {compose_path}: {e}")

    async def audit_environment_variables(self):
        """Audit environment variable security"""
        logger.info("Auditing environment variables...")

        # Check for required Redis environment variables
        required_env_vars = [
            "REDIS_PASSWORD",
            "REDIS_APP_PASSWORD",
            "REDIS_ADMIN_PASSWORD",
        ]

        missing_vars = []
        for var in required_env_vars:
            if not os.getenv(var):
                missing_vars.append(var)

        if missing_vars:
            self.issues.append(
                SecurityIssue(
                    severity="critical",
                    category="config",
                    title="Missing Required Environment Variables",
                    description=f"Required environment variables not set: {', '.join(missing_vars)}",
                    remediation="Set all required environment variables with secure values",
                )
            )

        # Check for weak passwords (if set)
        for var in required_env_vars:
            value = os.getenv(var, "")
            if value and len(value) < 12:
                self.issues.append(
                    SecurityIssue(
                        severity="high",
                        category="config",
                        title=f"Weak Password: {var}",
                        description=f"Environment variable {var} has weak password (< 12 characters)",
                        remediation="Use strong passwords with at least 12 characters",
                    )
                )

    async def audit_container_security(self):
        """Audit container security configuration"""
        logger.info("Auditing container security...")

        # Check Dockerfile security (if it exists)
        dockerfile_paths = [
            self.project_root / "Dockerfile",
            self.project_root / "backend" / "Dockerfile",
        ]

        for dockerfile_path in dockerfile_paths:
            if dockerfile_path.exists():
                try:
                    dockerfile_content = dockerfile_path.read_text()

                    # Check for USER directive
                    if "USER " not in dockerfile_content:
                        self.issues.append(
                            SecurityIssue(
                                severity="medium",
                                category="container",
                                title="Missing USER Directive",
                                description=f"Dockerfile {dockerfile_path.name} runs as root",
                                remediation="Add USER directive to run as non-root user",
                                file_path=str(dockerfile_path),
                            )
                        )

                    # Check for COPY/ADD with proper permissions
                    lines = dockerfile_content.split("\n")
                    for i, line in enumerate(lines, 1):
                        if line.strip().startswith("COPY ") and "--chown=" not in line:
                            self.issues.append(
                                SecurityIssue(
                                    severity="low",
                                    category="container",
                                    title="COPY Without Ownership",
                                    description="COPY command without explicit ownership",
                                    remediation="Use --chown flag with COPY commands",
                                    file_path=str(dockerfile_path),
                                    line_number=i,
                                )
                            )

                except Exception as e:
                    logger.error(f"Error reading Dockerfile {dockerfile_path}: {e}")

    def _generate_report(self) -> AuditReport:
        """Generate comprehensive audit report"""
        # Count issues by severity
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for issue in self.issues:
            severity_counts[issue.severity] += 1

        # Calculate compliance score (100 - weighted issue score)
        issue_weights = {"critical": 25, "high": 10, "medium": 5, "low": 1}
        total_weight = sum(
            severity_counts[sev] * weight for sev, weight in issue_weights.items()
        )
        compliance_score = max(0, 100 - total_weight)

        # Generate recommendations
        recommendations = []
        if severity_counts["critical"] > 0:
            recommendations.append("Address all critical security issues immediately")
        if severity_counts["high"] > 0:
            recommendations.append(
                "Resolve high-severity issues before production deployment"
            )
        if compliance_score < 80:
            recommendations.append("Implement comprehensive security hardening")

        recommendations.extend(
            [
                "Regularly rotate Redis passwords and certificates",
                "Monitor Redis security logs for suspicious activity",
                "Implement network segmentation for Redis traffic",
                "Regular security audits and penetration testing",
            ]
        )

        return AuditReport(
            timestamp=datetime.utcnow().isoformat(),
            redis_version=None,  # Could be detected from Redis info
            deployment_type="docker",  # Based on presence of compose files
            total_issues=len(self.issues),
            critical_issues=severity_counts["critical"],
            high_issues=severity_counts["high"],
            medium_issues=severity_counts["medium"],
            low_issues=severity_counts["low"],
            issues=self.issues,
            compliance_score=compliance_score,
            recommendations=recommendations,
        )


async def main():
    """Main audit function"""
    auditor = RedisSecurityAuditor()
    report = await auditor.run_full_audit()

    # Output report
    print("\n" + "=" * 80)
    print("REDIS SECURITY AUDIT REPORT")
    print("=" * 80)

    print(f"Timestamp: {report.timestamp}")
    print(f"Deployment Type: {report.deployment_type}")
    print(f"Compliance Score: {report.compliance_score:.1f}/100")
    print()

    print("ISSUE SUMMARY:")
    print(f"  Critical: {report.critical_issues}")
    print(f"  High:     {report.high_issues}")
    print(f"  Medium:   {report.medium_issues}")
    print(f"  Low:      {report.low_issues}")
    print(f"  Total:    {report.total_issues}")
    print()

    if report.issues:
        print("DETAILED ISSUES:")
        print("-" * 50)

        for issue in sorted(
            report.issues,
            key=lambda x: {"critical": 0, "high": 1, "medium": 2, "low": 3}[x.severity],
        ):
            severity_icon = {
                "critical": "üî¥",
                "high": "üü†",
                "medium": "üü°",
                "low": "üîµ",
            }[issue.severity]

            print(f"{severity_icon} [{issue.severity.upper()}] {issue.title}")
            print(f"   Category: {issue.category}")
            print(f"   Description: {issue.description}")
            print(f"   Remediation: {issue.remediation}")
            if issue.file_path:
                location = issue.file_path
                if issue.line_number:
                    location += f":{issue.line_number}"
                print(f"   Location: {location}")
            print()

    print("RECOMMENDATIONS:")
    for i, rec in enumerate(report.recommendations, 1):
        print(f"  {i}. {rec}")

    # Save report to file
    report_file = Path("redis_security_audit_report.json")
    with open(report_file, "w") as f:
        json.dump(asdict(report), f, indent=2)

    print(f"\nüìä Full report saved to: {report_file}")

    # Exit with appropriate code
    if report.critical_issues > 0:
        print("\nüö® CRITICAL ISSUES FOUND - Deployment not recommended")
        sys.exit(2)
    elif report.high_issues > 0:
        print("\n‚ö†Ô∏è  HIGH PRIORITY ISSUES - Review before production")
        sys.exit(1)
    else:
        print("\n‚úÖ No critical or high-priority security issues found")
        sys.exit(0)


if __name__ == "__main__":
    asyncio.run(main())
