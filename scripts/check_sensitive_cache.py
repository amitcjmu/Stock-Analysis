#!/usr/bin/env python3
"""
Sensitive Data Cache Checker for AI Force Migration Platform
Generated by CC DevSecOps Engineer

This script scans for potential sensitive data exposure in cache operations:
- PII (Personally Identifiable Information)
- Authentication tokens and secrets
- Financial and healthcare data
- Regulatory compliance violations
- Unencrypted sensitive data in cache
"""

import ast
import sys
import re
from pathlib import Path
from typing import List, Dict, Any, Set, Pattern
import json


class SensitiveDataChecker(ast.NodeVisitor):
    """Check for sensitive data exposure in cache operations"""

    def __init__(self):
        self.violations: List[Dict[str, Any]] = []
        self.current_file: str = ""

        # Comprehensive sensitive data patterns
        self.sensitive_patterns = {
            'credentials': {
                'password', 'passwd', 'pwd', 'secret', 'api_key', 'access_token',
                'refresh_token', 'bearer_token', 'session_token', 'csrf_token',
                'jwt', 'oauth', 'saml', 'private_key', 'public_key',
                'certificate', 'cert', 'credential'
            },
            'pii': {
                'ssn', 'social_security', 'social_security_number', 'sin',
                'email', 'phone', 'telephone', 'mobile', 'address',
                'street', 'zip', 'postal', 'first_name', 'last_name',
                'full_name', 'birth_date', 'birthday', 'dob',
                'driver_license', 'passport', 'national_id'
            },
            'financial': {
                'credit_card', 'card_number', 'cc_number', 'cvv', 'cvc',
                'bank_account', 'routing_number', 'iban', 'swift',
                'payment', 'billing', 'invoice', 'salary', 'wage'
            },
            'healthcare': {
                'medical_record', 'patient_id', 'diagnosis', 'medication',
                'treatment', 'health_record', 'hipaa', 'phi'
            },
            'security': {
                'encryption_key', 'signing_key', 'hmac_key', 'aes_key',
                'rsa_key', 'signature', 'nonce', 'salt'
            }
        }

        # Regex patterns for detecting sensitive data formats
        self.regex_patterns = {
            'ssn': re.compile(r'\b\d{3}-?\d{2}-?\d{4}\b'),
            'credit_card': re.compile(r'\b(?:\d{4}[-\s]?){3}\d{4}\b'),
            'email': re.compile(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'),
            'phone': re.compile(r'\b\d{3}-?\d{3}-?\d{4}\b|\b\(\d{3}\)\s?\d{3}-?\d{4}\b'),
            'token': re.compile(r'\b[A-Za-z0-9]{32,}\b'),  # Long alphanumeric strings
            'api_key': re.compile(r'\b(?:sk_|pk_|key_)[A-Za-z0-9]{20,}\b')
        }

        # Cache operations to monitor
        self.cache_operations = {
            'set', 'setex', 'setnx', 'mset', 'hset', 'hmset', 'hsetex',
            'zadd', 'sadd', 'lpush', 'rpush', 'cache_set', 'cache_store',
            'put', 'store', 'save', 'persist'
        }

        # Safe encryption indicators
        self.encryption_indicators = {
            'encrypt', 'encrypted', 'cipher', 'encode', 'encoded', 'hash',
            'hashed', 'secure', 'protected', 'safe', 'anonymize', 'redact'
        }

    def visit_Call(self, node):
        """Check function calls for sensitive data caching"""
        try:
            if self._is_cache_operation(node):
                self._check_cache_operation(node)
            elif self._is_logging_operation(node):
                self._check_logging_operation(node)
        except Exception:
            pass

        self.generic_visit(node)

    def visit_Assign(self, node):
        """Check variable assignments for sensitive data patterns"""
        try:
            # Check if assigning to cache-related variables
            for target in node.targets:
                if isinstance(target, ast.Name) and 'cache' in target.id.lower():
                    if self._contains_sensitive_data(node.value):
                        self._add_violation(
                            node.lineno, 'sensitive_cache_assignment',
                            f'Sensitive data assigned to cache variable "{target.id}"'
                        )
        except Exception:
            pass

        self.generic_visit(node)

    def _is_cache_operation(self, node: ast.Call) -> bool:
        """Check if this is a cache operation"""
        try:
            if isinstance(node.func, ast.Attribute):
                obj_name = ""
                if isinstance(node.func.value, ast.Name):
                    obj_name = node.func.value.id.lower()
                method_name = node.func.attr.lower()

                # Check for cache objects and methods
                if any(cache_term in obj_name for cache_term in ['cache', 'redis', 'memcache']):
                    return any(op in method_name for op in self.cache_operations)

                return any(op in method_name for op in self.cache_operations)
        except Exception:
            pass
        return False

    def _is_logging_operation(self, node: ast.Call) -> bool:
        """Check if this is a logging operation that might expose sensitive data"""
        try:
            if isinstance(node.func, ast.Attribute):
                obj_name = ""
                if isinstance(node.func.value, ast.Name):
                    obj_name = node.func.value.id.lower()
                method_name = node.func.attr.lower()

                return 'log' in obj_name and method_name in ['info', 'debug', 'error', 'warning']
        except Exception:
            pass
        return False

    def _check_cache_operation(self, node: ast.Call):
        """Check cache operations for sensitive data"""
        for i, arg in enumerate(node.args):
            if self._contains_sensitive_data(arg):
                # Check if data appears to be encrypted
                if not self._appears_encrypted(arg, node):
                    severity = self._get_sensitivity_level(arg)
                    self._add_violation(
                        node.lineno, f'unencrypted_sensitive_cache_{severity}',
                        f'Potential {severity} data in cache operation - ensure encryption'
                    )

    def _check_logging_operation(self, node: ast.Call):
        """Check logging operations for sensitive data exposure"""
        # Skip if this appears to be operational logging
        if self._is_operational_logging(node):
            return

        for arg in node.args:
            if self._contains_sensitive_data(arg):
                self._add_violation(
                    node.lineno, 'sensitive_data_logging',
                    'Potential sensitive data in log statement - avoid logging PII/credentials'
                )

    def _is_operational_logging(self, node: ast.Call) -> bool:
        """Check if this appears to be operational/diagnostic logging rather than sensitive data"""
        try:
            # Check for operational logging patterns in arguments
            for arg in node.args:
                if isinstance(arg, (ast.Constant, ast.JoinedStr)):
                    # Get string content from f-strings and regular strings
                    content = ""
                    if isinstance(arg, ast.Constant) and isinstance(arg.value, str):
                        content = arg.value.lower()
                    elif isinstance(arg, ast.JoinedStr):
                        # For f-strings, check the constant parts
                        for value in arg.values:
                            if isinstance(value, ast.Constant) and isinstance(value.value, str):
                                content += value.value.lower()

                    # Operational logging patterns
                    operational_patterns = [
                        'testing ', 'checking ', 'validating ', 'scanning ',
                        'starting ', 'completed ', 'finished ', 'running ',
                        'error occurred', 'exception:', 'failed to', 'unable to',
                        'security test', 'vulnerability scan', 'deployment',
                        'operational data', 'not sensitive', 'error type',
                        'test failed', 'scan complete', 'check passed',
                        # Additional patterns for database and flow operations
                        'data cleansing', 'field mapping', 'asset inventory',
                        'migration', 'workflow', 'discovery flow', 'flow phase',
                        'table structure', 'database', 'columns', 'business rules',
                        'adding ', 'updated ', 'creating ', 'processing ',
                        'deploying ', 'health checks', 'performance metrics',
                        'missing ', 'found ', 'phase ', 'progress', 'status',
                        'crewai', 'flow id', 'single source', 'ecosystem integration',
                        'multi-tenant', 'demo data', 'validation', 'raw records',
                        'import=', 'mapping=', 'cleansing=', 'phases:', 'attribute',
                        'workflow_states', 'missing columns', 'core tables', 'alembic',
                        'environment variables', 'diagnosis summary', 'fix strategy',
                        'rolling update', 'single source of truth', 'achievements',
                        'api key is configured', 'api key is missing', 'deepinfra',
                        'configured', 'missing', 'credentials check failed',
                        'check failed', 'error type', 'only logging error'
                    ]

                    if any(pattern in content for pattern in operational_patterns):
                        return True

            return False
        except Exception:
            return False

    def _contains_sensitive_data(self, node: ast.AST) -> bool:
        """Check if AST node contains sensitive data patterns"""
        try:
            if isinstance(node, ast.Constant):
                return self._is_sensitive_value(node.value)
            elif isinstance(node, ast.Name):
                return self._is_sensitive_identifier(node.id)
            elif isinstance(node, ast.Attribute):
                return self._is_sensitive_identifier(node.attr)
            elif isinstance(node, ast.Dict):
                return self._check_dict_for_sensitive_data(node)
            elif isinstance(node, ast.List) or isinstance(node, ast.Tuple):
                return any(self._contains_sensitive_data(elt) for elt in node.elts)
            elif isinstance(node, ast.JoinedStr):
                return self._check_f_string_for_sensitive_data(node)
            elif isinstance(node, ast.Call):
                # Check function calls that might return sensitive data
                return self._is_sensitive_function_call(node)
        except Exception:
            pass
        return False

    def _is_sensitive_value(self, value: Any) -> bool:
        """Check if a value contains sensitive data"""
        if not isinstance(value, str):
            return False

        value_lower = value.lower()

        # Check against sensitive word patterns
        for category, patterns in self.sensitive_patterns.items():
            if any(pattern in value_lower for pattern in patterns):
                return True

        # Check against regex patterns
        for pattern_name, regex in self.regex_patterns.items():
            if regex.search(value):
                return True

        return False

    def _is_sensitive_identifier(self, identifier: str) -> bool:
        """Check if an identifier suggests sensitive data"""
        id_lower = identifier.lower()

        # Skip common false positives including operational logging contexts
        safe_contexts = [
            'cache_key', 'redis_key', 'lookup_key', 'index_key', 'sort_key',
            'primary_key', 'foreign_key', 'partition_key', 'composite_key',
            'secret_name', 'secret_type', 'secret_manager', 'secret_config',
            'token_type', 'token_name', 'token_config', 'token_manager',
            'key_name', 'key_type', 'key_config', 'key_manager',
            'error_type', 'exception_type', 'test_type', 'scan_type',
            'check_type', 'validation_type', 'operational_type',
            'log_type', 'security_type', 'auth_type', 'system_type'
        ]

        if any(safe in id_lower for safe in safe_contexts):
            return False

        for category, patterns in self.sensitive_patterns.items():
            if any(pattern in id_lower for pattern in patterns):
                return True

        return False

    def _check_dict_for_sensitive_data(self, node: ast.Dict) -> bool:
        """Check dictionary for sensitive keys or values"""
        try:
            # Check keys
            for key in node.keys:
                if key and isinstance(key, ast.Constant):
                    if self._is_sensitive_value(key.value):
                        return True

            # Check values
            for value in node.values:
                if self._contains_sensitive_data(value):
                    return True
        except Exception:
            pass
        return False

    def _check_f_string_for_sensitive_data(self, node: ast.JoinedStr) -> bool:
        """Check f-string for sensitive data patterns"""
        try:
            for value in node.values:
                if isinstance(value, ast.Constant):
                    if self._is_sensitive_value(value.value):
                        return True
                elif isinstance(value, ast.FormattedValue):
                    if self._contains_sensitive_data(value.value):
                        return True
        except Exception:
            pass
        return False

    def _is_sensitive_function_call(self, node: ast.Call) -> bool:
        """Check if function call might return sensitive data"""
        try:
            func_name = ""
            if isinstance(node.func, ast.Name):
                func_name = node.func.id.lower()
            elif isinstance(node.func, ast.Attribute):
                func_name = node.func.attr.lower()

            # Functions that commonly return sensitive data
            sensitive_functions = {
                'get_password', 'get_token', 'get_secret', 'get_key',
                'authenticate', 'login', 'get_credentials', 'decrypt'
            }

            return any(sens_func in func_name for sens_func in sensitive_functions)
        except Exception:
            pass
        return False

    def _appears_encrypted(self, node: ast.AST, context_node: ast.Call) -> bool:
        """Check if data appears to be encrypted or properly secured"""
        try:
            # Check if the cache operation includes encryption indicators
            for arg in context_node.args:
                if isinstance(arg, ast.Name) and any(
                    indicator in arg.id.lower() for indicator in self.encryption_indicators
                ):
                    return True

            # Check if the function call includes encryption methods
            if isinstance(context_node.func, ast.Attribute):
                method_name = context_node.func.attr.lower()
                if any(indicator in method_name for indicator in self.encryption_indicators):
                    return True

            # Check for encryption wrapper functions
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    func_name = node.func.id.lower()
                    if any(indicator in func_name for indicator in self.encryption_indicators):
                        return True
        except Exception:
            pass
        return False

    def _get_sensitivity_level(self, node: ast.AST) -> str:
        """Determine the sensitivity level of the data"""
        try:
            node_str = ast.unparse(node).lower()

            # Critical level
            if any(pattern in node_str for pattern in
                   self.sensitive_patterns['credentials'] | self.sensitive_patterns['security']):
                return 'critical'

            # High level
            if any(pattern in node_str for pattern in
                   self.sensitive_patterns['financial'] | self.sensitive_patterns['healthcare']):
                return 'high'

            # Medium level
            if any(pattern in node_str for pattern in self.sensitive_patterns['pii']):
                return 'medium'
        except Exception:
            pass

        return 'medium'

    def _add_violation(self, line_no: int, violation_type: str, message: str):
        """Add a violation to the list"""
        severity = 'critical' if 'critical' in violation_type else \
                  'high' if 'high' in violation_type else 'medium'

        self.violations.append({
            'file': self.current_file,
            'line': line_no,
            'severity': severity,
            'type': violation_type,
            'message': message
        })


def scan_file(file_path: Path) -> List[Dict]:
    """Scan a file for sensitive data exposure"""
    checker = SensitiveDataChecker()
    checker.current_file = str(file_path)

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Skip files that don't contain cache or logging operations
        if not any(term in content.lower() for term in
                  ['cache', 'redis', 'log', 'print', 'store', 'save']):
            return []

        tree = ast.parse(content, filename=str(file_path))
        checker.visit(tree)

    except SyntaxError:
        # Skip files with syntax errors
        pass
    except Exception:
        # Skip files that can't be processed
        pass

    return checker.violations


def scan_typescript_files(project_root: Path) -> List[Dict]:
    """Basic scan of TypeScript files for sensitive data patterns"""
    violations = []

    src_dir = project_root / "src"
    if not src_dir.exists():
        return violations

    # Patterns for TypeScript/JavaScript
    ts_sensitive_patterns = [
        r'localStorage\.setItem\([^)]*(?:password|token|secret|key)[^)]*\)',
        r'sessionStorage\.setItem\([^)]*(?:password|token|secret|key)[^)]*\)',
        r'console\.log\([^)]*(?:password|token|secret|key)[^)]*\)',
        r'cache\.set\([^)]*(?:password|token|secret|ssn|credit)[^)]*\)'
    ]

    for ts_file in src_dir.rglob("*.ts"):
        if "node_modules" in str(ts_file):
            continue

        try:
            with open(ts_file, 'r', encoding='utf-8') as f:
                content = f.read()

            for i, line in enumerate(content.split('\n'), 1):
                for pattern in ts_sensitive_patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        violations.append({
                            'file': str(ts_file),
                            'line': i,
                            'severity': 'high',
                            'type': 'frontend_sensitive_data',
                            'message': 'Potential sensitive data in frontend code'
                        })
        except Exception:
            pass

    return violations


def main():
    """Main function to run sensitive data checks"""
    project_root = Path(__file__).parent.parent
    all_violations = []

    # Scan Python files
    backend_dir = project_root / "backend"
    if backend_dir.exists():
        for py_file in backend_dir.rglob("*.py"):
            # Skip backup files, venv, cache, migrations, test files, and temporary files
            if any(skip in str(py_file) for skip in [
                "venv", "__pycache__", "migrations", "backup", "backups",
                ".backup", "_backup", "alembic_versions_backup", "temp", "archive",
                "test_", "tests"
            ]):
                continue
            violations = scan_file(py_file)
            all_violations.extend(violations)

    # Scan TypeScript files
    ts_violations = scan_typescript_files(project_root)
    all_violations.extend(ts_violations)

    # Group violations by severity
    critical = [v for v in all_violations if v['severity'] == 'critical']
    high = [v for v in all_violations if v['severity'] == 'high']
    medium = [v for v in all_violations if v['severity'] == 'medium']

    # Report results
    if critical:
        print("üö® CRITICAL SENSITIVE DATA VIOLATIONS:")
        for violation in critical:
            print(f"  {violation['file']}:{violation['line']} - {violation['message']}")
        print()

    if high:
        print("‚ùå HIGH SENSITIVITY VIOLATIONS:")
        for violation in high:
            print(f"  {violation['file']}:{violation['line']} - {violation['message']}")
        print()

    if medium:
        print("‚ö†Ô∏è  MEDIUM SENSITIVITY WARNINGS:")
        for violation in medium:
            print(f"  {violation['file']}:{violation['line']} - {violation['message']}")
        print()

    if not all_violations:
        print("‚úÖ No sensitive data exposure detected")

    # Print security guidelines
    print("\nüîí Sensitive Data Security Guidelines:")
    print("  ‚úì Encrypt all PII, credentials, and financial data before caching")
    print("  ‚úì Use secure key derivation for encryption keys")
    print("  ‚úì Never log passwords, tokens, or personal information")
    print("  ‚úì Implement data retention and deletion policies")
    print("  ‚úì Use data classification levels (Public, Internal, Confidential, Restricted)")
    print("  ‚úì Regular security audits and penetration testing")

    # Exit with error if critical/high violations found
    if critical or high:
        print(f"\nüö® Found {len(critical)} critical and {len(high)} high-severity violations")
        sys.exit(1)

    if medium:
        print(f"\n‚ö†Ô∏è  Found {len(medium)} medium-severity warnings for review")

    print("\nüìã Sensitive Data Check Complete")


if __name__ == "__main__":
    main()
