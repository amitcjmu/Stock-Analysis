#!/usr/bin/env python3
"""
Cache Security Checker for AI Force Migration Platform
Generated by CC DevSecOps Engineer

This script validates cache-related code for security issues including:
- Unencrypted sensitive data in cache operations
- Improper cache key formats
- Missing tenant isolation
- Dangerous cache operations
"""

import ast
import sys
import re
from pathlib import Path
from typing import List, Dict, Any, Set
import json


class CacheSecurityChecker(ast.NodeVisitor):
    """Check for security issues in cache-related code"""

    def __init__(self):
        self.errors: List[Dict[str, Any]] = []
        self.warnings: List[Dict[str, Any]] = []
        self.current_file: str = ""
        self.sensitive_fields = {
            'password', 'passwd', 'secret', 'token', 'key', 'api_key',
            'access_token', 'refresh_token', 'auth_token', 'bearer_token',
            'ssn', 'social_security', 'credit_card', 'card_number',
            'cvv', 'pin', 'private_key', 'certificate', 'credential',
            'session_id', 'session_token', 'csrf_token', 'jwt',
            'encryption_key', 'signing_key', 'hmac_key'
        }
        self.cache_operations = {
            'set', 'setex', 'setnx', 'mset', 'hset', 'hmset', 'hsetex',
            'zadd', 'sadd', 'lpush', 'rpush', 'cache_set', 'cache_store'
        }
        # Operations where the first argument is a cache key
        self.key_operations = {
            'set', 'setex', 'setnx', 'get', 'delete', 'del', 'exists',
            'expire', 'ttl', 'cache_set', 'cache_get', 'cache_delete'
        }

    def visit_Call(self, node):
        """Check function calls for cache security issues"""
        try:
            # Skip FastAPI route decorators
            if isinstance(node.func, ast.Attribute) and node.func.attr in [
                'get', 'post', 'put', 'delete', 'patch', 'options', 'head'
            ]:
                return

            # Check Redis/cache operations
            if self._is_cache_operation(node):
                self._check_cache_operation_security(node)
                # Only check for sensitive data in cache operations
                self._check_function_arguments(node)

        except Exception as e:
            # Don't fail the check for AST parsing errors
            pass

        self.generic_visit(node)

    def visit_Assign(self, node):
        """Check variable assignments for cache-related security issues"""
        try:
            if isinstance(node.value, ast.Call):
                # Check if assigning result of cache operation
                if self._is_cache_operation(node.value):
                    self._check_cache_assignment(node)
        except Exception:
            pass

        self.generic_visit(node)

    def _is_cache_operation(self, node: ast.Call) -> bool:
        """Check if this is a cache-related operation"""
        if isinstance(node.func, ast.Attribute):
            func_name = node.func.attr.lower()
            # Skip telemetry and instrumentation calls
            if func_name in ['set_attribute', 'log', 'info', 'debug', 'error', 'warning']:
                return False

            obj_name = ""
            if isinstance(node.func.value, ast.Name):
                obj_name = node.func.value.id.lower()

            # Skip dictionary operations that aren't cache operations
            if func_name in ['setdefault', 'get', 'pop', 'update'] and obj_name not in ['cache', 'redis']:
                return False

            # ONLY consider cache operations on actual cache/redis objects
            # This prevents flagging dictionary access like data["key"] or cached_data.get()
            if 'cache' in obj_name or 'redis' in obj_name:
                return any(op in func_name for op in self.cache_operations)

            # For all other objects, be very strict - only explicit cache function names
            cache_specific_methods = {'cache_set', 'cache_store', 'cache_get', 'cache_delete'}
            return func_name in cache_specific_methods

        elif isinstance(node.func, ast.Name):
            func_name = node.func.id.lower()
            # Skip secure_setattr - it's not a cache operation
            if func_name == 'secure_setattr':
                return False
            # Only flag standalone function calls with explicit cache names
            cache_specific_functions = {'cache_set', 'cache_store', 'cache_get', 'cache_delete'}
            return func_name in cache_specific_functions

        return False

    def _check_cache_operation_security(self, node: ast.Call):
        """Check cache operations for security issues"""
        try:
            # Only check cache key format for operations that use keys
            func_name = ""
            if isinstance(node.func, ast.Attribute):
                func_name = node.func.attr.lower()
            elif isinstance(node.func, ast.Name):
                func_name = node.func.id.lower()

            # Check cache key format only for key operations
            if node.args and any(op in func_name for op in self.key_operations):
                first_arg = node.args[0]
                if isinstance(first_arg, ast.Constant) and isinstance(first_arg.value, str):
                    # Only validate if it looks like a cache key (not an environment variable or configuration)
                    key_str = first_arg.value
                    # Extended list of patterns that are NOT cache keys
                    non_cache_patterns = [
                        'OTEL_', 'ENV_', 'DEBUG', 'PRODUCTION', 'DEVELOPMENT', 'LOG_LEVEL',
                        'sqlalchemy.', 'database_url', 'DATABASE_URL',
                        'http.', 'cache.enabled', 'cache.disabled', 'content-type',
                        'pytest', 'test_', '__file__', '__name__', '__main__'
                    ]
                    if not any(pattern in key_str for pattern in non_cache_patterns):
                        self._validate_cache_key_format(key_str, node.lineno)
                elif isinstance(first_arg, ast.JoinedStr) or isinstance(first_arg, ast.BinOp):
                    # f-string or string concatenation - harder to validate statically
                    self.warnings.append({
                        'file': self.current_file,
                        'line': node.lineno,
                        'type': 'dynamic_cache_key',
                        'message': 'Dynamic cache key detected - ensure it includes version and tenant isolation'
                    })

            # Check for sensitive data in cache values
            if len(node.args) > 1:
                value_arg = node.args[1]
                if self._contains_sensitive_data(value_arg):
                    self.errors.append({
                        'file': self.current_file,
                        'line': node.lineno,
                        'type': 'sensitive_data_caching',
                        'message': 'Sensitive data must be encrypted before caching'
                    })

        except Exception:
            pass

    def _check_cache_assignment(self, node: ast.Assign):
        """Check cache result assignments"""
        try:
            # Check if cached data is used without validation
            for target in node.targets:
                if isinstance(target, ast.Name):
                    var_name = target.id.lower()
                    if any(sensitive in var_name for sensitive in self.sensitive_fields):
                        self.warnings.append({
                            'file': self.current_file,
                            'line': node.lineno,
                            'type': 'sensitive_cache_assignment',
                            'message': f'Sensitive variable "{target.id}" assigned from cache - ensure validation'
                        })
        except Exception:
            pass

    def _check_function_arguments(self, node: ast.Call):
        """Check function arguments for sensitive data patterns"""
        try:
            for arg in node.args:
                if self._contains_sensitive_data(arg):
                    # Check if this is not in an encryption call
                    func_name = ""
                    if isinstance(node.func, ast.Attribute):
                        func_name = node.func.attr.lower()
                    elif isinstance(node.func, ast.Name):
                        func_name = node.func.id.lower()

                    if not any(enc in func_name for enc in ['encrypt', 'hash', 'encode', 'secure']):
                        self.warnings.append({
                            'file': self.current_file,
                            'line': node.lineno,
                            'type': 'potential_sensitive_data',
                            'message': 'Potential sensitive data in function call - verify encryption if caching'
                        })
        except Exception:
            pass

    def _validate_cache_key_format(self, key: str, line_no: int):
        """Validate cache key follows security conventions"""
        # Cache key should include version prefix
        if not re.match(r'^v\d+:', key):
            self.errors.append({
                'file': self.current_file,
                'line': line_no,
                'type': 'missing_version_prefix',
                'message': f'Cache key "{key}" must start with version prefix (e.g., "v1:")'
            })

        # Check for tenant isolation in user-related keys
        if any(user_term in key.lower() for user_term in ['user', 'client', 'tenant', 'account']):
            if 'tenant:' not in key and 'client:' not in key:
                self.errors.append({
                    'file': self.current_file,
                    'line': line_no,
                    'type': 'missing_tenant_isolation',
                    'message': f'Cache key "{key}" for user data must include tenant context'
                })

        # Check for dangerous patterns
        if any(dangerous in key for dangerous in ['*', '?', '[', ']', '{', '}']):
            self.errors.append({
                'file': self.current_file,
                'line': line_no,
                'type': 'dangerous_key_pattern',
                'message': f'Cache key "{key}" contains dangerous characters'
            })

    def _contains_sensitive_data(self, node: ast.AST) -> bool:
        """Check if AST node might contain sensitive data"""
        try:
            if isinstance(node, ast.Constant) and isinstance(node.value, str):
                return self._is_sensitive_string(node.value)
            elif isinstance(node, ast.Name):
                return any(field in node.id.lower() for field in self.sensitive_fields)
            elif isinstance(node, ast.Attribute):
                return any(field in node.attr.lower() for field in self.sensitive_fields)
            elif isinstance(node, ast.Dict):
                # Check dictionary keys and values
                for key, value in zip(node.keys, node.values):
                    if key and isinstance(key, ast.Constant):
                        if self._is_sensitive_string(str(key.value)):
                            return True
                    if self._contains_sensitive_data(value):
                        return True
            elif isinstance(node, ast.JoinedStr):
                # f-string - check for sensitive patterns
                node_str = ast.unparse(node).lower()
                return any(field in node_str for field in self.sensitive_fields)
        except Exception:
            pass
        return False

    def _is_sensitive_string(self, text: str) -> bool:
        """Check if string contains sensitive field names"""
        text_lower = text.lower()
        return any(field in text_lower for field in self.sensitive_fields)


def scan_file(file_path: Path) -> tuple[List[Dict], List[Dict]]:
    """Scan a single file for cache security issues"""
    checker = CacheSecurityChecker()
    checker.current_file = str(file_path)

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Only process files that likely contain cache operations
        if not any(cache_term in content.lower() for cache_term in
                  ['redis', 'cache', 'memcache', 'set', 'get', 'store']):
            return [], []

        tree = ast.parse(content, filename=str(file_path))
        checker.visit(tree)

    except SyntaxError:
        # Skip files with syntax errors
        pass
    except Exception:
        # Skip files that can't be processed
        pass

    return checker.errors, checker.warnings


def load_exclusions(project_root: Path) -> Set[str]:
    """Load exclusion patterns from .cache-security-exclude file"""
    exclusions = set()
    exclude_file = project_root / ".cache-security-exclude"

    if exclude_file.exists():
        with open(exclude_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    exclusions.add(line)

    return exclusions


def should_exclude_file(file_path: Path, exclusions: Set[str]) -> bool:
    """Check if file should be excluded from checking"""
    file_str = str(file_path)

    for exclusion in exclusions:
        if ':' in exclusion:
            # Line-specific exclusion
            exclude_file, line_range = exclusion.split(':', 1)
            if file_str.endswith(exclude_file):
                return True  # For simplicity, exclude the whole file
        else:
            # Whole file exclusion
            if file_str.endswith(exclusion):
                return True

    return False


def main():
    """Main function to run cache security checks"""
    project_root = Path(__file__).parent.parent
    errors = []
    warnings = []
    exclusions = load_exclusions(project_root)

    # Scan Python files in backend
    backend_dir = project_root / "backend"
    if backend_dir.exists():
        for py_file in backend_dir.rglob("*.py"):
            if any(skip in str(py_file) for skip in [
                "venv", "__pycache__", "migrations", "test_", "tests",
                "backup", "backups", "archive", "temp"
            ]):
                continue
            if should_exclude_file(py_file, exclusions):
                continue
            file_errors, file_warnings = scan_file(py_file)
            errors.extend(file_errors)
            warnings.extend(file_warnings)

    # Scan TypeScript files for cache patterns (basic check)
    src_dir = project_root / "src"
    if src_dir.exists():
        for ts_file in src_dir.rglob("*.ts"):
            # Basic regex check for TypeScript cache operations
            try:
                with open(ts_file, 'r', encoding='utf-8') as f:
                    content = f.read()

                # Check for potential cache operations with sensitive data
                sensitive_cache_patterns = [
                    r'cache\.set\([^)]*(?:password|token|secret|key)[^)]*\)',
                    r'localStorage\.setItem\([^)]*(?:password|token|secret)[^)]*\)',
                    r'sessionStorage\.setItem\([^)]*(?:password|token|secret)[^)]*\)'
                ]

                for i, line in enumerate(content.split('\n'), 1):
                    for pattern in sensitive_cache_patterns:
                        if re.search(pattern, line, re.IGNORECASE):
                            warnings.append({
                                'file': str(ts_file),
                                'line': i,
                                'type': 'frontend_sensitive_cache',
                                'message': 'Potential sensitive data in frontend cache operation'
                            })
            except Exception:
                pass

    # Report results
    if errors:
        print("‚ùå CACHE SECURITY ERRORS:")
        for error in errors:
            print(f"  {error['file']}:{error['line']} - {error['message']}")
        print()

    if warnings:
        print("‚ö†Ô∏è  CACHE SECURITY WARNINGS:")
        for warning in warnings:
            print(f"  {warning['file']}:{warning['line']} - {warning['message']}")
        print()

    if not errors and not warnings:
        print("‚úÖ No cache security issues detected")

    # Exit with error code if critical issues found
    if errors:
        print(f"\nüö® Found {len(errors)} critical cache security issues that must be fixed")
        sys.exit(1)

    if warnings:
        print(f"\n‚ö†Ô∏è  Found {len(warnings)} cache security warnings for review")

    print("\nüìã Cache Security Check Complete")


if __name__ == "__main__":
    main()
