#!/usr/bin/env python3
"""
Redis Deployment Validation Script
Generated by CC DevSecOps Engineer

Comprehensive validation of Redis infrastructure deployment including:
- Security configuration validation
- Performance benchmarking
- Integration testing
- Monitoring verification
- Emergency procedure testing
"""

import asyncio
import json
import logging
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple, Any

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class RedisDeploymentValidator:
    """Validates Redis deployment across all components"""

    def __init__(self, environment: str = "local"):
        self.environment = environment
        self.project_root = Path(__file__).parent.parent
        self.validation_results = {
            "timestamp": datetime.utcnow().isoformat(),
            "environment": environment,
            "tests": {},
            "overall_status": "unknown",
            "recommendations": []
        }

    async def validate_deployment(self) -> bool:
        """Run comprehensive Redis deployment validation"""
        logger.info(f"ğŸš€ Starting Redis deployment validation for {self.environment}")

        test_suite = [
            ("Security Configuration", self.validate_security_config),
            ("Connection Management", self.validate_connection_management),
            ("Performance Benchmarks", self.validate_performance),
            ("Monitoring Integration", self.validate_monitoring),
            ("Cache Operations", self.validate_cache_operations),
            ("Failover Mechanisms", self.validate_failover),
            ("Documentation", self.validate_documentation),
        ]

        passed_tests = 0
        total_tests = len(test_suite)

        for test_name, test_func in test_suite:
            logger.info(f"ğŸ§ª Running: {test_name}")
            try:
                result = await test_func()
                self.validation_results["tests"][test_name] = result

                if result["status"] == "pass":
                    logger.info(f"âœ… {test_name}: PASSED")
                    passed_tests += 1
                elif result["status"] == "warning":
                    logger.warning(f"âš ï¸  {test_name}: WARNING - {result.get('message', '')}")
                    passed_tests += 0.5  # Partial credit for warnings
                else:
                    logger.error(f"âŒ {test_name}: FAILED - {result.get('message', '')}")

            except Exception as e:
                logger.error(f"âŒ {test_name}: ERROR - {str(e)}")
                self.validation_results["tests"][test_name] = {
                    "status": "error",
                    "message": str(e)
                }

        # Calculate overall status
        pass_rate = passed_tests / total_tests
        if pass_rate >= 0.9:
            self.validation_results["overall_status"] = "excellent"
        elif pass_rate >= 0.8:
            self.validation_results["overall_status"] = "good"
        elif pass_rate >= 0.6:
            self.validation_results["overall_status"] = "acceptable"
        else:
            self.validation_results["overall_status"] = "needs_improvement"

        # Generate report
        await self.generate_validation_report()

        return pass_rate >= 0.8

    async def validate_security_config(self) -> Dict[str, Any]:
        """Validate Redis security configuration"""
        result = {"status": "pass", "checks": [], "issues": []}

        try:
            # Check Redis configuration file
            redis_conf_path = self.project_root / "redis" / "redis.conf"
            if redis_conf_path.exists():
                with open(redis_conf_path, 'r') as f:
                    config_content = f.read()

                security_checks = [
                    ("requirepass", "Password authentication"),
                    ("protected-mode yes", "Protected mode enabled"),
                    ("rename-command FLUSHALL", "Dangerous commands disabled"),
                    ("bind 127.0.0.1", "Network binding restricted"),
                    ("aclfile", "ACL file configured"),
                ]

                for check, description in security_checks:
                    if check in config_content:
                        result["checks"].append(f"âœ… {description}")
                    else:
                        result["issues"].append(f"âŒ {description} - {check} not found")
                        result["status"] = "warning"
            else:
                result["status"] = "fail"
                result["message"] = "Redis configuration file not found"

            # Check ACL file
            acl_file_path = self.project_root / "redis" / "users.acl"
            if acl_file_path.exists():
                with open(acl_file_path, 'r') as f:
                    acl_content = f.read()

                if "user default off" in acl_content:
                    result["checks"].append("âœ… Default user disabled")
                else:
                    result["issues"].append("âŒ Default user not disabled")
                    result["status"] = "warning"

                # Count defined users
                user_count = acl_content.count("user ")
                if user_count >= 3:
                    result["checks"].append(f"âœ… {user_count} users defined")
                else:
                    result["issues"].append(f"âŒ Insufficient users defined ({user_count})")
                    result["status"] = "warning"
            else:
                result["issues"].append("âŒ ACL file not found")
                result["status"] = "warning"

        except Exception as e:
            result["status"] = "error"
            result["message"] = str(e)

        return result

    async def validate_connection_management(self) -> Dict[str, Any]:
        """Validate Redis connection management"""
        result = {"status": "pass", "metrics": {}}

        try:
            # Test Redis connection manager
            sys.path.insert(0, str(self.project_root / "backend"))

            from app.core.redis_config import redis_manager

            # Test initialization
            initialized = await redis_manager.initialize()
            result["metrics"]["initialization"] = initialized

            if not initialized:
                result["status"] = "fail"
                result["message"] = "Redis manager initialization failed"
                return result

            # Test health check
            health = await redis_manager.health_check()
            result["metrics"]["health_check"] = health

            # Test command execution
            start_time = time.time()
            ping_result = await redis_manager.execute_command("ping")
            latency = (time.time() - start_time) * 1000

            result["metrics"]["ping_latency_ms"] = round(latency, 2)
            result["metrics"]["ping_successful"] = bool(ping_result)

            if latency > 100:
                result["status"] = "warning"
                result["message"] = f"High latency: {latency:.2f}ms"

            # Test circuit breaker
            circuit_breaker_state = redis_manager.circuit_breaker.state
            result["metrics"]["circuit_breaker_state"] = circuit_breaker_state

            await redis_manager.close()

        except Exception as e:
            result["status"] = "error"
            result["message"] = str(e)

        return result

    async def validate_performance(self) -> Dict[str, Any]:
        """Validate Redis performance benchmarks"""
        result = {"status": "pass", "benchmarks": {}}

        try:
            if self.environment == "local":
                # Run Redis benchmark
                benchmark_result = subprocess.run([
                    "redis-benchmark", "-h", "localhost", "-p", "6379",
                    "-n", "1000", "-c", "10", "-q", "-t", "set,get"
                ], capture_output=True, text=True, timeout=30)

                if benchmark_result.returncode == 0:
                    # Parse benchmark results
                    output_lines = benchmark_result.stdout.split('\n')
                    for line in output_lines:
                        if 'requests per second' in line:
                            parts = line.split(':')
                            if len(parts) >= 2:
                                operation = parts[0].strip()
                                rps = parts[1].strip().split()[0]
                                result["benchmarks"][operation] = rps

                    # Check if performance is acceptable
                    get_rps = float(result["benchmarks"].get("GET", "0"))
                    set_rps = float(result["benchmarks"].get("SET", "0"))

                    if get_rps < 10000 or set_rps < 10000:
                        result["status"] = "warning"
                        result["message"] = "Performance below expected thresholds"
                else:
                    result["status"] = "fail"
                    result["message"] = "Benchmark execution failed"
            else:
                # For production, we'll simulate benchmarks to avoid load
                result["benchmarks"]["simulated"] = "Production environment - benchmarks skipped"
                result["status"] = "pass"

        except Exception as e:
            result["status"] = "error"
            result["message"] = str(e)

        return result

    async def validate_monitoring(self) -> Dict[str, Any]:
        """Validate monitoring integration"""
        result = {"status": "pass", "monitoring_checks": []}

        try:
            # Check if monitoring module exists
            monitoring_file = self.project_root / "backend" / "app" / "monitoring" / "redis_monitor.py"
            if monitoring_file.exists():
                result["monitoring_checks"].append("âœ… Redis monitoring module exists")
            else:
                result["monitoring_checks"].append("âŒ Redis monitoring module missing")
                result["status"] = "fail"

            # Check if health endpoints exist
            health_endpoint_file = self.project_root / "backend" / "app" / "api" / "v1" / "endpoints" / "health.py"
            if health_endpoint_file.exists():
                with open(health_endpoint_file, 'r') as f:
                    health_content = f.read()

                if "redis" in health_content.lower():
                    result["monitoring_checks"].append("âœ… Redis health endpoints configured")
                else:
                    result["monitoring_checks"].append("âŒ Redis health endpoints missing")
                    result["status"] = "warning"
            else:
                result["monitoring_checks"].append("âŒ Health endpoint file missing")
                result["status"] = "warning"

            # Check for metrics configuration
            if "prometheus" in str(monitoring_file):
                result["monitoring_checks"].append("âœ… Prometheus metrics configured")
            else:
                result["monitoring_checks"].append("âš ï¸  Prometheus metrics not detected")
                result["status"] = "warning"

        except Exception as e:
            result["status"] = "error"
            result["message"] = str(e)

        return result

    async def validate_cache_operations(self) -> Dict[str, Any]:
        """Validate cache operations"""
        result = {"status": "pass", "operations": {}}

        try:
            sys.path.insert(0, str(self.project_root / "backend"))

            from app.services.caching.redis_cache import RedisCache

            cache = RedisCache()

            # Test basic cache operations
            test_key = "validation:test"
            test_value = "test_value_123"

            # Set operation
            set_success = await cache.set(test_key, test_value, 60)
            result["operations"]["set"] = set_success

            # Get operation
            get_value = await cache.get(test_key)
            result["operations"]["get"] = (get_value == test_value)

            # Exists operation
            exists_result = await cache.exists(test_key)
            result["operations"]["exists"] = exists_result

            # Delete operation
            delete_success = await cache.delete(test_key)
            result["operations"]["delete"] = delete_success

            # Check if all operations succeeded
            if not all(result["operations"].values()):
                result["status"] = "fail"
                result["message"] = "Some cache operations failed"

        except Exception as e:
            result["status"] = "error"
            result["message"] = str(e)

        return result

    async def validate_failover(self) -> Dict[str, Any]:
        """Validate failover mechanisms"""
        result = {"status": "pass", "failover_checks": []}

        try:
            sys.path.insert(0, str(self.project_root / "backend"))

            from app.services.caching.redis_cache import RedisCache

            # Test fallback behavior when Redis is unavailable
            cache = RedisCache()

            # Simulate Redis unavailable
            original_enabled = cache.enabled
            cache.enabled = False
            cache.client = None

            # Test operations with Redis disabled
            fallback_tests = [
                ("get", cache.get("test:key")),
                ("set", cache.set("test:key", "value")),
                ("exists", cache.exists("test:key")),
                ("delete", cache.delete("test:key"))
            ]

            for operation, test_coro in fallback_tests:
                try:
                    result_val = await test_coro
                    # All fallback operations should complete without error
                    result["failover_checks"].append(f"âœ… {operation} fallback works")
                except Exception:
                    result["failover_checks"].append(f"âŒ {operation} fallback failed")
                    result["status"] = "fail"

            # Restore original state
            cache.enabled = original_enabled

        except Exception as e:
            result["status"] = "error"
            result["message"] = str(e)

        return result

    async def validate_documentation(self) -> Dict[str, Any]:
        """Validate documentation completeness"""
        result = {"status": "pass", "documentation_checks": []}

        try:
            # Check for required documentation files
            required_docs = [
                ("Redis Configuration", "redis/redis.conf"),
                ("ACL Configuration", "redis/users.acl"),
                ("Emergency Procedures", "docs/redis-emergency-procedures.md"),
                ("Deployment Script", "scripts/deploy_redis_infrastructure.py"),
                ("CI/CD Configuration", ".github/workflows/redis-infrastructure-ci.yml")
            ]

            for doc_name, doc_path in required_docs:
                file_path = self.project_root / doc_path
                if file_path.exists():
                    result["documentation_checks"].append(f"âœ… {doc_name}")
                else:
                    result["documentation_checks"].append(f"âŒ {doc_name} missing")
                    result["status"] = "warning"

            # Check if pre-commit hooks are configured
            precommit_file = self.project_root / ".pre-commit-config.yaml"
            if precommit_file.exists():
                with open(precommit_file, 'r') as f:
                    precommit_content = f.read()

                if "redis" in precommit_content.lower():
                    result["documentation_checks"].append("âœ… Pre-commit Redis hooks configured")
                else:
                    result["documentation_checks"].append("âš ï¸  Pre-commit Redis hooks not detected")
                    result["status"] = "warning"

        except Exception as e:
            result["status"] = "error"
            result["message"] = str(e)

        return result

    async def generate_validation_report(self):
        """Generate comprehensive validation report"""
        report_file = self.project_root / f"redis_validation_report_{self.environment}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

        with open(report_file, 'w') as f:
            json.dump(self.validation_results, f, indent=2)

        # Generate recommendations
        self._generate_recommendations()

        # Print summary
        self._print_validation_summary()

        logger.info(f"ğŸ“Š Validation report saved: {report_file}")

    def _generate_recommendations(self):
        """Generate recommendations based on validation results"""
        recommendations = []

        for test_name, test_result in self.validation_results["tests"].items():
            if test_result["status"] == "warning":
                recommendations.append(f"âš ï¸  {test_name}: Review and address warnings")
            elif test_result["status"] == "fail":
                recommendations.append(f"âŒ {test_name}: Critical issues need immediate attention")
            elif test_result["status"] == "error":
                recommendations.append(f"ğŸ”§ {test_name}: Technical issues need investigation")

        # General recommendations
        if self.validation_results["overall_status"] == "needs_improvement":
            recommendations.append("ğŸ”„ Consider revisiting Redis configuration and deployment")

        if any("warning" in str(result) for result in self.validation_results["tests"].values()):
            recommendations.append("ğŸ“‹ Schedule regular Redis health checks")
            recommendations.append("ğŸ”’ Review security configurations monthly")

        self.validation_results["recommendations"] = recommendations

    def _print_validation_summary(self):
        """Print validation summary"""
        print("\n" + "="*80)
        print(f"ğŸ¯ REDIS DEPLOYMENT VALIDATION SUMMARY - {self.environment.upper()}")
        print("="*80)

        # Overall status
        status_emoji = {
            "excellent": "ğŸ‰",
            "good": "âœ…",
            "acceptable": "âš ï¸",
            "needs_improvement": "âŒ"
        }

        overall_status = self.validation_results["overall_status"]
        print(f"{status_emoji.get(overall_status, 'â“')} Overall Status: {overall_status.upper()}")

        # Test results summary
        print(f"\nğŸ“Š Test Results:")
        for test_name, result in self.validation_results["tests"].items():
            status = result["status"]
            emoji = "âœ…" if status == "pass" else "âš ï¸" if status == "warning" else "âŒ"
            print(f"  {emoji} {test_name}: {status.upper()}")

            if result.get("message"):
                print(f"      â””â”€ {result['message']}")

        # Recommendations
        if self.validation_results["recommendations"]:
            print(f"\nğŸ’¡ Recommendations:")
            for i, rec in enumerate(self.validation_results["recommendations"], 1):
                print(f"  {i}. {rec}")

        # Next steps
        print(f"\nğŸ“‹ Next Steps:")
        if overall_status == "excellent":
            print("  ğŸ‰ Deployment is production-ready!")
            print("  ğŸ“… Schedule regular maintenance and monitoring reviews")
        elif overall_status == "good":
            print("  ğŸ”§ Address minor warnings if possible")
            print("  ğŸš€ Deployment is ready for production")
        elif overall_status == "acceptable":
            print("  âš ï¸  Address warnings before production deployment")
            print("  ğŸ§ª Consider additional testing")
        else:
            print("  âŒ Critical issues must be resolved before deployment")
            print("  ğŸ”„ Re-run validation after fixes")

        print("="*80)


async def main():
    """Main validation function"""
    import argparse

    parser = argparse.ArgumentParser(description="Validate Redis deployment")
    parser.add_argument(
        "--environment",
        choices=["local", "staging", "production"],
        default="local",
        help="Environment to validate"
    )

    args = parser.parse_args()

    validator = RedisDeploymentValidator(args.environment)
    success = await validator.validate_deployment()

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    asyncio.run(main())
