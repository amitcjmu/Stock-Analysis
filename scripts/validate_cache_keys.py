#!/usr/bin/env python3
"""
Cache Key Validation Script for AI Force Migration Platform
Generated by CC DevSecOps Engineer

This script validates cache key naming conventions and enforces:
- Version prefixing
- Tenant isolation for multi-tenant data
- Consistent naming patterns
- Security best practices
"""

import ast
import sys
import re
from pathlib import Path
from typing import List, Dict, Any, Set
import json


class CacheKeyValidator(ast.NodeVisitor):
    """Validate cache key formats and naming conventions"""

    def __init__(self):
        self.violations: List[Dict[str, Any]] = []
        self.current_file: str = ""
        self.valid_prefixes = {
            'v1:', 'v2:', 'v3:', 'v4:', 'v5:'  # Supported API versions
        }
        self.required_tenant_contexts = {
            'user:', 'client:', 'tenant:', 'account:', 'engagement:'
        }
        self.cache_methods = {
            'set', 'setex', 'setnx', 'mset', 'hset', 'hmset',  # Redis
            'cache_set', 'cache_store', 'put', 'store'  # Application cache
        }

    def visit_Call(self, node):
        """Check cache operation calls"""
        try:
            if self._is_cache_operation(node) and node.args:
                # First argument should be the cache key
                key_arg = node.args[0]
                self._validate_cache_key(key_arg, node.lineno)
        except Exception:
            # Don't fail validation for AST parsing errors
            pass

        self.generic_visit(node)

    def visit_Subscript(self, node):
        """Check cache access patterns like cache[key]"""
        try:
            if isinstance(node.value, ast.Name) and 'cache' in node.value.id.lower():
                if isinstance(node.slice, ast.Constant):
                    self._validate_static_key(node.slice.value, node.lineno)
        except Exception:
            pass

        self.generic_visit(node)

    def _is_cache_operation(self, node: ast.Call) -> bool:
        """Check if this is a cache operation"""
        try:
            if isinstance(node.func, ast.Attribute):
                obj_name = ""
                if isinstance(node.func.value, ast.Name):
                    obj_name = node.func.value.id.lower()
                method_name = node.func.attr.lower()

                # Check for cache objects and methods
                if 'cache' in obj_name or 'redis' in obj_name:
                    return any(method in method_name for method in self.cache_methods)

                # Check for method names that suggest caching
                return any(method in method_name for method in self.cache_methods)

        except Exception:
            pass
        return False

    def _validate_cache_key(self, key_node: ast.AST, line_no: int):
        """Validate cache key node"""
        try:
            if isinstance(key_node, ast.Constant) and isinstance(key_node.value, str):
                self._validate_static_key(key_node.value, line_no)
            elif isinstance(key_node, ast.JoinedStr):
                self._validate_f_string_key(key_node, line_no)
            elif isinstance(key_node, ast.BinOp):
                self._validate_concatenated_key(key_node, line_no)
            elif isinstance(key_node, ast.Call):
                self._validate_generated_key(key_node, line_no)
            else:
                # Complex key generation - provide general guidance
                self.violations.append({
                    'file': self.current_file,
                    'line': line_no,
                    'severity': 'warning',
                    'type': 'complex_key_generation',
                    'message': 'Complex cache key generation - ensure it follows naming conventions'
                })
        except Exception:
            pass

    def _validate_static_key(self, key: str, line_no: int):
        """Validate a static string cache key"""
        violations = []

        # Rule 1: Must have version prefix
        if not any(key.startswith(prefix) for prefix in self.valid_prefixes):
            violations.append({
                'rule': 'version_prefix',
                'message': f'Cache key "{key}" must start with version prefix (v1:, v2:, etc.)'
            })

        # Rule 2: Multi-tenant data must include tenant context
        if self._requires_tenant_context(key):
            if not any(context in key for context in self.required_tenant_contexts):
                violations.append({
                    'rule': 'tenant_isolation',
                    'message': f'Cache key "{key}" for user/tenant data must include tenant context'
                })

        # Rule 3: No dangerous characters
        dangerous_chars = ['*', '?', '[', ']', '{', '}', '\\', '/', ' ']
        found_dangerous = [char for char in dangerous_chars if char in key]
        if found_dangerous:
            violations.append({
                'rule': 'dangerous_characters',
                'message': f'Cache key "{key}" contains dangerous characters: {found_dangerous}'
            })

        # Rule 4: Reasonable length
        if len(key) > 250:  # Redis key limit is 512MB, but keep reasonable
            violations.append({
                'rule': 'key_length',
                'message': f'Cache key "{key}" is too long ({len(key)} chars). Keep under 250 chars.'
            })

        # Rule 5: Consistent naming pattern
        if not self._follows_naming_pattern(key):
            violations.append({
                'rule': 'naming_pattern',
                'message': f'Cache key "{key}" should follow pattern: version:context:resource:identifier'
            })

        # Add violations to main list
        for violation in violations:
            self.violations.append({
                'file': self.current_file,
                'line': line_no,
                'severity': 'error' if violation['rule'] in ['version_prefix', 'tenant_isolation'] else 'warning',
                'type': violation['rule'],
                'message': violation['message']
            })

    def _validate_f_string_key(self, node: ast.JoinedStr, line_no: int):
        """Validate f-string cache keys"""
        try:
            # Reconstruct the f-string pattern
            key_pattern = ""
            has_version = False
            has_tenant_context = False

            for value in node.values:
                if isinstance(value, ast.Constant):
                    key_pattern += str(value.value)
                    if any(prefix in str(value.value) for prefix in self.valid_prefixes):
                        has_version = True
                    if any(context in str(value.value) for context in self.required_tenant_contexts):
                        has_tenant_context = True
                elif isinstance(value, ast.FormattedValue):
                    key_pattern += "{var}"
                    # Check if variable name suggests tenant context
                    if hasattr(value.value, 'id'):
                        var_name = value.value.id.lower()
                        if any(ctx.replace(':', '') in var_name for ctx in self.required_tenant_contexts):
                            has_tenant_context = True

            # Check version prefix
            if not has_version:
                self.violations.append({
                    'file': self.current_file,
                    'line': line_no,
                    'severity': 'error',
                    'type': 'missing_version_prefix',
                    'message': f'F-string cache key "{key_pattern}" must include version prefix'
                })

            # Check tenant context if needed
            if self._requires_tenant_context(key_pattern) and not has_tenant_context:
                self.violations.append({
                    'file': self.current_file,
                    'line': line_no,
                    'severity': 'error',
                    'type': 'missing_tenant_context',
                    'message': f'F-string cache key "{key_pattern}" must include tenant context'
                })

        except Exception:
            # Fallback for complex f-strings
            self.violations.append({
                'file': self.current_file,
                'line': line_no,
                'severity': 'warning',
                'type': 'complex_f_string',
                'message': 'Complex f-string cache key - manually verify it follows naming conventions'
            })

    def _validate_concatenated_key(self, node: ast.BinOp, line_no: int):
        """Validate concatenated cache keys"""
        self.violations.append({
            'file': self.current_file,
            'line': line_no,
            'severity': 'warning',
            'type': 'concatenated_key',
            'message': 'String concatenation for cache key - prefer f-strings and verify naming conventions'
        })

    def _validate_generated_key(self, node: ast.Call, line_no: int):
        """Validate keys generated by function calls"""
        try:
            func_name = ""
            if isinstance(node.func, ast.Name):
                func_name = node.func.id
            elif isinstance(node.func, ast.Attribute):
                func_name = node.func.attr

            # Check if it's a known key generation function
            if 'key' in func_name.lower() and 'generate' in func_name.lower():
                self.violations.append({
                    'file': self.current_file,
                    'line': line_no,
                    'severity': 'info',
                    'type': 'generated_key',
                    'message': f'Using key generation function "{func_name}" - ensure it follows conventions'
                })
            else:
                self.violations.append({
                    'file': self.current_file,
                    'line': line_no,
                    'severity': 'warning',
                    'type': 'unknown_key_generation',
                    'message': f'Unknown key generation method "{func_name}" - verify naming conventions'
                })
        except Exception:
            pass

    def _requires_tenant_context(self, key: str) -> bool:
        """Check if key requires tenant context based on content"""
        key_lower = key.lower()
        tenant_sensitive_terms = [
            'user', 'client', 'tenant', 'account', 'engagement',
            'profile', 'preference', 'setting', 'data', 'session',
            'auth', 'permission', 'role', 'access'
        ]
        return any(term in key_lower for term in tenant_sensitive_terms)

    def _follows_naming_pattern(self, key: str) -> bool:
        """Check if key follows recommended pattern: version:context:resource:identifier"""
        # Split on colons and check structure
        parts = key.split(':')

        # Must have at least 3 parts: version, context, resource
        if len(parts) < 3:
            return False

        # First part should be version
        if not re.match(r'^v\d+$', parts[0]):
            return False

        # Other parts should be meaningful identifiers (no empty parts)
        return all(part.strip() for part in parts[1:])


def scan_file(file_path: Path) -> List[Dict]:
    """Scan a file for cache key validation issues"""
    validator = CacheKeyValidator()
    validator.current_file = str(file_path)

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Only process files that likely contain cache operations
        if not any(term in content.lower() for term in ['cache', 'redis', 'set', 'get']):
            return []

        tree = ast.parse(content, filename=str(file_path))
        validator.visit(tree)

    except SyntaxError:
        # Skip files with syntax errors
        pass
    except Exception:
        # Skip files that can't be processed
        pass

    return validator.violations


def main():
    """Main function to run cache key validation"""
    project_root = Path(__file__).parent.parent
    all_violations = []

    # Scan Python files
    backend_dir = project_root / "backend"
    if backend_dir.exists():
        for py_file in backend_dir.rglob("*.py"):
            if any(skip in str(py_file) for skip in ["venv", "__pycache__", "migrations"]):
                continue
            violations = scan_file(py_file)
            all_violations.extend(violations)

    # Group violations by severity
    errors = [v for v in all_violations if v['severity'] == 'error']
    warnings = [v for v in all_violations if v['severity'] == 'warning']
    info = [v for v in all_violations if v['severity'] == 'info']

    # Report results
    if errors:
        print("‚ùå CACHE KEY ERRORS (Must Fix):")
        for error in errors:
            print(f"  {error['file']}:{error['line']} - {error['message']}")
        print()

    if warnings:
        print("‚ö†Ô∏è  CACHE KEY WARNINGS:")
        for warning in warnings:
            print(f"  {warning['file']}:{warning['line']} - {warning['message']}")
        print()

    if info:
        print("‚ÑπÔ∏è  CACHE KEY INFO:")
        for item in info:
            print(f"  {item['file']}:{item['line']} - {item['message']}")
        print()

    if not all_violations:
        print("‚úÖ All cache keys follow naming conventions")

    # Print conventions summary
    print("\nüìã Cache Key Naming Conventions:")
    print("  ‚úì Must start with version prefix (v1:, v2:, etc.)")
    print("  ‚úì Multi-tenant data must include tenant context (tenant:, client:, etc.)")
    print("  ‚úì Follow pattern: version:context:resource:identifier")
    print("  ‚úì No dangerous characters (* ? [ ] { } \\ / spaces)")
    print("  ‚úì Keep under 250 characters")
    print("  ‚úì Use descriptive, consistent naming")

    # Exit with error if critical violations found
    if errors:
        print(f"\nüö® Found {len(errors)} critical cache key violations")
        sys.exit(1)

    if warnings:
        print(f"\n‚ö†Ô∏è  Found {len(warnings)} cache key warnings for review")

    print("\nüìã Cache Key Validation Complete")


if __name__ == "__main__":
    main()
