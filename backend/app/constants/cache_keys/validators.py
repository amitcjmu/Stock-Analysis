"""
Cache Key Strategy and Validation Classes

This module contains strategy classes for agent-specific caching and validation
classes for sensitive data handling.

Generated by CC (Claude Code)
"""

from typing import Dict


class AgentCacheStrategy:
    """
    Agent-specific caching strategies based on agent behavior patterns.
    Different agents have different result volatility and computation costs.
    """

    AGENT_TTL_MAP = {
        # Fast, frequently changing agents
        "data_import_agent": 300,  # 5 minutes
        "validation_agent": 180,  # 3 minutes
        "progress_tracking_agent": 60,  # 1 minute
        # Medium volatility agents
        "field_mapping_agent": 1800,  # 30 minutes
        "data_cleansing_agent": 900,  # 15 minutes
        "gap_analysis_agent": 1200,  # 20 minutes
        # Expensive, stable analysis agents
        "asset_classification_agent": 3600,  # 1 hour
        "dependency_analysis_agent": 7200,  # 2 hours
        "sixr_recommendation_agent": 14400,  # 4 hours
        "learning_agent": 86400,  # 24 hours
    }

    @classmethod
    def get_agent_ttl(cls, agent_type: str) -> int:
        """Alias for get_ttl_for_agent for backward compatibility"""
        return cls.get_ttl_for_agent(agent_type)

    @classmethod
    def get_ttl_for_agent(cls, agent_type: str) -> int:
        """
        Get recommended TTL for specific agent results.

        Args:
            agent_type: Type/name of the agent

        Returns:
            TTL in seconds, default 30 minutes if agent not found
        """
        return cls.AGENT_TTL_MAP.get(agent_type, 1800)

    @classmethod
    def should_cache_agent_result(
        cls, agent_type: str, execution_time_seconds: float
    ) -> bool:
        """
        Determine if agent result should be cached based on execution cost.

        Args:
            agent_type: Type/name of the agent
            execution_time_seconds: How long the agent took to execute

        Returns:
            True if result should be cached
        """
        # Always cache if execution took more than 30 seconds
        if execution_time_seconds > 30:
            return True

        # Cache expensive agents even if they're fast
        expensive_agents = {
            "sixr_recommendation_agent",
            "dependency_analysis_agent",
            "asset_classification_agent",
            "learning_agent",
        }

        return agent_type in expensive_agents


class SensitiveDataMarkers:
    """
    Markers to identify cache keys that contain sensitive data requiring encryption.
    Used by SecureCache to automatically encrypt/decrypt sensitive data.
    """

    # Cache key patterns that always contain sensitive data
    SENSITIVE_PATTERNS = {
        ":agent:",
        ":crewai:",
        ":flow:",
        ":user:",
        ":client:",
        "config",
        "tool",
        "memory",
        "state",
        "checkpoint",
        "context",
        "settings",
    }

    # Cache key segments that indicate sensitive data
    SENSITIVE_SEGMENTS = {
        "config",
        "credential",
        "token",
        "secret",
        "memory",
        "checkpoint",
        "context",
        "settings",
    }

    @classmethod
    def requires_encryption(cls, cache_key: str) -> bool:
        """
        Determine if a cache key contains sensitive data requiring encryption.

        Args:
            cache_key: The cache key to analyze

        Returns:
            True if the key contains sensitive data
        """
        # Check against sensitive patterns
        for pattern in cls.SENSITIVE_PATTERNS:
            if pattern in cache_key:
                return True

        # Check for sensitive segments
        key_lower = cache_key.lower()
        for segment in cls.SENSITIVE_SEGMENTS:
            if f":{segment}:" in key_lower or key_lower.endswith(f":{segment}"):
                return True

        return False

    @classmethod
    def get_encryption_context(cls, cache_key: str) -> Dict[str, str]:
        """
        Extract encryption context from cache key for additional security.

        Args:
            cache_key: The cache key to analyze

        Returns:
            Dictionary with encryption context metadata
        """
        parts = cache_key.split(":")
        context = {}

        # Extract tenant context for encryption key derivation
        if "client:" in cache_key:
            client_idx = parts.index("client") if "client" in parts else -1
            if client_idx >= 0 and client_idx + 1 < len(parts):
                context["client_id"] = parts[client_idx + 1]

        if "engagement:" in cache_key:
            engagement_idx = parts.index("engagement") if "engagement" in parts else -1
            if engagement_idx >= 0 and engagement_idx + 1 < len(parts):
                context["engagement_id"] = parts[engagement_idx + 1]

        if "user:" in cache_key:
            user_idx = parts.index("user") if "user" in parts else -1
            if user_idx >= 0 and user_idx + 1 < len(parts):
                context["user_id"] = parts[user_idx + 1]

        return context
