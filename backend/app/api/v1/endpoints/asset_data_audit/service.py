"""
Asset Data Audit Service

Business logic for comprehensive asset data auditing.
Extracts and categorizes all data associated with an asset.

Generated by CC (Claude Code) for Asset Data Review feature
"""

import logging
from collections import defaultdict
from datetime import datetime
from decimal import Decimal
from typing import Any, Dict, List
from uuid import UUID

from sqlalchemy import inspect, select, text
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.asset import Asset

from .schemas import (
    AssetDataAuditResponse,
    CategoryStats,
    DataGaps,
    EnrichmentTableInfo,
    FieldInfo,
    LowCompletenessCategory,
    OverallSummary,
    SummaryStats,
)

logger = logging.getLogger(__name__)


# Enrichment tables to query (table_name, key)
ENRICHMENT_TABLES = [
    ("asset_resilience", "resilience"),
    ("asset_compliance_flags", "compliance_flags"),
    ("asset_vulnerabilities", "vulnerabilities"),
    ("asset_tech_debt", "tech_debt"),
    ("asset_dependencies", "dependencies"),
    ("asset_performance_metrics", "performance_metrics"),
    ("asset_cost_optimization", "cost_optimization"),
    ("asset_licenses", "licenses"),
    ("asset_contacts", "contacts"),
    ("asset_custom_attributes", "custom_attributes_table"),
    ("asset_eol_assessments", "eol_assessments"),
    ("asset_product_links", "product_links"),
]


def safe_json_value(value: Any) -> Any:
    """Safely convert a value to JSON-serializable format."""
    if value is None:
        return None
    if isinstance(value, (str, int, float, bool)):
        return value
    if isinstance(value, UUID):
        return str(value)
    if isinstance(value, datetime):
        return value.isoformat()
    if isinstance(value, Decimal):
        return float(value)
    if isinstance(value, dict):
        return {k: safe_json_value(v) for k, v in value.items()}
    if isinstance(value, (list, tuple)):
        return [safe_json_value(v) for v in value]
    if isinstance(value, bytes):
        return value.decode("utf-8", errors="replace")
    return str(value)


def get_column_metadata(column) -> dict:
    """Extract metadata from a SQLAlchemy column."""
    info = getattr(column, "info", {}) or {}
    return {
        "display_name": info.get("display_name", column.name.replace("_", " ").title()),
        "category": info.get("category", "uncategorized"),
        "short_hint": info.get("short_hint"),
        "comment": getattr(column, "comment", None),
        "nullable": getattr(column, "nullable", True),
        "type": str(column.type),
    }


def is_jsonb_column(column) -> bool:
    """Check if a column is a JSONB/JSON type."""
    type_str = str(column.type).upper()
    return "JSON" in type_str


def is_value_populated(value: Any) -> bool:
    """Determine if a value is considered 'populated' (not empty)."""
    if value is None:
        return False
    if isinstance(value, str) and value.strip() == "":
        return False
    if isinstance(value, (list, dict)) and len(value) == 0:
        return False
    return True


async def get_enrichment_data(
    db: AsyncSession, asset_id: UUID
) -> Dict[str, EnrichmentTableInfo]:
    """Fetch all enrichment table data for an asset."""
    enrichment_data: Dict[str, EnrichmentTableInfo] = {}

    for table_name, key in ENRICHMENT_TABLES:
        try:
            query = text(
                f"""
                SELECT * FROM migration.{table_name}
                WHERE asset_id = :asset_id
            """
            )
            result = await db.execute(query, {"asset_id": str(asset_id)})
            rows = result.mappings().all()

            if rows:
                records = [
                    {k: safe_json_value(v) for k, v in dict(row).items()}
                    for row in rows
                ]
                enrichment_data[key] = EnrichmentTableInfo(
                    exists=True,
                    record_count=len(rows),
                    records=records,
                )
            else:
                enrichment_data[key] = EnrichmentTableInfo(
                    exists=False,
                    record_count=0,
                    records=[],
                )
        except Exception as e:
            logger.warning(f"Error querying {table_name}: {e}")
            enrichment_data[key] = EnrichmentTableInfo(
                exists=False,
                record_count=0,
                records=[],
                error=str(e),
            )

    return enrichment_data


async def audit_asset(
    asset_id: str,
    db: AsyncSession,
    client_account_id: UUID,
    engagement_id: UUID,
) -> AssetDataAuditResponse:
    """
    Perform comprehensive audit of an asset's data.

    Args:
        asset_id: UUID of the asset to audit
        db: Database session
        client_account_id: Tenant client account ID for scoping
        engagement_id: Engagement ID for scoping

    Returns:
        AssetDataAuditResponse with categorized data and gap analysis
    """
    # Fetch the asset with tenant scoping
    stmt = select(Asset).where(
        Asset.id == UUID(asset_id),
        Asset.client_account_id == client_account_id,
        Asset.engagement_id == engagement_id,
        Asset.deleted_at.is_(None),
    )
    result = await db.execute(stmt)
    asset = result.scalar_one_or_none()

    if not asset:
        raise ValueError(f"Asset not found: {asset_id}")

    # Get SQLAlchemy mapper for column inspection
    mapper = inspect(Asset)
    columns = mapper.columns

    # Categorize fields
    categories: Dict[str, Dict] = defaultdict(
        lambda: {"fields": [], "populated": 0, "total": 0}
    )
    jsonb_expanded: Dict[str, Any] = {}
    all_fields: List[FieldInfo] = []

    # Process each column
    for column in columns:
        col_name = column.name
        metadata = get_column_metadata(column)
        category = metadata["category"]

        # Get the value
        try:
            value = getattr(asset, col_name, None)
            safe_value = safe_json_value(value)
        except Exception as e:
            logger.warning(f"Error getting value for {col_name}: {e}")
            safe_value = f"<error: {e}>"
            value = None

        populated = is_value_populated(value)

        field_info = FieldInfo(
            name=col_name,
            display_name=metadata["display_name"],
            value=safe_value,
            populated=populated,
            type=metadata["type"],
            hint=metadata["short_hint"],
            comment=metadata["comment"],
        )

        categories[category]["fields"].append(field_info)
        categories[category]["total"] += 1
        if populated:
            categories[category]["populated"] += 1

        all_fields.append(field_info)

        # Expand JSONB columns
        if is_jsonb_column(column) and value:
            jsonb_expanded[col_name] = safe_json_value(value)

    # Convert categories to CategoryStats objects
    category_stats: Dict[str, CategoryStats] = {}
    for cat_name, cat_data in categories.items():
        total = cat_data["total"]
        populated = cat_data["populated"]
        completeness = round((populated / total * 100) if total > 0 else 0, 1)

        category_stats[cat_name] = CategoryStats(
            fields=cat_data["fields"],
            populated=populated,
            total=total,
            completeness_pct=completeness,
        )

    # Get enrichment data
    enrichment_data = await get_enrichment_data(db, UUID(asset_id))

    # Calculate enrichment stats
    enrichment_total = 0
    enrichment_populated = 0
    for enrich_data in enrichment_data.values():
        if enrich_data.exists and enrich_data.records:
            for record in enrich_data.records:
                for k, v in record.items():
                    if k not in ("id", "asset_id", "created_at", "updated_at"):
                        enrichment_total += 1
                        if is_value_populated(v):
                            enrichment_populated += 1

    # Calculate overall stats
    total_fields = len(all_fields)
    populated_fields = sum(1 for f in all_fields if f.populated)

    main_table_stats = SummaryStats(
        total_fields=total_fields,
        populated_fields=populated_fields,
        completeness_pct=round(
            (populated_fields / total_fields * 100) if total_fields > 0 else 0, 1
        ),
    )

    enrichment_stats = SummaryStats(
        total_fields=enrichment_total,
        populated_fields=enrichment_populated,
        completeness_pct=round(
            (
                (enrichment_populated / enrichment_total * 100)
                if enrichment_total > 0
                else 0
            ),
            1,
        ),
    )

    overall_total = total_fields + enrichment_total
    overall_populated = populated_fields + enrichment_populated
    overall_stats = SummaryStats(
        total_fields=overall_total,
        populated_fields=overall_populated,
        completeness_pct=round(
            (overall_populated / overall_total * 100) if overall_total > 0 else 0, 1
        ),
    )

    # Build data gaps report
    empty_categories = [
        cat
        for cat, data in category_stats.items()
        if data.populated == 0 and data.total > 0
    ]

    low_completeness = [
        LowCompletenessCategory(category=cat, completeness_pct=data.completeness_pct)
        for cat, data in category_stats.items()
        if 0 < data.completeness_pct < 50
    ]

    missing_enrichments = [
        key for key, data in enrichment_data.items() if not data.exists
    ]

    data_gaps = DataGaps(
        empty_categories=empty_categories,
        low_completeness_categories=low_completeness,
        missing_enrichments=missing_enrichments,
    )

    return AssetDataAuditResponse(
        asset_id=str(asset_id),
        asset_name=asset.name,
        summary=OverallSummary(
            main_table=main_table_stats,
            enrichments=enrichment_stats,
            overall=overall_stats,
        ),
        categories=category_stats,
        enrichments=enrichment_data,
        jsonb_expanded=jsonb_expanded,
        data_gaps=data_gaps,
    )
