"""
Asset Data Audit Core Functions

Main audit functions for comprehensive asset data analysis.

Generated by CC (Claude Code) for Asset Data Review feature
"""

import logging
from collections import defaultdict
from typing import Any, Dict, List
from uuid import UUID

from sqlalchemy import inspect, select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.asset import Asset

from ..schemas import (
    AssetDataAuditResponse,
    CategoryStats,
    DataGaps,
    FieldInfo,
    LowCompletenessCategory,
    OverallSummary,
    SummaryStats,
)
from .enrichment import (
    ENRICHMENT_TABLES,
    get_enrichment_data,
    get_enrichment_summary_stats,
)
from .utils import (
    get_column_metadata,
    is_jsonb_column,
    is_value_populated,
    safe_json_value,
)

logger = logging.getLogger(__name__)


async def audit_asset(
    asset_id: str,
    db: AsyncSession,
    client_account_id: UUID,
    engagement_id: UUID,
) -> AssetDataAuditResponse:
    """
    Perform comprehensive audit of an asset's data.

    Args:
        asset_id: UUID of the asset to audit
        db: Database session
        client_account_id: Tenant client account ID for scoping
        engagement_id: Engagement ID for scoping

    Returns:
        AssetDataAuditResponse with categorized data and gap analysis
    """
    # Fetch the asset with tenant scoping
    stmt = select(Asset).where(
        Asset.id == UUID(asset_id),
        Asset.client_account_id == client_account_id,
        Asset.engagement_id == engagement_id,
        Asset.deleted_at.is_(None),
    )
    result = await db.execute(stmt)
    asset = result.scalar_one_or_none()

    if not asset:
        raise ValueError(f"Asset not found: {asset_id}")

    # Get SQLAlchemy mapper for column inspection
    mapper = inspect(Asset)
    columns = mapper.columns

    # Categorize fields
    categories: Dict[str, Dict] = defaultdict(
        lambda: {"fields": [], "populated": 0, "total": 0}
    )
    jsonb_expanded: Dict[str, Any] = {}
    all_fields: List[FieldInfo] = []

    # Process each column
    for column in columns:
        col_name = column.name
        metadata = get_column_metadata(column)
        category = metadata["category"]

        # Get the value
        try:
            value = getattr(asset, col_name, None)
            safe_value = safe_json_value(value)
        except Exception as e:
            logger.warning(f"Error getting value for {col_name}: {e}")
            safe_value = f"<error: {e}>"
            value = None

        populated = is_value_populated(value)

        field_info = FieldInfo(
            name=col_name,
            display_name=metadata["display_name"],
            value=safe_value,
            populated=populated,
            type=metadata["type"],
            hint=metadata["short_hint"],
            comment=metadata["comment"],
        )

        categories[category]["fields"].append(field_info)
        categories[category]["total"] += 1
        if populated:
            categories[category]["populated"] += 1

        all_fields.append(field_info)

        # Expand JSONB columns
        if is_jsonb_column(column) and value:
            jsonb_expanded[col_name] = safe_json_value(value)

    # Convert categories to CategoryStats objects
    category_stats: Dict[str, CategoryStats] = {}
    for cat_name, cat_data in categories.items():
        total = cat_data["total"]
        populated = cat_data["populated"]
        completeness = round((populated / total * 100) if total > 0 else 0, 1)

        category_stats[cat_name] = CategoryStats(
            fields=cat_data["fields"],
            populated=populated,
            total=total,
            completeness_pct=completeness,
        )

    # Get enrichment data
    enrichment_data = await get_enrichment_data(db, UUID(asset_id))

    # Calculate enrichment stats
    enrichment_total = 0
    enrichment_populated = 0
    for enrich_data in enrichment_data.values():
        if enrich_data.exists and enrich_data.records:
            for record in enrich_data.records:
                for k, v in record.items():
                    if k not in ("id", "asset_id", "created_at", "updated_at"):
                        enrichment_total += 1
                        if is_value_populated(v):
                            enrichment_populated += 1

    # Calculate overall stats
    total_fields = len(all_fields)
    populated_fields = sum(1 for f in all_fields if f.populated)

    main_table_stats = SummaryStats(
        total_fields=total_fields,
        populated_fields=populated_fields,
        completeness_pct=round(
            (populated_fields / total_fields * 100) if total_fields > 0 else 0, 1
        ),
    )

    enrichment_stats = SummaryStats(
        total_fields=enrichment_total,
        populated_fields=enrichment_populated,
        completeness_pct=round(
            (
                (enrichment_populated / enrichment_total * 100)
                if enrichment_total > 0
                else 0
            ),
            1,
        ),
    )

    overall_total = total_fields + enrichment_total
    overall_populated = populated_fields + enrichment_populated
    overall_stats = SummaryStats(
        total_fields=overall_total,
        populated_fields=overall_populated,
        completeness_pct=round(
            (overall_populated / overall_total * 100) if overall_total > 0 else 0, 1
        ),
    )

    # Build data gaps report
    empty_categories = [
        cat
        for cat, data in category_stats.items()
        if data.populated == 0 and data.total > 0
    ]

    low_completeness = [
        LowCompletenessCategory(category=cat, completeness_pct=data.completeness_pct)
        for cat, data in category_stats.items()
        if 0 < data.completeness_pct < 50
    ]

    missing_enrichments = [
        key for key, data in enrichment_data.items() if not data.exists
    ]

    data_gaps = DataGaps(
        empty_categories=empty_categories,
        low_completeness_categories=low_completeness,
        missing_enrichments=missing_enrichments,
    )

    return AssetDataAuditResponse(
        asset_id=str(asset_id),
        asset_name=asset.name,
        summary=OverallSummary(
            main_table=main_table_stats,
            enrichments=enrichment_stats,
            overall=overall_stats,
        ),
        categories=category_stats,
        enrichments=enrichment_data,
        jsonb_expanded=jsonb_expanded,
        data_gaps=data_gaps,
    )


async def audit_asset_summary(
    asset_id: str,
    db: AsyncSession,
    client_account_id: UUID,
    engagement_id: UUID,
) -> Dict[str, Any]:
    """
    Generate lightweight summary of an asset's data completeness.

    Uses COUNT queries instead of fetching full records for better performance.
    This is optimized for the summary endpoint that only needs statistics.

    Args:
        asset_id: UUID of the asset to audit
        db: Database session
        client_account_id: Tenant client account ID for scoping
        engagement_id: Engagement ID for scoping

    Returns:
        Dictionary with summary statistics and data gaps
    """
    # Fetch the asset with tenant scoping
    stmt = select(Asset).where(
        Asset.id == UUID(asset_id),
        Asset.client_account_id == client_account_id,
        Asset.engagement_id == engagement_id,
        Asset.deleted_at.is_(None),
    )
    result = await db.execute(stmt)
    asset = result.scalar_one_or_none()

    if not asset:
        raise ValueError(f"Asset not found: {asset_id}")

    # Get SQLAlchemy mapper for column inspection
    mapper = inspect(Asset)
    columns = mapper.columns

    # Calculate main table stats efficiently (no full data fetch needed)
    categories: Dict[str, Dict] = defaultdict(lambda: {"populated": 0, "total": 0})
    total_fields = 0
    populated_fields = 0

    for column in columns:
        col_name = column.name
        metadata = get_column_metadata(column)
        category = metadata["category"]

        try:
            value = getattr(asset, col_name, None)
            populated = is_value_populated(value)
        except Exception:
            populated = False

        categories[category]["total"] += 1
        total_fields += 1
        if populated:
            categories[category]["populated"] += 1
            populated_fields += 1

    # Build category summaries
    category_summaries = {}
    empty_categories = []
    low_completeness = []

    for cat_name, cat_data in categories.items():
        total = cat_data["total"]
        pop = cat_data["populated"]
        completeness = round((pop / total * 100) if total > 0 else 0, 1)
        category_summaries[cat_name] = {
            "populated": pop,
            "total": total,
            "completeness_pct": completeness,
        }
        if pop == 0 and total > 0:
            empty_categories.append(cat_name)
        elif 0 < completeness < 50:
            low_completeness.append(
                {"category": cat_name, "completeness_pct": completeness}
            )

    # Use efficient COUNT queries for enrichment stats
    enrichment_stats = await get_enrichment_summary_stats(db, UUID(asset_id))

    # Calculate enrichment summary (estimate based on existence)
    enrichment_existing = sum(1 for v in enrichment_stats.values() if v["exists"])
    enrichment_total = len(ENRICHMENT_TABLES)

    missing_enrichments = [
        key for key, data in enrichment_stats.items() if not data["exists"]
    ]

    # Calculate overall stats
    main_completeness = round(
        (populated_fields / total_fields * 100) if total_fields > 0 else 0, 1
    )
    enrichment_completeness = round(
        (enrichment_existing / enrichment_total * 100) if enrichment_total > 0 else 0,
        1,
    )

    return {
        "asset_id": str(asset_id),
        "asset_name": asset.name,
        "summary": {
            "main_table": {
                "total_fields": total_fields,
                "populated_fields": populated_fields,
                "completeness_pct": main_completeness,
            },
            "enrichments": {
                "total_fields": enrichment_total,
                "populated_fields": enrichment_existing,
                "completeness_pct": enrichment_completeness,
            },
            "overall": {
                "total_fields": total_fields + enrichment_total,
                "populated_fields": populated_fields + enrichment_existing,
                "completeness_pct": round(
                    (
                        (
                            (populated_fields + enrichment_existing)
                            / (total_fields + enrichment_total)
                            * 100
                        )
                        if (total_fields + enrichment_total) > 0
                        else 0
                    ),
                    1,
                ),
            },
        },
        "data_gaps": {
            "empty_categories": empty_categories,
            "low_completeness_categories": low_completeness,
            "missing_enrichments": missing_enrichments,
        },
        "category_summaries": category_summaries,
        "enrichment_status": enrichment_stats,
    }
