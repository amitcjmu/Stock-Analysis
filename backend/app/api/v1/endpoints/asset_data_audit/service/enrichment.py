"""
Asset Data Audit Enrichment Queries

Functions for querying enrichment tables for asset data.

Generated by CC (Claude Code) for Asset Data Review feature

Security: Enrichment queries use tenant scoping where available.
Tables without tenant columns rely on asset_id being pre-validated
against the tenant context before these queries run.
"""

import asyncio
import logging
from typing import Any, Dict, Set
from uuid import UUID

from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from ..schemas import EnrichmentTableInfo
from .utils import safe_json_value

logger = logging.getLogger(__name__)


# Enrichment tables configuration: (table_name, key, has_tenant_columns)
# Tables with has_tenant_columns=True will include client_account_id and
# engagement_id in their queries for additional security.
ENRICHMENT_TABLES = [
    ("asset_resilience", "resilience", False),
    ("asset_compliance_flags", "compliance_flags", False),
    ("asset_vulnerabilities", "vulnerabilities", False),
    ("asset_tech_debt", "tech_debt", False),
    ("asset_dependencies", "dependencies", True),
    ("asset_performance_metrics", "performance_metrics", False),
    ("asset_cost_optimization", "cost_optimization", False),
    ("asset_licenses", "licenses", False),
    ("asset_contacts", "contacts", True),
    ("asset_custom_attributes", "custom_attributes_table", True),
    ("asset_eol_assessments", "eol_assessments", True),
    ("asset_product_links", "product_links", False),
]

# Sensitive fields to redact from responses (PII, credentials, etc.)
SENSITIVE_FIELDS: Set[str] = {
    "password",
    "secret",
    "token",
    "api_key",
    "private_key",
    "credential",
    "license_key",
    "auth_token",
    "access_key",
    "secret_key",
}

# Fields to partially mask (show partial value for usability)
FIELDS_TO_MASK: Set[str] = {
    "email",
    "phone",
}


def _redact_sensitive_value(key: str, value: Any) -> Any:
    """Redact or mask sensitive field values."""
    key_lower = key.lower()

    # Full redaction for highly sensitive fields
    if any(sensitive in key_lower for sensitive in SENSITIVE_FIELDS):
        return "[REDACTED]"

    # Partial masking for PII fields
    if key_lower in FIELDS_TO_MASK and value:
        str_value = str(value)
        if key_lower == "email" and "@" in str_value:
            # Mask email: show first 2 chars and domain
            local, domain = str_value.rsplit("@", 1)
            masked_local = local[:2] + "***" if len(local) > 2 else "***"
            return f"{masked_local}@{domain}"
        elif key_lower == "phone" and len(str_value) > 4:
            # Mask phone: show last 4 digits
            return "***" + str_value[-4:]

    return value


def _process_record(record: Dict[str, Any]) -> Dict[str, Any]:
    """Process a record, applying redaction and safe JSON conversion."""
    return {
        k: _redact_sensitive_value(k, safe_json_value(v)) for k, v in record.items()
    }


async def get_enrichment_data(
    db: AsyncSession,
    asset_id: UUID,
    client_account_id: UUID,
    engagement_id: UUID,
) -> Dict[str, EnrichmentTableInfo]:
    """
    Fetch all enrichment table data for an asset concurrently.

    Security: Uses tenant scoping where available. The caller MUST validate
    that the asset_id belongs to the provided tenant context before calling.

    Args:
        db: Database session
        asset_id: UUID of the asset (must be pre-validated for tenant)
        client_account_id: Tenant client account ID
        engagement_id: Engagement ID

    Returns:
        Dictionary of enrichment table data with sensitive fields redacted
    """
    enrichment_data: Dict[str, EnrichmentTableInfo] = {}

    async def fetch_one_table(
        table_name: str, key: str, has_tenant_columns: bool
    ) -> None:
        """Fetch data from a single enrichment table with appropriate scoping."""
        try:
            # Build query with tenant scoping if available
            if has_tenant_columns:
                query = text(
                    f"SELECT * FROM migration.{table_name} "
                    f"WHERE asset_id = :asset_id "
                    f"AND client_account_id = :client_account_id "
                    f"AND engagement_id = :engagement_id"
                )
                params = {
                    "asset_id": str(asset_id),
                    "client_account_id": str(client_account_id),
                    "engagement_id": str(engagement_id),
                }
            else:
                # Tables without tenant columns - rely on pre-validated asset_id
                query = text(
                    f"SELECT * FROM migration.{table_name} WHERE asset_id = :asset_id"
                )
                params = {"asset_id": str(asset_id)}

            result = await db.execute(query, params)
            rows = result.mappings().all()

            if rows:
                # Process records with redaction
                records = [_process_record(dict(row)) for row in rows]
                enrichment_data[key] = EnrichmentTableInfo(
                    exists=True, record_count=len(rows), records=records
                )
            else:
                enrichment_data[key] = EnrichmentTableInfo(
                    exists=False, record_count=0, records=[]
                )
        except Exception as e:
            logger.warning(f"Error querying {table_name}: {e}")
            enrichment_data[key] = EnrichmentTableInfo(
                exists=False, record_count=0, records=[], error=str(e)
            )

    # Execute all table queries concurrently
    tasks = [
        fetch_one_table(table, key, has_tenant)
        for table, key, has_tenant in ENRICHMENT_TABLES
    ]
    await asyncio.gather(*tasks)

    return enrichment_data


async def get_enrichment_summary_stats(
    db: AsyncSession,
    asset_id: UUID,
    client_account_id: UUID,
    engagement_id: UUID,
) -> Dict[str, Dict[str, Any]]:
    """
    Fetch lightweight enrichment statistics using COUNT queries.

    More efficient than get_enrichment_data for summary endpoints
    as it only retrieves record counts, not full records.

    Security: Uses tenant scoping where available.
    """
    enrichment_stats: Dict[str, Dict[str, Any]] = {}

    async def count_one_table(
        table_name: str, key: str, has_tenant_columns: bool
    ) -> None:
        """Get record count from a single enrichment table."""
        try:
            if has_tenant_columns:
                query = text(
                    f"SELECT COUNT(*) FROM migration.{table_name} "
                    f"WHERE asset_id = :asset_id "
                    f"AND client_account_id = :client_account_id "
                    f"AND engagement_id = :engagement_id"
                )
                params = {
                    "asset_id": str(asset_id),
                    "client_account_id": str(client_account_id),
                    "engagement_id": str(engagement_id),
                }
            else:
                query = text(
                    f"SELECT COUNT(*) FROM migration.{table_name} "
                    f"WHERE asset_id = :asset_id"
                )
                params = {"asset_id": str(asset_id)}

            result = await db.execute(query, params)
            record_count = result.scalar() or 0
            enrichment_stats[key] = {
                "exists": record_count > 0,
                "record_count": record_count,
            }
        except Exception as e:
            logger.warning(f"Error counting {table_name}: {e}")
            enrichment_stats[key] = {"exists": False, "record_count": 0}

    # Execute all count queries concurrently
    tasks = [
        count_one_table(table, key, has_tenant)
        for table, key, has_tenant in ENRICHMENT_TABLES
    ]
    await asyncio.gather(*tasks)

    return enrichment_stats
