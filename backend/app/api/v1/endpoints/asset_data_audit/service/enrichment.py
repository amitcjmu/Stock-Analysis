"""
Asset Data Audit Enrichment Queries

Functions for querying enrichment tables for asset data.

Generated by CC (Claude Code) for Asset Data Review feature
"""

import asyncio
import logging
from typing import Any, Dict
from uuid import UUID

from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from ..schemas import EnrichmentTableInfo
from .utils import safe_json_value

logger = logging.getLogger(__name__)


# Enrichment tables to query (table_name, key)
ENRICHMENT_TABLES = [
    ("asset_resilience", "resilience"),
    ("asset_compliance_flags", "compliance_flags"),
    ("asset_vulnerabilities", "vulnerabilities"),
    ("asset_tech_debt", "tech_debt"),
    ("asset_dependencies", "dependencies"),
    ("asset_performance_metrics", "performance_metrics"),
    ("asset_cost_optimization", "cost_optimization"),
    ("asset_licenses", "licenses"),
    ("asset_contacts", "contacts"),
    ("asset_custom_attributes", "custom_attributes_table"),
    ("asset_eol_assessments", "eol_assessments"),
    ("asset_product_links", "product_links"),
]


async def get_enrichment_data(
    db: AsyncSession, asset_id: UUID
) -> Dict[str, EnrichmentTableInfo]:
    """Fetch all enrichment table data for an asset concurrently."""
    enrichment_data: Dict[str, EnrichmentTableInfo] = {}

    async def fetch_one_table(table_name: str, key: str) -> None:
        """Fetch data from a single enrichment table."""
        try:
            query = text(
                f"SELECT * FROM migration.{table_name} WHERE asset_id = :asset_id"
            )
            result = await db.execute(query, {"asset_id": str(asset_id)})
            rows = result.mappings().all()

            if rows:
                records = [
                    {k: safe_json_value(v) for k, v in dict(row).items()}
                    for row in rows
                ]
                enrichment_data[key] = EnrichmentTableInfo(
                    exists=True, record_count=len(rows), records=records
                )
            else:
                enrichment_data[key] = EnrichmentTableInfo(
                    exists=False, record_count=0, records=[]
                )
        except Exception as e:
            logger.warning(f"Error querying {table_name}: {e}")
            enrichment_data[key] = EnrichmentTableInfo(
                exists=False, record_count=0, records=[], error=str(e)
            )

    # Execute all table queries concurrently
    tasks = [fetch_one_table(table, key) for table, key in ENRICHMENT_TABLES]
    await asyncio.gather(*tasks)

    return enrichment_data


async def get_enrichment_summary_stats(
    db: AsyncSession, asset_id: UUID
) -> Dict[str, Dict[str, Any]]:
    """
    Fetch lightweight enrichment statistics using COUNT queries.

    More efficient than get_enrichment_data for summary endpoints
    as it only retrieves record counts, not full records.
    """
    enrichment_stats: Dict[str, Dict[str, Any]] = {}

    async def count_one_table(table_name: str, key: str) -> None:
        """Get record count from a single enrichment table."""
        try:
            query = text(
                f"SELECT COUNT(*) FROM migration.{table_name} WHERE asset_id = :asset_id"
            )
            result = await db.execute(query, {"asset_id": str(asset_id)})
            record_count = result.scalar() or 0
            enrichment_stats[key] = {
                "exists": record_count > 0,
                "record_count": record_count,
            }
        except Exception as e:
            logger.warning(f"Error counting {table_name}: {e}")
            enrichment_stats[key] = {"exists": False, "record_count": 0}

    # Execute all count queries concurrently
    tasks = [count_one_table(table, key) for table, key in ENRICHMENT_TABLES]
    await asyncio.gather(*tasks)

    return enrichment_stats
