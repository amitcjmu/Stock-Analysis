"""
Asset Data Audit Router

API endpoints for comprehensive asset data auditing and review.
Provides visibility into all data associated with an asset including
main table columns, enrichment tables, and JSONB contents.

Generated by CC (Claude Code) for Asset Data Review feature
"""

import logging
from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db
from app.core.context import get_request_context, RequestContext
from app.api.v1.auth.auth_utils import get_current_user
from app.models.client_account import User
from app.models.asset import Asset

from .schemas import AssetDataAuditResponse, AssetListResponse, AssetListItem
from .service import audit_asset, audit_asset_summary  # noqa: F401

router = APIRouter()
logger = logging.getLogger(__name__)


@router.get(
    "/assets",
    response_model=AssetListResponse,
    summary="List assets available for audit",
    description="Returns a list of assets that can be audited, with basic info.",
)
async def list_assets_for_audit(
    limit: int = Query(default=50, le=200, description="Maximum number of assets"),
    offset: int = Query(default=0, ge=0, description="Offset for pagination"),
    search: Optional[str] = Query(default=None, description="Search by asset name"),
    phase: Optional[str] = Query(
        default=None,
        description="Filter by current phase (discovery, assessment, etc.)",
    ),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
    context: RequestContext = Depends(get_request_context),
) -> AssetListResponse:
    """
    List assets available for data audit.

    Provides a quick overview of assets with basic completeness indicators
    to help users identify which assets to audit.
    """
    try:
        # Build base query with tenant scoping
        base_query = select(Asset).where(
            Asset.client_account_id == context.client_account_id,
            Asset.engagement_id == context.engagement_id,
            Asset.deleted_at.is_(None),
        )

        # Apply search filter with wildcard escaping to prevent injection
        if search:
            # Escape special LIKE characters
            search_term = (
                search.replace("\\", "\\\\").replace("%", "\\%").replace("_", "\\_")
            )
            base_query = base_query.where(
                Asset.name.ilike(f"%{search_term}%", escape="\\")
            )

        # Apply phase filter
        if phase:
            base_query = base_query.where(Asset.current_phase == phase)

        # Get total count
        count_query = select(func.count()).select_from(base_query.subquery())
        total_result = await db.execute(count_query)
        total = total_result.scalar() or 0

        # Get paginated results
        query = base_query.order_by(Asset.updated_at.desc()).offset(offset).limit(limit)
        result = await db.execute(query)
        assets = result.scalars().all()

        # Build response items
        items: List[AssetListItem] = []
        for asset in assets:
            items.append(
                AssetListItem(
                    id=str(asset.id),
                    name=asset.name,
                    current_phase=asset.current_phase,
                    assessment_flow_id=(
                        str(asset.assessment_flow_id)
                        if asset.assessment_flow_id
                        else None
                    ),
                )
            )

        return AssetListResponse(assets=items, total=total)

    except Exception as e:
        logger.exception(f"Error listing assets for audit: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list assets: {str(e)}",
        )


@router.get(
    "/{asset_id}",
    response_model=AssetDataAuditResponse,
    summary="Get comprehensive asset data audit",
    description="Returns all data associated with an asset, categorized and with gap analysis.",
)
async def get_asset_data_audit(
    asset_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
    context: RequestContext = Depends(get_request_context),
) -> AssetDataAuditResponse:
    """
    Get comprehensive data audit for a specific asset.

    Returns:
    - All main table columns organized by category
    - All enrichment table data (resilience, compliance, tech_debt, etc.)
    - Expanded JSONB column contents
    - Data gap analysis with completeness metrics
    """
    try:
        result = await audit_asset(
            asset_id=str(asset_id),
            db=db,
            client_account_id=context.client_account_id,
            engagement_id=context.engagement_id,
        )
        return result

    except ValueError as e:
        # Asset not found
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )
    except Exception as e:
        logger.exception(f"Error auditing asset {asset_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to audit asset: {str(e)}",
        )


@router.get(
    "/{asset_id}/summary",
    summary="Get quick summary of asset data completeness",
    description="Returns just the summary statistics without full field details.",
)
async def get_asset_audit_summary(
    asset_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
    context: RequestContext = Depends(get_request_context),
) -> dict:
    """
    Get quick summary of asset data completeness.

    Uses optimized COUNT queries for better performance.
    Useful for dashboards or quick checks where full data isn't needed.
    """
    try:
        # Use the optimized summary function with COUNT queries
        result = await audit_asset_summary(
            asset_id=str(asset_id),
            db=db,
            client_account_id=context.client_account_id,
            engagement_id=context.engagement_id,
        )
        return result

    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )
    except Exception as e:
        logger.exception(f"Error getting audit summary for asset {asset_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get audit summary: {str(e)}",
        )
