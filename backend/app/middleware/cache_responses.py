"""
Cache Response Handling Functions

This module provides functions for creating, extracting, and caching HTTP responses
in the cache middleware system.

Extracted from cache_middleware.py for modularization (file length > 400 lines).

CRITICAL: Contains bug fix #674 - Response body pre-rendering to prevent
"Response content shorter than Content-Length" errors.

Generated by CC (Claude Code)
"""

import json
from datetime import datetime
from typing import Any, Dict, Optional

from fastapi import Request, Response
from fastapi.responses import JSONResponse, StreamingResponse

from app.core.logging import get_logger
from app.middleware.cache_utils import generate_etag

logger = get_logger(__name__)


def create_cached_response(
    cached_data: Dict[str, Any], request: Request
) -> JSONResponse:
    """
    Create HTTP response from cached data.

    CRITICAL BUG FIX #674: This function includes body pre-rendering logic
    to ensure Content-Length header is set correctly, preventing
    "Response content shorter than Content-Length" errors.

    Args:
        cached_data: Cached response data with metadata
        request: Original FastAPI request

    Returns:
        JSONResponse: Response with cached data and appropriate headers
    """
    try:
        response_data = cached_data.get("data")
        cached_at = cached_data.get("cached_at")
        ttl = cached_data.get("ttl", 300)

        # Generate ETag for the cached data
        etag = generate_etag(response_data)

        # Calculate cache age
        cache_age = 0
        if cached_at:
            try:
                cached_time = datetime.fromisoformat(cached_at.replace("Z", "+00:00"))
                cache_age = int(
                    (
                        datetime.utcnow() - cached_time.replace(tzinfo=None)
                    ).total_seconds()
                )
            except Exception as e:
                logger.debug(f"Failed to calculate cache age: {e}")
                cache_age = 0

        # Create response with appropriate headers
        # CRITICAL FIX (#674): Pre-render body to ensure Content-Length is correct
        response = JSONResponse(content=response_data)

        # Force body rendering to ensure Content-Length header is set correctly
        # This prevents "Response content shorter than Content-Length" errors
        if not hasattr(response, "body") or not response.body:
            _ = response.body

        response.headers["ETag"] = f'"{etag}"'
        response.headers["Cache-Control"] = f"private, max-age={ttl}"
        response.headers["X-Cache"] = "HIT"
        response.headers["X-Cache-Age"] = str(cache_age)
        response.headers["Vary"] = "X-Client-Account-ID, X-Engagement-ID"

        return response

    except Exception as e:
        logger.error(f"Failed to create cached response: {e}")
        # Return a basic response if something goes wrong
        fallback_response = JSONResponse(
            content=cached_data.get("data", {}), headers={"X-Cache": "HIT_ERROR"}
        )
        # CRITICAL FIX (#674): Ensure fallback also has body rendered
        if not hasattr(fallback_response, "body") or not fallback_response.body:
            _ = fallback_response.body
        return fallback_response


async def extract_response_body(response: Response) -> Optional[Any]:
    """
    Extract JSON body from response handling different response types.

    Args:
        response: FastAPI response object

    Returns:
        Optional[Any]: Extracted response body or None if extraction fails
    """
    try:
        # Handle JSONResponse - get content directly
        if isinstance(response, JSONResponse):
            # For JSONResponse, we can access the content directly
            if hasattr(response, "body") and response.body:
                return json.loads(response.body.decode("utf-8"))
            # Fallback: try to get from rendered content
            elif hasattr(response, "content"):
                return response.content

        # Handle StreamingResponse - consume the stream
        elif isinstance(response, StreamingResponse):
            # StreamingResponse body is already consumed, we can't extract it here
            # This should be handled in _execute_and_cache_request before consumption
            logger.debug("Cannot extract body from already consumed StreamingResponse")
            return None

        # Handle regular Response with body attribute
        elif hasattr(response, "body") and response.body:
            body_bytes = response.body
            if isinstance(body_bytes, bytes):
                return json.loads(body_bytes.decode("utf-8"))
            elif isinstance(body_bytes, str):
                return json.loads(body_bytes)

        return None

    except (json.JSONDecodeError, UnicodeDecodeError) as e:
        logger.debug(f"Failed to decode response body as JSON: {e}")
        return None
    except Exception as e:
        logger.debug(f"Failed to extract response body: {e}")
        return None


async def cache_response(
    redis,
    circuit_breaker,
    cache_key: str,
    response: Response,
    cache_config: Dict[str, Any],
    request: Request,
):
    """
    Cache response data in Redis.

    Args:
        redis: Redis cache instance
        circuit_breaker: Circuit breaker for resilience
        cache_key: Cache key to store under
        response: Response to cache
        cache_config: Cache configuration dict
        request: Original request
    """
    if not redis or not redis.enabled:
        return

    try:
        # Only cache successful JSON responses
        if response.status_code != 200 or not response.headers.get(
            "content-type", ""
        ).startswith("application/json"):
            return

        # Extract response body
        response_body = await extract_response_body(response)
        if not response_body:
            return

        # Generate ETag
        etag = generate_etag(response_body)

        # Prepare cache data
        cache_data = {
            "data": response_body,
            "cached_at": datetime.utcnow().isoformat(),
            "ttl": cache_config.get("ttl", 300),
            "cache_type": cache_config.get("cache_type", "unknown"),
            "endpoint": request.url.path,
        }

        # Store in Redis with TTL
        ttl = cache_config.get("ttl", 300)
        success = await circuit_breaker.async_call(
            redis.set, cache_key, cache_data, ttl
        )

        if success:
            # Store ETag separately for conditional requests
            etag_key = f"{cache_key}:etag"
            await circuit_breaker.async_call(redis.set, etag_key, etag, ttl)

            # Add cache headers to original response
            response.headers["ETag"] = f'"{etag}"'
            response.headers["Cache-Control"] = f"private, max-age={ttl}"
            response.headers["Vary"] = "X-Client-Account-ID, X-Engagement-ID"

            logger.debug(f"Cached response for key: {cache_key}")

    except Exception as e:
        logger.debug(f"Failed to cache response: {e}")


async def cache_response_data(
    redis,
    circuit_breaker,
    cache_key: str,
    response_data: Any,
    cache_config: Dict[str, Any],
    request: Request,
):
    """
    Cache response data directly in Redis.

    Args:
        redis: Redis cache instance
        circuit_breaker: Circuit breaker for resilience
        cache_key: Cache key to store under
        response_data: Response data to cache
        cache_config: Cache configuration dict
        request: Original request
    """
    if not redis or not redis.enabled:
        return

    try:
        # Generate ETag
        etag = generate_etag(response_data)

        # Prepare cache data
        cache_data = {
            "data": response_data,
            "cached_at": datetime.utcnow().isoformat(),
            "ttl": cache_config.get("ttl", 300),
            "cache_type": cache_config.get("cache_type", "unknown"),
            "endpoint": request.url.path,
        }

        # Store in Redis with TTL
        ttl = cache_config.get("ttl", 300)
        success = await circuit_breaker.async_call(
            redis.set, cache_key, cache_data, ttl
        )

        if success:
            # Store ETag separately for conditional requests
            etag_key = f"{cache_key}:etag"
            await circuit_breaker.async_call(redis.set, etag_key, etag, ttl)

            logger.debug(f"Cached response data for key: {cache_key}")

    except Exception as e:
        logger.debug(f"Failed to cache response data: {e}")


__all__ = [
    "create_cached_response",
    "extract_response_body",
    "cache_response",
    "cache_response_data",
]
