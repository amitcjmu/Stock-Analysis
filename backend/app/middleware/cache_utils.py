"""
Cache Utility Functions

This module provides utility functions for cache key generation, request filtering,
and ETag generation used by the CacheMiddleware.

Extracted from cache_middleware.py for modularization (file length > 400 lines).

Generated by CC (Claude Code)
"""

import hashlib
import json
import re
from typing import Any, Dict, Optional

from fastapi import Request

from app.constants.cache_keys import CACHE_VERSION
from app.core.logging import get_logger

logger = get_logger(__name__)


# Endpoints that should be cached (pattern matching supported)
CACHEABLE_ENDPOINTS = {
    # User context endpoints (high value, stable data)
    r"/api/v1/context/me": {"ttl": 3600, "cache_type": "user_context"},
    r"/api/v1/context-establishment/clients": {
        "ttl": 1800,
        "cache_type": "client_data",
    },
    r"/api/v1/context-establishment/engagements": {
        "ttl": 1800,
        "cache_type": "engagement_data",
    },
    # Field mapping endpoints (frequently accessed during reviews)
    r"/api/v1/field-mappings/.*": {"ttl": 120, "cache_type": "field_mappings"},
    r"/api/v1/data-import/.*/mappings": {
        "ttl": 120,
        "cache_type": "field_mappings",
    },
    # Flow data endpoints (moderate volatility)
    r"/api/v1/flows/.*/complete": {"ttl": 300, "cache_type": "flow_state"},
    # Asset and analysis endpoints (expensive to compute)
    r"/api/v1/assets/.*/inventory": {"ttl": 900, "cache_type": "asset_data"},
    r"/api/v1/assets/.*/dependencies": {"ttl": 1800, "cache_type": "asset_data"},
    r"/api/v1/assets/list/paginated": {
        "ttl": 300,
        "cache_type": "asset_data",
    },  # For Assess flow pages
    r"/api/v1/sixr-analysis/.*": {"ttl": 3600, "cache_type": "agent_results"},
    # Admin endpoints (relatively stable)
    r"/api/v1/admin/clients": {"ttl": 300, "cache_type": "admin_data"},
    r"/api/v1/admin/active-users": {"ttl": 180, "cache_type": "admin_data"},
}

# Endpoints that should never be cached
EXCLUDED_ENDPOINTS = {
    r"/api/v1/auth/.*",  # Authentication endpoints
    r"/api/v1/health.*",  # Health checks
    r"/api/v1/monitoring/.*",  # Monitoring endpoints
    r".*websocket.*",  # WebSocket connections
}


def should_cache_request(request: Request) -> bool:
    """
    Determine if a request should be cached.

    Args:
        request: FastAPI request object

    Returns:
        bool: True if request should be cached, False otherwise
    """
    # Only cache GET requests
    if request.method != "GET":
        return False

    path = request.url.path

    # Check excluded endpoints first
    for pattern in EXCLUDED_ENDPOINTS:
        if re.match(pattern, path):
            return False

    # Check if path matches any cacheable endpoint
    for pattern in CACHEABLE_ENDPOINTS:
        if re.match(pattern, path):
            return True

    return False


def get_cache_config(path: str) -> Optional[Dict[str, Any]]:
    """
    Get cache configuration for an endpoint.

    Args:
        path: URL path to check

    Returns:
        Optional[Dict[str, Any]]: Cache configuration dict with ttl and cache_type,
                                  or None if not cacheable
    """
    for pattern, config in CACHEABLE_ENDPOINTS.items():
        if re.match(pattern, path):
            return config
    return None


def generate_cache_key(request: Request) -> Optional[str]:
    """
    Generate cache key with tenant isolation and security validation.

    Key structure: {version}:endpoint:{tenant_context}:{query_hash}:{user_context}

    Args:
        request: FastAPI request object

    Returns:
        Optional[str]: Generated cache key or None if key cannot be generated
    """
    try:
        # Extract tenant context from headers (required for multi-tenancy)
        client_account_id = request.headers.get("X-Client-Account-ID")
        engagement_id = request.headers.get("X-Engagement-ID")

        # Get user context from request state (set by auth middleware)
        user_id = getattr(request.state, "user_id", None)

        # Ensure we have minimum required context for security
        if not client_account_id and not user_id:
            logger.warning(
                f"Cannot cache request without tenant context: {request.url.path}"
            )
            return None

        # Base components
        path_key = request.url.path.replace("/api/v1/", "").replace("/", ":")

        # Create query hash for parameters (excluding sensitive data)
        query_params = dict(request.query_params)
        # Remove sensitive parameters that shouldn't be part of cache key
        sensitive_params = {"token", "password", "secret", "key"}
        filtered_params = {
            k: v for k, v in query_params.items() if k.lower() not in sensitive_params
        }

        query_hash = ""
        if filtered_params:
            query_string = json.dumps(filtered_params, sort_keys=True)
            query_hash = hashlib.sha256(query_string.encode()).hexdigest()[:16]

        # Build tenant-isolated cache key
        key_parts = [CACHE_VERSION, path_key]

        if client_account_id:
            key_parts.extend(["client", client_account_id])

        if engagement_id:
            key_parts.extend(["engagement", engagement_id])

        if user_id:
            key_parts.extend(["user", user_id])

        if query_hash:
            key_parts.extend(["query", query_hash])

        cache_key = ":".join(key_parts)

        # Ensure key length is reasonable (Redis has 512MB key limit, but we want efficiency)
        if len(cache_key) > 250:
            # Hash the key if it's too long
            key_hash = hashlib.sha256(cache_key.encode()).hexdigest()[:32]
            cache_key = f"{CACHE_VERSION}:hashed:{key_hash}"

        return cache_key

    except Exception as e:
        logger.error(f"Failed to generate cache key: {e}")
        return None


def generate_etag(data: Any) -> str:
    """
    Generate ETag for response data.

    Args:
        data: Response data to generate ETag for

    Returns:
        str: Generated ETag hash (32 character hex string)
    """
    try:
        # Create deterministic string representation
        data_string = json.dumps(data, sort_keys=True, default=str)
        # Generate hash
        return hashlib.sha256(data_string.encode()).hexdigest()[:32]
    except Exception:
        # Fallback to timestamp-based ETag
        import time

        return hashlib.sha256(str(time.time()).encode()).hexdigest()[:32]


__all__ = [
    "CACHEABLE_ENDPOINTS",
    "EXCLUDED_ENDPOINTS",
    "should_cache_request",
    "get_cache_config",
    "generate_cache_key",
    "generate_etag",
]
