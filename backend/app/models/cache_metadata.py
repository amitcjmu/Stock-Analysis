"""
Cache Metadata Models for AI Force Migration Platform

This module defines SQLAlchemy models for tracking cache operations, performance metrics,
and coherence in the Redis caching layer. All models follow the established patterns
from the existing codebase including multi-tenant isolation and proper foreign keys.

ðŸ”’ Security: All models include client_account_id for multi-tenant isolation
âš¡ Performance: Optimized indexes for cache lookup and analytics queries
ðŸŽ¯ Coherence: Support for cascade invalidation tracking
ðŸ“Š Analytics: Built-in performance metrics and audit trails

Generated by CC (Claude Code)
"""

from __future__ import annotations

from datetime import datetime
from typing import Optional

from sqlalchemy import (
    JSON,
    Boolean,
    CheckConstraint,
    Column,
    DateTime,
    Float,
    ForeignKey,
    Index,
    Integer,
    String,
    Text,
    UniqueConstraint,
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.core.database import Base
from app.models.base import TimestampMixin


class CacheMetadata(Base, TimestampMixin):
    """
    Tracks metadata for cached items including access patterns, expiration, and relationships.
    This is the primary table for cache coherence and performance monitoring.

    Design Principles:
    - Multi-tenant isolation via client_account_id
    - Optimized for high-volume cache operations
    - Supports cascade invalidation tracking
    - Includes performance analytics fields
    """

    __tablename__ = "cache_metadata"
    __table_args__ = (
        # Unique constraint on cache_key per tenant for data integrity
        UniqueConstraint(
            "cache_key", "client_account_id", name="uq_cache_metadata_key_tenant"
        ),
        # Optimized indexes for common query patterns
        Index(
            "ix_cache_metadata_entity_lookup",
            "entity_type",
            "entity_id",
            "client_account_id",
        ),
        Index("ix_cache_metadata_expiration", "expires_at"),
        Index("ix_cache_metadata_access_patterns", "last_accessed", "access_count"),
        Index("ix_cache_metadata_tenant_active", "client_account_id", "is_active"),
        # Partial index for active cache entries (most queries)
        Index(
            "ix_cache_metadata_active_keys",
            "cache_key",
            "client_account_id",
            postgresql_where=Column("is_active") == True,  # noqa: E712
        ),
        {"schema": "migration"},
    )

    id = Column(
        Integer,
        primary_key=True,
        comment="Unique identifier for the cache metadata record",
    )

    # Cache identification
    cache_key = Column(
        String(500),
        nullable=False,
        index=True,
        comment="The full Redis cache key including version and tenant information",
    )

    cache_key_type = Column(
        String(50),
        nullable=False,
        comment="Type of cache key for monitoring and metrics (from CacheKeyType enum)",
    )

    # Entity relationships for coherence
    entity_type = Column(
        String(50),
        nullable=False,
        comment="Type of entity being cached (user, flow, import, etc.)",
    )

    entity_id = Column(
        String(100), nullable=False, comment="ID of the primary entity being cached"
    )

    # Multi-tenant isolation
    client_account_id = Column(
        UUID(as_uuid=True),
        ForeignKey("client_accounts.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment="Client account this cache entry belongs to for tenant isolation",
    )

    engagement_id = Column(
        UUID(as_uuid=True),
        ForeignKey("engagements.id", ondelete="CASCADE"),
        nullable=True,
        comment="Optional engagement context for engagement-scoped cache entries",
    )

    # Cache lifecycle management
    ttl_seconds = Column(
        Integer, nullable=False, comment="Time-to-live in seconds for this cache entry"
    )

    expires_at = Column(
        DateTime(timezone=True),
        nullable=False,
        index=True,
        comment="Calculated expiration timestamp for cache cleanup",
    )

    is_active = Column(
        Boolean,
        nullable=False,
        default=True,
        comment="Whether this cache entry is currently active",
    )

    # Performance metrics
    access_count = Column(
        Integer,
        nullable=False,
        default=0,
        comment="Number of times this cache key has been accessed",
    )

    hit_count = Column(
        Integer, nullable=False, default=0, comment="Number of successful cache hits"
    )

    miss_count = Column(
        Integer,
        nullable=False,
        default=0,
        comment="Number of cache misses (key not found or expired)",
    )

    last_accessed = Column(
        DateTime(timezone=True), nullable=True, comment="Timestamp of last cache access"
    )

    avg_access_time_ms = Column(
        Float,
        nullable=True,
        comment="Average access time in milliseconds for performance monitoring",
    )

    # Cache content metadata
    data_size_bytes = Column(
        Integer,
        nullable=True,
        comment="Size of cached data in bytes for memory usage tracking",
    )

    compression_ratio = Column(
        Float,
        nullable=True,
        comment="Compression ratio if data is compressed (0.0-1.0)",
    )

    # Coherence and invalidation tracking
    parent_cache_keys = Column(
        JSON,
        nullable=True,
        default=list,
        comment="List of parent cache keys that trigger invalidation of this entry",
    )

    child_cache_keys = Column(
        JSON,
        nullable=True,
        default=list,
        comment="List of child cache keys that should be invalidated when this entry changes",
    )

    invalidation_triggers = Column(
        JSON,
        nullable=True,
        default=list,
        comment="List of events/operations that should invalidate this cache entry",
    )

    # Metadata and context
    cache_tags = Column(
        JSON,
        nullable=True,
        default=list,
        comment="Tags for cache organization and batch operations",
    )

    metadata = Column(
        JSON,
        nullable=True,
        default=dict,
        comment="Additional metadata about the cached content",
    )

    # Audit fields
    created_by_user_id = Column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="SET NULL"),
        nullable=True,
        comment="User who initiated the cache operation",
    )

    # Relationships
    client_account = relationship("ClientAccount", back_populates="cache_metadata")
    engagement = relationship("Engagement", lazy="select")
    created_by_user = relationship(
        "User", foreign_keys=[created_by_user_id], lazy="select"
    )

    # Cache performance and audit relationships
    performance_logs = relationship(
        "CachePerformanceLog",
        back_populates="cache_metadata",
        cascade="all, delete-orphan",
    )

    invalidation_logs = relationship(
        "CacheInvalidationLog",
        back_populates="cache_metadata",
        cascade="all, delete-orphan",
    )

    def __repr__(self):
        return (
            f"<CacheMetadata(id={self.id}, cache_key='{self.cache_key}', "
            f"entity_type='{self.entity_type}', client_account_id={self.client_account_id})>"
        )

    @property
    def hit_ratio(self) -> float:
        """Calculate cache hit ratio for this key."""
        total_requests = self.hit_count + self.miss_count
        if total_requests == 0:
            return 0.0
        return self.hit_count / total_requests

    @property
    def is_expired(self) -> bool:
        """Check if cache entry is expired."""
        if not self.expires_at:
            return False
        return datetime.utcnow() <= self.expires_at

    def update_access_metrics(self, was_hit: bool, access_time_ms: float):
        """Update access metrics for performance tracking."""
        self.access_count += 1
        if was_hit:
            self.hit_count += 1
        else:
            self.miss_count += 1

        self.last_accessed = func.now()

        # Update running average of access time
        if self.avg_access_time_ms is None:
            self.avg_access_time_ms = access_time_ms
        else:
            # Weighted average favoring recent measurements
            self.avg_access_time_ms = (
                self.avg_access_time_ms * 0.8 + access_time_ms * 0.2
            )


class CachePerformanceLog(Base, TimestampMixin):
    """
    Detailed performance logging for cache operations.
    Used for analytics, optimization, and troubleshooting.
    """

    __tablename__ = "cache_performance_logs"
    __table_args__ = (
        # Indexes for time-series analytics
        Index("ix_cache_perf_time_series", "created_at", "operation_type"),
        Index("ix_cache_perf_metadata_lookup", "cache_metadata_id", "created_at"),
        Index("ix_cache_perf_tenant_analytics", "client_account_id", "created_at"),
        {"schema": "migration"},
    )

    id = Column(
        Integer,
        primary_key=True,
        comment="Unique identifier for the performance log entry",
    )

    cache_metadata_id = Column(
        Integer,
        ForeignKey("migration.cache_metadata.id", ondelete="CASCADE"),
        nullable=False,
        comment="Reference to the cache metadata entry",
    )

    client_account_id = Column(
        UUID(as_uuid=True),
        ForeignKey("client_accounts.id", ondelete="CASCADE"),
        nullable=False,
        comment="Client account for tenant isolation",
    )

    # Operation details
    operation_type = Column(
        String(20),
        nullable=False,
        comment="Type of cache operation (GET, SET, DELETE, INVALIDATE)",
    )

    was_hit = Column(
        Boolean, nullable=False, comment="Whether the cache operation resulted in a hit"
    )

    response_time_ms = Column(
        Float,
        nullable=False,
        comment="Response time for the cache operation in milliseconds",
    )

    data_size_bytes = Column(
        Integer, nullable=True, comment="Size of data involved in the operation"
    )

    # Context information
    endpoint = Column(
        String(200),
        nullable=True,
        comment="API endpoint that triggered the cache operation",
    )

    user_id = Column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="SET NULL"),
        nullable=True,
        comment="User who initiated the operation",
    )

    session_id = Column(
        String(100), nullable=True, comment="Session identifier for request correlation"
    )

    # Error tracking
    error_message = Column(
        Text, nullable=True, comment="Error message if operation failed"
    )

    error_code = Column(
        String(50), nullable=True, comment="Error code for categorization"
    )

    # Additional metrics
    redis_memory_usage_mb = Column(
        Float, nullable=True, comment="Redis memory usage at time of operation"
    )

    concurrent_operations = Column(
        Integer, nullable=True, comment="Number of concurrent cache operations"
    )

    metadata = Column(
        JSON, nullable=True, default=dict, comment="Additional operation metadata"
    )

    # Relationships
    cache_metadata = relationship("CacheMetadata", back_populates="performance_logs")
    client_account = relationship("ClientAccount", lazy="select")
    user = relationship("User", lazy="select")

    def __repr__(self):
        return (
            f"<CachePerformanceLog(id={self.id}, operation='{self.operation_type}', "
            f"hit={self.was_hit}, response_time={self.response_time_ms}ms)>"
        )


class CacheInvalidationLog(Base, TimestampMixin):
    """
    Audit log for cache invalidation operations.
    Tracks what was invalidated, why, and the cascade effects.
    """

    __tablename__ = "cache_invalidation_logs"
    __table_args__ = (
        Index("ix_cache_invalidation_time_series", "created_at", "invalidation_type"),
        Index("ix_cache_invalidation_metadata", "cache_metadata_id", "created_at"),
        Index(
            "ix_cache_invalidation_trigger", "trigger_entity_type", "trigger_entity_id"
        ),
        {"schema": "migration"},
    )

    id = Column(
        Integer,
        primary_key=True,
        comment="Unique identifier for the invalidation log entry",
    )

    cache_metadata_id = Column(
        Integer,
        ForeignKey("migration.cache_metadata.id", ondelete="CASCADE"),
        nullable=True,
        comment="Reference to the cache metadata entry that was invalidated",
    )

    client_account_id = Column(
        UUID(as_uuid=True),
        ForeignKey("client_accounts.id", ondelete="CASCADE"),
        nullable=False,
        comment="Client account for tenant isolation",
    )

    # Invalidation details
    invalidation_type = Column(
        String(30),
        nullable=False,
        comment="Type of invalidation (EXPLICIT, CASCADE, EXPIRATION, MANUAL)",
    )

    cache_key_pattern = Column(
        String(500),
        nullable=False,
        comment="The cache key or pattern that was invalidated",
    )

    keys_invalidated_count = Column(
        Integer,
        nullable=False,
        default=1,
        comment="Number of cache keys invalidated by this operation",
    )

    # Trigger information
    trigger_entity_type = Column(
        String(50),
        nullable=True,
        comment="Type of entity that triggered the invalidation",
    )

    trigger_entity_id = Column(
        String(100),
        nullable=True,
        comment="ID of entity that triggered the invalidation",
    )

    trigger_operation = Column(
        String(50),
        nullable=True,
        comment="Operation that triggered invalidation (CREATE, UPDATE, DELETE)",
    )

    # User and context
    user_id = Column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="SET NULL"),
        nullable=True,
        comment="User who initiated the operation that caused invalidation",
    )

    endpoint = Column(
        String(200),
        nullable=True,
        comment="API endpoint that triggered the invalidation",
    )

    # Performance impact
    invalidation_time_ms = Column(
        Float,
        nullable=True,
        comment="Time taken to complete the invalidation in milliseconds",
    )

    cascade_depth = Column(
        Integer,
        nullable=False,
        default=0,
        comment="Depth of cascade invalidation (0 for direct invalidation)",
    )

    # Metadata
    reason = Column(
        Text, nullable=True, comment="Human-readable reason for the invalidation"
    )

    metadata = Column(
        JSON, nullable=True, default=dict, comment="Additional invalidation metadata"
    )

    # Relationships
    cache_metadata = relationship("CacheMetadata", back_populates="invalidation_logs")
    client_account = relationship("ClientAccount", lazy="select")
    user = relationship("User", lazy="select")

    def __repr__(self):
        return (
            f"<CacheInvalidationLog(id={self.id}, type='{self.invalidation_type}', "
            f"pattern='{self.cache_key_pattern}', count={self.keys_invalidated_count})>"
        )


class CacheConfiguration(Base, TimestampMixin):
    """
    Configuration settings for cache behavior per client account.
    Allows customization of TTLs, eviction policies, and feature flags.
    """

    __tablename__ = "cache_configurations"
    __table_args__ = (
        UniqueConstraint("client_account_id", name="uq_cache_config_client"),
        {"schema": "migration"},
    )

    id = Column(
        Integer,
        primary_key=True,
        comment="Unique identifier for the cache configuration",
    )

    client_account_id = Column(
        UUID(as_uuid=True),
        ForeignKey("client_accounts.id", ondelete="CASCADE"),
        nullable=False,
        unique=True,
        comment="Client account this configuration applies to",
    )

    # Feature flags
    cache_enabled = Column(
        Boolean,
        nullable=False,
        default=True,
        comment="Whether caching is enabled for this client",
    )

    distributed_cache_enabled = Column(
        Boolean,
        nullable=False,
        default=True,
        comment="Whether distributed caching features are enabled",
    )

    cache_analytics_enabled = Column(
        Boolean,
        nullable=False,
        default=True,
        comment="Whether cache analytics and logging are enabled",
    )

    # TTL overrides (in seconds, null means use defaults)
    user_context_ttl = Column(
        Integer, nullable=True, comment="Custom TTL for user context cache entries"
    )

    field_mapping_ttl = Column(
        Integer, nullable=True, comment="Custom TTL for field mapping cache entries"
    )

    flow_state_ttl = Column(
        Integer, nullable=True, comment="Custom TTL for flow state cache entries"
    )

    agent_results_ttl = Column(
        Integer, nullable=True, comment="Custom TTL for agent execution results"
    )

    # Performance settings
    max_cache_size_mb = Column(
        Integer, nullable=True, comment="Maximum cache size for this client in MB"
    )

    eviction_policy = Column(
        String(20),
        nullable=False,
        default="LRU",
        comment="Cache eviction policy (LRU, LFU, TTL)",
    )

    # Security settings
    encryption_enabled = Column(
        Boolean,
        nullable=False,
        default=False,
        comment="Whether sensitive cache data should be encrypted",
    )

    pii_cache_enabled = Column(
        Boolean, nullable=False, default=False, comment="Whether PII data can be cached"
    )

    # Custom settings
    custom_settings = Column(
        JSON,
        nullable=True,
        default=dict,
        comment="Client-specific custom cache settings",
    )

    # Monitoring thresholds
    alert_hit_ratio_threshold = Column(
        Float,
        nullable=True,
        default=0.7,
        comment="Alert when hit ratio falls below this threshold",
    )

    alert_response_time_threshold_ms = Column(
        Float,
        nullable=True,
        default=100.0,
        comment="Alert when average response time exceeds this threshold",
    )

    # Relationships
    client_account = relationship("ClientAccount", lazy="select")

    def __repr__(self):
        return (
            f"<CacheConfiguration(id={self.id}, client_account_id={self.client_account_id}, "
            f"cache_enabled={self.cache_enabled})>"
        )

    def get_ttl_for_key_type(self, key_type: str) -> Optional[int]:
        """Get custom TTL for a specific key type, or None to use defaults."""
        ttl_map = {
            "user_context": self.user_context_ttl,
            "field_mappings": self.field_mapping_ttl,
            "flow_state": self.flow_state_ttl,
            "agent_results": self.agent_results_ttl,
        }
        return ttl_map.get(key_type)


# Add the relationship back to ClientAccount
# This will be added to the ClientAccount model via migration or model extension
def add_cache_relationships_to_client_account():
    """
    Helper function to add cache-related relationships to ClientAccount.
    This should be called during model initialization or added directly to the ClientAccount model.
    """
    try:
        from app.models.client_account import ClientAccount

        # Add relationships if they don't exist
        if not hasattr(ClientAccount, "cache_metadata"):
            ClientAccount.cache_metadata = relationship(
                "CacheMetadata",
                back_populates="client_account",
                cascade="all, delete-orphan",
                lazy="select",
            )

        if not hasattr(ClientAccount, "cache_configuration"):
            ClientAccount.cache_configuration = relationship(
                "CacheConfiguration",
                uselist=False,  # One-to-one relationship
                cascade="all, delete-orphan",
                lazy="select",
            )

    except ImportError:
        # Models not available during initial setup
        pass


# Constraints to ensure data integrity
def get_model_constraints():
    """Get additional constraints that should be added via migration."""
    return [
        # Cache metadata constraints
        CheckConstraint("ttl_seconds > 0", name="ck_cache_metadata_positive_ttl"),
        CheckConstraint(
            "access_count >= 0", name="ck_cache_metadata_positive_access_count"
        ),
        CheckConstraint("hit_count >= 0", name="ck_cache_metadata_positive_hit_count"),
        CheckConstraint(
            "miss_count >= 0", name="ck_cache_metadata_positive_miss_count"
        ),
        CheckConstraint(
            "compression_ratio >= 0.0 AND compression_ratio <= 1.0",
            name="ck_cache_metadata_valid_compression_ratio",
        ),
        # Performance log constraints
        CheckConstraint(
            "response_time_ms >= 0", name="ck_cache_perf_positive_response_time"
        ),
        CheckConstraint(
            "operation_type IN ('GET', 'SET', 'DELETE', 'INVALIDATE', 'EXISTS')",
            name="ck_cache_perf_valid_operation_type",
        ),
        # Invalidation log constraints
        CheckConstraint(
            "keys_invalidated_count > 0", name="ck_cache_invalidation_positive_count"
        ),
        CheckConstraint(
            "cascade_depth >= 0", name="ck_cache_invalidation_positive_cascade_depth"
        ),
        CheckConstraint(
            "invalidation_type IN ('EXPLICIT', 'CASCADE', 'EXPIRATION', 'MANUAL', 'BATCH')",
            name="ck_cache_invalidation_valid_type",
        ),
        # Configuration constraints
        CheckConstraint(
            "max_cache_size_mb > 0", name="ck_cache_config_positive_max_size"
        ),
        CheckConstraint(
            "eviction_policy IN ('LRU', 'LFU', 'TTL', 'RANDOM')",
            name="ck_cache_config_valid_eviction_policy",
        ),
        CheckConstraint(
            "alert_hit_ratio_threshold >= 0.0 AND alert_hit_ratio_threshold <= 1.0",
            name="ck_cache_config_valid_hit_ratio_threshold",
        ),
    ]


# Export all models
__all__ = [
    "CacheMetadata",
    "CachePerformanceLog",
    "CacheInvalidationLog",
    "CacheConfiguration",
    "add_cache_relationships_to_client_account",
    "get_model_constraints",
]
