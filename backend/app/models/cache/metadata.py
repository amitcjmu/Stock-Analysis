"""
Cache Metadata Model

Tracks metadata for cached items including access patterns, expiration, and relationships.
This is the primary table for cache coherence and performance monitoring.

Generated by CC (Claude Code)
"""

from __future__ import annotations

from datetime import datetime, timezone
from sqlalchemy import (
    JSON,
    Boolean,
    Column,
    DateTime,
    Float,
    ForeignKey,
    Index,
    Integer,
    String,
    UniqueConstraint,
    text,
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.core.database import Base
from app.models.base import TimestampMixin


class CacheMetadata(Base, TimestampMixin):
    """
    Tracks metadata for cached items including access patterns, expiration, and relationships.
    This is the primary table for cache coherence and performance monitoring.

    Design Principles:
    - Multi-tenant isolation via client_account_id
    - Optimized for high-volume cache operations
    - Supports cascade invalidation tracking
    - Includes performance analytics fields
    """

    __tablename__ = "cache_metadata"
    __table_args__ = (
        # Unique constraint on cache_key per tenant for data integrity
        UniqueConstraint(
            "cache_key", "client_account_id", name="uq_cache_metadata_key_tenant"
        ),
        # Optimized indexes for common query patterns
        Index(
            "ix_cache_metadata_entity_lookup",
            "entity_type",
            "entity_id",
            "client_account_id",
        ),
        Index("ix_cache_metadata_expiration", "expires_at"),
        Index("ix_cache_metadata_access_patterns", "last_accessed", "access_count"),
        Index("ix_cache_metadata_tenant_active", "client_account_id", "is_active"),
        # Partial index for active cache entries (most queries)
        Index(
            "ix_cache_metadata_active_keys",
            "cache_key",
            "client_account_id",
            postgresql_where=text("cache_metadata.is_active = TRUE"),
        ),
        {"schema": "migration"},
    )

    id = Column(
        Integer,
        primary_key=True,
        comment="Unique identifier for the cache metadata record",
    )

    # Cache identification
    cache_key = Column(
        String(500),
        nullable=False,
        index=True,
        comment="The full Redis cache key including version and tenant information",
    )

    cache_key_type = Column(
        String(50),
        nullable=False,
        comment="Type of cache key for monitoring and metrics (from CacheKeyType enum)",
    )

    # Entity relationships for coherence
    entity_type = Column(
        String(50),
        nullable=False,
        comment="Type of entity being cached (user, flow, import, etc.)",
    )

    entity_id = Column(
        String(100), nullable=False, comment="ID of the primary entity being cached"
    )

    # Multi-tenant isolation
    client_account_id = Column(
        UUID(as_uuid=True),
        ForeignKey("migration.client_accounts.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment="Client account this cache entry belongs to for tenant isolation",
    )

    engagement_id = Column(
        UUID(as_uuid=True),
        ForeignKey("migration.engagements.id", ondelete="CASCADE"),
        nullable=True,
        comment="Optional engagement context for engagement-scoped cache entries",
    )

    # Cache lifecycle management
    ttl_seconds = Column(
        Integer, nullable=False, comment="Time-to-live in seconds for this cache entry"
    )

    expires_at = Column(
        DateTime(timezone=True),
        nullable=False,
        index=True,
        comment="Calculated expiration timestamp for cache cleanup",
    )

    is_active = Column(
        Boolean,
        nullable=False,
        default=True,
        comment="Whether this cache entry is currently active",
    )

    # Performance metrics
    access_count = Column(
        Integer,
        nullable=False,
        default=0,
        comment="Number of times this cache key has been accessed",
    )

    hit_count = Column(
        Integer, nullable=False, default=0, comment="Number of successful cache hits"
    )

    miss_count = Column(
        Integer,
        nullable=False,
        default=0,
        comment="Number of cache misses (key not found or expired)",
    )

    last_accessed = Column(
        DateTime(timezone=True), nullable=True, comment="Timestamp of last cache access"
    )

    avg_access_time_ms = Column(
        Float,
        nullable=True,
        comment="Average access time in milliseconds for performance monitoring",
    )

    # Cache content metadata
    data_size_bytes = Column(
        Integer,
        nullable=True,
        comment="Size of cached data in bytes for memory usage tracking",
    )

    compression_ratio = Column(
        Float,
        nullable=True,
        comment="Compression ratio if data is compressed (0.0-1.0)",
    )

    # Coherence and invalidation tracking
    parent_cache_keys = Column(
        JSON,
        nullable=True,
        default=list,
        comment="List of parent cache keys that trigger invalidation of this entry",
    )

    child_cache_keys = Column(
        JSON,
        nullable=True,
        default=list,
        comment="List of child cache keys that should be invalidated when this entry changes",
    )

    invalidation_triggers = Column(
        JSON,
        nullable=True,
        default=list,
        comment="List of events/operations that should invalidate this cache entry",
    )

    # Metadata and context
    cache_tags = Column(
        JSON,
        nullable=True,
        default=list,
        comment="Tags for cache organization and batch operations",
    )

    cache_metadata = Column(
        JSON,
        nullable=True,
        default=dict,
        comment="Additional metadata about the cached content",
    )

    # Audit fields
    created_by_user_id = Column(
        UUID(as_uuid=True),
        ForeignKey("migration.users.id", ondelete="SET NULL"),
        nullable=True,
        comment="User who initiated the cache operation",
    )

    # Relationships
    client_account = relationship("ClientAccount", back_populates="cache_metadata")
    engagement = relationship("Engagement", lazy="select")
    created_by_user = relationship(
        "User", foreign_keys=[created_by_user_id], lazy="select"
    )

    # Cache performance and audit relationships
    performance_logs = relationship(
        "CachePerformanceLog",
        back_populates="cache_metadata",
        cascade="all, delete-orphan",
    )

    invalidation_logs = relationship(
        "CacheInvalidationLog",
        back_populates="cache_metadata",
        cascade="all, delete-orphan",
    )

    def __repr__(self):
        return (
            f"<CacheMetadata(id={self.id}, cache_key='{self.cache_key}', "
            f"entity_type='{self.entity_type}', client_account_id={self.client_account_id})>"
        )

    @property
    def hit_ratio(self) -> float:
        """Calculate cache hit ratio for this key."""
        total_requests = self.hit_count + self.miss_count
        if total_requests == 0:
            return 0.0
        return self.hit_count / total_requests

    @property
    def is_expired(self) -> bool:
        """Check if cache entry is expired."""
        if not self.expires_at:
            return False
        # Use timezone-aware comparison
        now = datetime.now(timezone.utc)
        # Handle both naive and aware datetimes
        if self.expires_at.tzinfo is None:
            # If expires_at is naive, assume it's UTC
            expires_at_aware = self.expires_at.replace(tzinfo=timezone.utc)
        else:
            expires_at_aware = self.expires_at
        return now >= expires_at_aware

    def update_access_metrics(self, was_hit: bool, access_time_ms: float):
        """Update access metrics for performance tracking."""
        self.access_count += 1
        if was_hit:
            self.hit_count += 1
        else:
            self.miss_count += 1

        self.last_accessed = func.now()

        # Update running average of access time
        if self.avg_access_time_ms is None:
            self.avg_access_time_ms = access_time_ms
        else:
            # Weighted average favoring recent measurements
            self.avg_access_time_ms = (
                self.avg_access_time_ms * 0.8 + access_time_ms * 0.2
            )
