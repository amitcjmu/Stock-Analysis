"""
Redis Configuration and Connection Manager
Generated by CC DevSecOps Engineer

This module provides a comprehensive Redis connection manager with:
- Connection pooling and health monitoring
- Fallback mechanisms and circuit breaker pattern
- SSL/TLS support for production
- Security hardening and monitoring
- Support for both local Redis and Upstash Cloud
"""

import asyncio
import logging
import time
from datetime import datetime
from typing import Any, Dict, Optional

from app.core.config import settings
from app.core.upstash_config import upstash_optimizer

logger = logging.getLogger(__name__)


class CircuitBreaker:
    """Circuit breaker pattern for Redis connections"""

    def __init__(self, failure_threshold: int = 5, recovery_timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN

    async def call(self, func, *args, **kwargs):
        """Execute function with circuit breaker protection"""
        if self.state == "OPEN":
            if self._should_attempt_reset():
                self.state = "HALF_OPEN"
            else:
                raise ConnectionError("Circuit breaker is OPEN")

        try:
            result = await func(*args, **kwargs)
            if self.state == "HALF_OPEN":
                self.state = "CLOSED"
                self.failure_count = 0
            return result
        except Exception as e:
            self._record_failure()
            raise e

    def _record_failure(self):
        """Record a failure and potentially open the circuit"""
        self.failure_count += 1
        self.last_failure_time = time.time()

        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"
            logger.warning(
                f"Circuit breaker OPENED after {self.failure_count} failures"
            )

    def _should_attempt_reset(self) -> bool:
        """Check if we should attempt to reset the circuit"""
        return (
            self.last_failure_time
            and time.time() - self.last_failure_time > self.recovery_timeout
        )


class RedisConnectionManager:
    """Advanced Redis connection manager with health monitoring and fallbacks"""

    def __init__(self):
        self.enabled = settings.REDIS_ENABLED
        self.client = None
        self.client_type = None
        self.circuit_breaker = CircuitBreaker()
        self.health_status = {
            "connected": False,
            "last_check": None,
            "errors": [],
            "total_operations": 0,
            "failed_operations": 0,
        }

        # Connection pool settings
        self.pool_config = {
            "max_connections": 50,
            "socket_connect_timeout": 10,
            "socket_timeout": 10,
            "socket_keepalive": True,
            "retry_on_timeout": True,
            "health_check_interval": 30,
        }

        if not self.enabled:
            logger.info("Redis cache is disabled via configuration")
            return

        # Initialize connection
        asyncio.create_task(self.initialize())

    async def initialize(self) -> bool:
        """Initialize Redis connection with proper error handling"""
        try:
            # Try Upstash Redis first (production)
            if settings.UPSTASH_REDIS_URL:
                if await self._init_upstash_redis():
                    logger.info("Connected to Upstash Redis (Production)")
                    return True

            # Try local/standard Redis
            if settings.REDIS_URL:
                if await self._init_standard_redis():
                    logger.info(f"Connected to Redis ({self.client_type})")
                    return True

            # If all connections fail
            logger.warning("All Redis connections failed - running in fallback mode")
            self.enabled = False
            return False

        except Exception as e:
            logger.error(f"Redis initialization failed: {e}")
            self.enabled = False
            return False

    async def _init_upstash_redis(self) -> bool:
        """Initialize Upstash Redis connection"""
        try:
            from upstash_redis import Redis as UpstashRedis

            # Get optimized configuration from upstash_config
            config = upstash_optimizer.get_optimized_pool_config()

            # Remove 'url' from config to avoid duplicate parameter error
            # URL and token must be passed explicitly to UpstashRedis constructor
            config_without_url = {
                k: v for k, v in config.items() if k not in ["url", "token"]
            }

            self.client = UpstashRedis(
                url=settings.UPSTASH_REDIS_URL,
                token=settings.UPSTASH_REDIS_TOKEN,
                **config_without_url,
            )

            # Test connection
            await self._test_connection()

            self.client_type = "upstash"
            self.health_status["connected"] = True

            return True

        except ImportError:
            logger.warning("upstash-redis package not installed")
            return False
        except Exception as e:
            logger.error(f"Upstash Redis connection failed: {e}")
            return False

    async def _init_standard_redis(self) -> bool:
        """Initialize standard Redis connection (async or sync wrapper)"""
        try:
            # Try async Redis first
            try:
                import redis.asyncio as redis_async

                pool = redis_async.ConnectionPool.from_url(
                    settings.REDIS_URL, decode_responses=True, **self.pool_config
                )

                self.client = redis_async.Redis(connection_pool=pool)
                await self._test_connection()

                self.client_type = "async"
                self.health_status["connected"] = True
                return True

            except ImportError:
                logger.info(
                    "redis[asyncio] not available, falling back to sync wrapper"
                )

            # Fallback to sync Redis with async wrapper
            import redis

            pool = redis.ConnectionPool.from_url(
                settings.REDIS_URL,
                decode_responses=True,
                max_connections=self.pool_config["max_connections"],
                socket_connect_timeout=self.pool_config["socket_connect_timeout"],
                socket_timeout=self.pool_config["socket_timeout"],
                socket_keepalive=self.pool_config["socket_keepalive"],
                retry_on_timeout=self.pool_config["retry_on_timeout"],
            )

            sync_client = redis.Redis(connection_pool=pool)
            self.client = AsyncRedisWrapper(sync_client)

            await self._test_connection()

            self.client_type = "sync_wrapped"
            self.health_status["connected"] = True
            return True

        except Exception as e:
            logger.error(f"Standard Redis connection failed: {e}")
            return False

    async def _test_connection(self):
        """Test Redis connection with proper error handling"""
        if self.client_type == "upstash":
            # Upstash uses synchronous API
            result = self.client.ping()
        else:
            # Async or wrapped async
            result = await self.client.ping()

        if not result:
            raise ConnectionError("Redis ping failed")

    def is_available(self) -> bool:
        """Check if Redis is available and healthy"""
        return (
            self.enabled
            and self.client is not None
            and self.health_status["connected"]
            and self.circuit_breaker.state != "OPEN"
        )

    async def health_check(self) -> Dict[str, Any]:
        """Comprehensive health check with metrics"""
        health_info = {
            "enabled": self.enabled,
            "client_type": self.client_type,
            "circuit_breaker_state": self.circuit_breaker.state,
            "last_check": datetime.utcnow().isoformat(),
            **self.health_status,
        }

        if not self.is_available():
            health_info["status"] = "unavailable"
            return health_info

        try:
            # Test basic operations
            start_time = time.time()

            if self.client_type == "upstash":
                # Test Upstash connection
                self.client.ping()
                info = self.client.info("memory")
            else:
                # Test async/wrapped connection
                await self.client.ping()
                info = await self.client.info("memory")

            latency = (time.time() - start_time) * 1000

            health_info.update(
                {
                    "status": "healthy",
                    "latency_ms": round(latency, 2),
                    "memory_info": {
                        "used_memory": info.get("used_memory_human", "unknown"),
                        "used_memory_peak": info.get(
                            "used_memory_peak_human", "unknown"
                        ),
                        "memory_fragmentation_ratio": info.get(
                            "mem_fragmentation_ratio", 0
                        ),
                    },
                }
            )

            # Add Upstash-specific metrics
            if self.client_type == "upstash":
                try:
                    upstash_stats = await upstash_optimizer.get_usage_stats()
                    health_info["upstash_metrics"] = upstash_stats
                except Exception as e:
                    logger.debug(f"Could not fetch Upstash metrics: {e}")

            self.health_status["last_check"] = datetime.utcnow()

        except Exception as e:
            health_info.update({"status": "unhealthy", "error": str(e)})
            self.health_status["errors"].append(
                {"timestamp": datetime.utcnow().isoformat(), "error": str(e)}
            )
            # Keep only last 10 errors
            self.health_status["errors"] = self.health_status["errors"][-10:]

        return health_info

    async def execute_command(self, command: str, *args, **kwargs) -> Any:
        """Execute Redis command with circuit breaker and monitoring"""
        if not self.is_available():
            logger.debug(f"Redis unavailable, skipping command: {command}")
            return None

        # Check rate limits for Upstash
        if self.client_type == "upstash":
            if not await upstash_optimizer.check_rate_limit(command, *args):
                logger.warning(f"Rate limit exceeded for command: {command}")
                raise ConnectionError("Rate limit exceeded")

        try:
            self.health_status["total_operations"] += 1

            # Execute with circuit breaker protection
            if self.client_type == "upstash":
                result = await self.circuit_breaker.call(
                    lambda: getattr(self.client, command.lower())(*args, **kwargs)
                )
            else:
                result = await self.circuit_breaker.call(
                    getattr(self.client, command.lower()), *args, **kwargs
                )

            return result

        except Exception as e:
            self.health_status["failed_operations"] += 1
            logger.error(f"Redis command '{command}' failed: {e}")
            raise

    async def close(self):
        """Close Redis connection properly"""
        if self.client and hasattr(self.client, "close"):
            try:
                if self.client_type == "upstash":
                    # Upstash doesn't have explicit close
                    pass
                elif hasattr(self.client, "close"):
                    await self.client.close()

                logger.info("Redis connection closed")
            except Exception as e:
                logger.warning(f"Error closing Redis connection: {e}")

        self.client = None
        self.health_status["connected"] = False


class AsyncRedisWrapper:
    """
    Async wrapper for synchronous Redis client
    Uses thread pool to prevent blocking the event loop
    """

    def __init__(self, sync_client):
        self.sync_client = sync_client
        logger.info("Using synchronous Redis client with async wrapper")

    async def ping(self):
        """Async ping wrapper"""
        return await asyncio.to_thread(self.sync_client.ping)

    async def info(self, section: str = None):
        """Async info wrapper"""
        if section:
            return await asyncio.to_thread(self.sync_client.info, section)
        return await asyncio.to_thread(self.sync_client.info)

    async def get(self, key: str):
        """Async get wrapper"""
        return await asyncio.to_thread(self.sync_client.get, key)

    async def set(
        self, key: str, value: str, ex: Optional[int] = None, nx: bool = False
    ):
        """Async set wrapper"""
        return await asyncio.to_thread(self.sync_client.set, key, value, ex=ex, nx=nx)

    async def delete(self, *keys):
        """Async delete wrapper"""
        return await asyncio.to_thread(self.sync_client.delete, *keys)

    async def exists(self, *keys):
        """Async exists wrapper"""
        return await asyncio.to_thread(self.sync_client.exists, *keys)

    async def expire(self, key: str, time: int):
        """Async expire wrapper"""
        return await asyncio.to_thread(self.sync_client.expire, key, time)

    async def scan(self, cursor=0, match=None, count=100):
        """Async scan wrapper"""
        return await asyncio.to_thread(
            self.sync_client.scan, cursor, match=match, count=count
        )

    def pipeline(self):
        """Create async pipeline wrapper"""
        return AsyncPipelineWrapper(self.sync_client.pipeline())

    async def close(self):
        """Close connection pool"""
        await asyncio.to_thread(self.sync_client.close)


class AsyncPipelineWrapper:
    """Async wrapper for Redis pipeline"""

    def __init__(self, sync_pipeline):
        self.sync_pipeline = sync_pipeline

    def set(self, key: str, value: str, ex: Optional[int] = None):
        """Add set command to pipeline"""
        self.sync_pipeline.set(key, value, ex=ex)
        return self

    def delete(self, *keys):
        """Add delete command to pipeline"""
        self.sync_pipeline.delete(*keys)
        return self

    def expire(self, key: str, time: int):
        """Add expire command to pipeline"""
        self.sync_pipeline.expire(key, time)
        return self

    async def execute(self):
        """Execute pipeline commands"""
        return await asyncio.to_thread(self.sync_pipeline.execute)


# Global Redis manager instance
redis_manager = RedisConnectionManager()


def get_redis_manager() -> RedisConnectionManager:
    """Get the global Redis manager instance"""
    return redis_manager


async def ensure_redis_connection():
    """Ensure Redis connection is established"""
    if not redis_manager.is_available():
        success = await redis_manager.initialize()
        if not success:
            logger.warning("Redis connection could not be established")
    return redis_manager.is_available()
