"""
Upstash Redis Configuration and Optimization
Generated by CC DevSecOps Engineer

This module provides optimized configuration for Upstash Redis deployments,
including rate limiting, connection pooling, and performance optimization.
"""

import os
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List
from collections import deque
import asyncio

logger = logging.getLogger(__name__)


class UpstashOptimizer:
    """Optimize Redis operations for Upstash limits and pricing"""

    def __init__(self):
        self.url = os.getenv("UPSTASH_REDIS_URL", "")
        self.token = os.getenv("UPSTASH_REDIS_TOKEN", "")

        # Upstash limits (free tier)
        self.daily_command_limit = int(os.getenv("UPSTASH_DAILY_LIMIT", "10000"))
        self.max_request_size = 1048576  # 1MB
        self.max_response_size = 10485760  # 10MB
        self.max_connections = 50  # Concurrent connections
        self.max_pipeline_size = 100  # Commands per pipeline

        # Rate limiting
        self.rate_limiter = UpstashRateLimiter(self.daily_command_limit)

    def get_optimized_pool_config(self) -> Dict[str, Any]:
        """Get connection pool config optimized for Upstash"""
        # URL already validated during initialization
        config = {
            "url": self.url,
            "decode_responses": True,
            "encoding": "utf-8",
            "encoding_errors": "strict",
            # Connection settings optimized for Upstash
            "max_connections": self.max_connections,
            "socket_connect_timeout": 10,
            "socket_timeout": 10,
            "socket_keepalive": True,
            "socket_keepalive_options": {
                1: 10,  # TCP_KEEPIDLE
                2: 3,  # TCP_KEEPINTVL
                3: 3,  # TCP_KEEPCNT
            },
            # SSL/TLS (required for Upstash)
            "ssl": True,
            "ssl_cert_reqs": "required",
            "ssl_check_hostname": True,
            "ssl_ca_certs": None,  # Use system bundle
            # Retry configuration
            "retry_on_timeout": True,
            "retry_on_error": [ConnectionError, TimeoutError],
            "health_check_interval": 60,
        }

        return config

    def should_compress(self, data_size: int) -> bool:
        """Determine if data should be compressed for Upstash"""
        return data_size > 1024  # Compress if > 1KB

    def estimate_command_cost(self, command: str, *args) -> int:
        """Estimate command cost for rate limiting"""
        # Command costs based on Upstash pricing model
        costs = {
            # Basic operations
            "GET": 1,
            "SET": 1,
            "DEL": 1,
            "EXISTS": 1,
            "EXPIRE": 1,
            "TTL": 1,
            "PING": 1,
            # Hash operations
            "HGET": 1,
            "HSET": 1,
            "HMGET": len(args) if args else 1,
            "HMSET": len(args) // 2 if args else 1,
            "HGETALL": 5,  # Higher cost for bulk operations
            # Set operations
            "SADD": len(args) - 1 if args else 1,
            "SMEMBERS": 10,  # High cost for reading all members
            "SCARD": 1,
            # List operations
            "LPUSH": len(args) - 1 if args else 1,
            "RPUSH": len(args) - 1 if args else 1,
            "LRANGE": 5,  # Cost depends on range size
            "LLEN": 1,
            # Stream operations
            "XADD": 2,
            "XRANGE": 10,
            "XREVRANGE": 10,
            "XLEN": 1,
            # Administrative
            "SCAN": 10,
            "INFO": 1,
            "MEMORY": 2,
            "SLOWLOG": 1,
            # Pipeline operations
            "PIPELINE": 1,  # Base cost per command in pipeline
        }

        return costs.get(command.upper(), 1)

    def optimize_pipeline(self, commands: List[tuple]) -> List[List[tuple]]:
        """Split large pipelines into smaller batches for Upstash"""
        if len(commands) <= self.max_pipeline_size:
            return [commands]

        batches = []
        for i in range(0, len(commands), self.max_pipeline_size):
            batch = commands[i : i + self.max_pipeline_size]
            batches.append(batch)

        return batches

    async def check_rate_limit(self, command: str, *args) -> bool:
        """Check if command can be executed within rate limits"""
        cost = self.estimate_command_cost(command, *args)
        return await self.rate_limiter.check_rate_limit(cost)

    async def get_usage_stats(self) -> Dict[str, Any]:
        """Get current Upstash usage statistics"""
        return await self.rate_limiter.get_usage_stats()


class UpstashRateLimiter:
    """Rate limiter for Upstash Redis commands"""

    def __init__(self, daily_limit: int = 10000):
        self.daily_limit = daily_limit
        self.window_size = 86400  # 24 hours in seconds
        self.commands = deque()  # (timestamp, cost) tuples
        self.lock = asyncio.Lock()

        # Performance tracking
        self.total_commands = 0
        self.total_cost = 0
        self.window_start = datetime.utcnow()

    async def check_rate_limit(self, command_cost: int = 1) -> bool:
        """Check if command can be executed within rate limits"""
        async with self.lock:
            now = datetime.utcnow()
            cutoff = now - timedelta(seconds=self.window_size)

            # Remove old commands outside the window
            while self.commands and self.commands[0][0] < cutoff:
                self.commands.popleft()

            # Calculate current usage
            current_usage = sum(cost for _, cost in self.commands)

            # Check if adding this command would exceed limit
            if current_usage + command_cost > self.daily_limit:
                logger.warning(
                    f"Upstash rate limit would be exceeded: "
                    f"{current_usage + command_cost}/{self.daily_limit} commands"
                )
                return False

            # Add command to tracking
            self.commands.append((now, command_cost))
            self.total_commands += 1
            self.total_cost += command_cost

            return True

    async def get_usage_stats(self) -> Dict[str, Any]:
        """Get current usage statistics"""
        async with self.lock:
            now = datetime.utcnow()
            cutoff = now - timedelta(seconds=self.window_size)

            # Clean old entries
            while self.commands and self.commands[0][0] < cutoff:
                self.commands.popleft()

            current_usage = sum(cost for _, cost in self.commands)
            usage_percent = (current_usage / self.daily_limit) * 100

            # Calculate time until reset
            if self.commands:
                oldest = self.commands[0][0]
                time_until_reset = (
                    oldest + timedelta(seconds=self.window_size) - now
                ).total_seconds()
            else:
                time_until_reset = 0

            # Calculate average commands per hour
            window_hours = (now - self.window_start).total_seconds() / 3600
            avg_commands_per_hour = self.total_commands / max(window_hours, 1)

            return {
                "current_usage": current_usage,
                "daily_limit": self.daily_limit,
                "usage_percent": round(usage_percent, 2),
                "remaining": self.daily_limit - current_usage,
                "time_until_reset_seconds": max(0, int(time_until_reset)),
                "commands_in_window": len(self.commands),
                "total_commands": self.total_commands,
                "total_cost": self.total_cost,
                "avg_commands_per_hour": round(avg_commands_per_hour, 2),
                "estimated_daily_usage": round(avg_commands_per_hour * 24, 0),
                "window_start": self.window_start.isoformat(),
            }

    async def reset_stats(self):
        """Reset usage statistics (for testing or new billing period)"""
        async with self.lock:
            self.commands.clear()
            self.total_commands = 0
            self.total_cost = 0
            self.window_start = datetime.utcnow()


class UpstashMonitor:
    """Monitor Upstash Redis performance and costs"""

    def __init__(self, optimizer: UpstashOptimizer):
        self.optimizer = optimizer
        self.api_key = os.getenv("UPSTASH_API_KEY")
        self.database_id = os.getenv("UPSTASH_DATABASE_ID")

    async def get_database_stats(self) -> Optional[Dict[str, Any]]:
        """Get database statistics from Upstash API"""
        if not self.api_key or not self.database_id:
            logger.warning("Upstash API credentials not configured")
            return None

        try:
            import httpx

            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"https://api.upstash.com/v2/redis/database/{self.database_id}/stats",
                    headers={"Authorization": f"Bearer {self.api_key}"},
                )

                if response.status_code == 200:
                    return response.json()
                else:
                    logger.error(f"Upstash API error: {response.status_code}")
                    return None

        except Exception as e:
            logger.error(f"Failed to fetch Upstash stats: {e}")
            return None

    async def get_cost_estimate(self) -> Dict[str, Any]:
        """Estimate current month's cost based on usage"""
        stats = await self.optimizer.get_usage_stats()

        # Upstash pricing (approximate)
        free_tier_commands = 10000
        paid_tier_cost_per_100k = 0.20  # $0.20 per 100K commands

        monthly_estimate = stats["estimated_daily_usage"] * 30

        if monthly_estimate <= free_tier_commands:
            cost_estimate = 0.0
            tier = "free"
        else:
            excess_commands = monthly_estimate - free_tier_commands
            cost_estimate = (excess_commands / 100000) * paid_tier_cost_per_100k
            tier = "paid"

        return {
            "tier": tier,
            "estimated_monthly_commands": int(monthly_estimate),
            "estimated_monthly_cost_usd": round(cost_estimate, 2),
            "free_tier_remaining": max(0, free_tier_commands - stats["current_usage"]),
            "current_usage_percent": stats["usage_percent"],
            "days_until_limit": (
                stats["remaining"] / max(stats["estimated_daily_usage"] / 30, 1)
                if stats["estimated_daily_usage"] > 0
                else float("inf")
            ),
        }

    async def check_alerts(self) -> List[Dict[str, Any]]:
        """Check for usage alerts and warnings"""
        alerts = []
        stats = await self.optimizer.get_usage_stats()
        cost_estimate = await self.get_cost_estimate()

        # Usage alerts
        if stats["usage_percent"] > 90:
            alerts.append(
                {
                    "level": "critical",
                    "type": "rate_limit",
                    "message": f"Rate limit usage at {stats['usage_percent']:.1f}%",
                    "recommendation": "Implement caching optimization or upgrade plan",
                }
            )
        elif stats["usage_percent"] > 75:
            alerts.append(
                {
                    "level": "warning",
                    "type": "rate_limit",
                    "message": f"Rate limit usage at {stats['usage_percent']:.1f}%",
                    "recommendation": "Monitor usage closely",
                }
            )

        # Cost alerts
        if cost_estimate["estimated_monthly_cost_usd"] > 5.0:
            alerts.append(
                {
                    "level": "warning",
                    "type": "cost",
                    "message": f"Estimated monthly cost: ${cost_estimate['estimated_monthly_cost_usd']:.2f}",
                    "recommendation": "Review caching strategy for cost optimization",
                }
            )

        # Performance alerts
        if stats["avg_commands_per_hour"] > 400:  # High usage
            alerts.append(
                {
                    "level": "info",
                    "type": "performance",
                    "message": f"High command rate: {stats['avg_commands_per_hour']:.0f} commands/hour",
                    "recommendation": "Consider implementing connection pooling",
                }
            )

        return alerts


# Global instances
upstash_optimizer = UpstashOptimizer()
upstash_monitor = UpstashMonitor(upstash_optimizer)

# Configuration constants
UPSTASH_CONFIG = upstash_optimizer.get_optimized_pool_config()
