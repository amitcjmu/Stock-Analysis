"""
Secure Cache Service

Main service class that provides transparent encryption/decryption while maintaining
compatibility with the existing Redis cache infrastructure.

Generated by CC (Claude Code)
"""

from typing import Any, Dict, Optional, Set

from app.core.config import settings
from app.core.logging import get_logger
from app.services.caching.redis_cache import RedisCache
from app.constants.cache_keys.validators import SensitiveDataMarkers

from .config import FieldEncryptionConfig
from .encoder import SecureCacheEncoder

logger = get_logger(__name__)


class SecureCacheService:
    """
    Secure cache service that provides transparent encryption/decryption
    while maintaining compatibility with the existing Redis cache.
    """

    def __init__(self, redis_cache: RedisCache, encryption_key: Optional[bytes] = None):
        """
        Initialize secure cache service.

        Args:
            redis_cache: Redis cache instance
            encryption_key: Optional encryption key
        """
        self.redis = redis_cache
        self.encoder = SecureCacheEncoder(encryption_key)

        # Configuration
        self.encrypt_by_default = getattr(settings, "CACHE_ENCRYPT_BY_DEFAULT", False)
        self.secure_tenants: Set[str] = set()  # Tenants that require encryption

        # Performance tracking
        self.cache_ops = {
            "secure_gets": 0,
            "secure_sets": 0,
            "encryption_errors": 0,
            "decryption_errors": 0,
        }

    def add_secure_tenant(self, tenant_id: str):
        """Mark a tenant as requiring encryption for all cache operations."""
        self.secure_tenants.add(tenant_id)
        logger.info(f"Tenant {tenant_id} marked as secure (encryption required)")

    def remove_secure_tenant(self, tenant_id: str):
        """Remove tenant from secure tenants list."""
        self.secure_tenants.discard(tenant_id)
        logger.info(f"Tenant {tenant_id} removed from secure tenants")

    async def get_secure(
        self, cache_key: str, tenant_id: str, decrypt: bool = True
    ) -> Optional[Any]:
        """
        Get value from cache with automatic decryption.

        Args:
            cache_key: Cache key to retrieve
            tenant_id: Tenant ID for security context
            decrypt: Whether to decrypt the retrieved data

        Returns:
            Decrypted data or None if not found
        """
        try:
            self.cache_ops["secure_gets"] += 1

            # Get from Redis
            cached_data = await self.redis.get(cache_key)
            if not cached_data:
                return None

            # Check if data is encrypted
            if isinstance(cached_data, dict) and cached_data.get(
                "__encryption_metadata"
            ):

                if decrypt:
                    # Verify tenant access
                    metadata = cached_data["__encryption_metadata"]
                    if metadata.get("tenant_id") != tenant_id:
                        logger.warning(
                            f"Tenant {tenant_id} attempted to access cache for tenant {metadata.get('tenant_id')}"
                        )
                        return None

                    # Decrypt the data
                    return self.encoder.decrypt_data(cached_data)
                else:
                    # Return encrypted data as-is
                    return cached_data

            # Return plaintext data
            return cached_data

        except Exception as e:
            self.cache_ops["decryption_errors"] += 1
            logger.error(f"Failed to get secure cache data for key {cache_key}: {e}")
            return None

    async def set_secure(
        self,
        cache_key: str,
        data: Any,
        tenant_id: str,
        ttl: Optional[int] = None,
        force_encrypt: bool = False,
    ) -> bool:
        """
        Set value in cache with automatic encryption.

        Args:
            cache_key: Cache key to set
            data: Data to cache
            tenant_id: Tenant ID for security context
            ttl: Time to live in seconds
            force_encrypt: Force encryption even if not required

        Returns:
            True if set successfully
        """
        try:
            self.cache_ops["secure_sets"] += 1

            # Determine if encryption is needed using validators
            should_encrypt = (
                force_encrypt
                or SensitiveDataMarkers.requires_encryption(cache_key)
                or tenant_id in self.secure_tenants
                or self.encrypt_by_default
                or self._contains_sensitive_data(data)
            )

            # Encrypt data if needed
            if should_encrypt and isinstance(data, dict):
                # Get encryption context from validators
                encryption_context = SensitiveDataMarkers.get_encryption_context(
                    cache_key
                )
                encrypted_data = self.encoder.encrypt_data(data, tenant_id)
                # Add context to metadata if available
                if encryption_context and "__encryption_metadata" in encrypted_data:
                    encrypted_data["__encryption_metadata"][
                        "context"
                    ] = encryption_context
                cache_data = encrypted_data
            else:
                # Store plaintext
                cache_data = data

            # Set in Redis
            return await self.redis.set(cache_key, cache_data, ttl)

        except Exception as e:
            self.cache_ops["encryption_errors"] += 1
            logger.error(f"Failed to set secure cache data for key {cache_key}: {e}")
            return False

    async def delete_secure(self, cache_key: str, tenant_id: str) -> bool:
        """
        Delete value from cache with tenant verification.

        Args:
            cache_key: Cache key to delete
            tenant_id: Tenant ID for security verification

        Returns:
            True if deleted successfully
        """
        try:
            # For security, verify tenant access before deletion
            existing_data = await self.get_secure(cache_key, tenant_id, decrypt=False)
            if existing_data is None:
                return True  # Already doesn't exist

            # Check tenant access if data is encrypted
            if isinstance(existing_data, dict) and existing_data.get(
                "__encryption_metadata"
            ):
                metadata = existing_data["__encryption_metadata"]
                if metadata.get("tenant_id") != tenant_id:
                    logger.warning(
                        f"Tenant {tenant_id} attempted to delete cache for tenant {metadata.get('tenant_id')}"
                    )
                    return False

            # Delete from Redis
            return await self.redis.delete(cache_key)

        except Exception as e:
            logger.error(f"Failed to delete secure cache data for key {cache_key}: {e}")
            return False

    def _contains_sensitive_data(self, data: Any) -> bool:
        """Check if data contains sensitive fields that should be encrypted."""
        if not isinstance(data, dict):
            return False

        for field_name in data.keys():
            if FieldEncryptionConfig.should_encrypt_field(field_name):
                return True

        return False

    def get_security_stats(self) -> Dict[str, Any]:
        """Get security and performance statistics."""
        return {
            "secure_tenants_count": len(self.secure_tenants),
            "secure_tenants": list(self.secure_tenants),
            "encryption_stats": self.encoder.get_encryption_stats(),
            "cache_operations": self.cache_ops,
            "encrypt_by_default": self.encrypt_by_default,
        }


__all__ = ["SecureCacheService"]
