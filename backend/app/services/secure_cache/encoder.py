"""
Secure Cache Encoder

Handles encryption and decryption of cache data with field-level granularity.
Provides performance tracking and integrity verification.

Generated by CC (Claude Code)
"""

import base64
import hashlib
import json
import time
from datetime import datetime
from typing import Any, Dict, Optional

from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

from app.core.config import settings
from app.core.logging import get_logger

from .config import EncryptionLevel, FieldEncryptionConfig

logger = get_logger(__name__)


class SecureCacheEncoder:
    """
    Handles encryption and decryption of cache data with field-level granularity.
    """

    def __init__(self, encryption_key: Optional[bytes] = None):
        """
        Initialize secure cache encoder.

        Args:
            encryption_key: Base encryption key. If None, will generate from settings.
        """
        self.base_key = encryption_key or self._derive_base_key()
        self.ciphers: Dict[EncryptionLevel, Fernet] = {}
        self._initialize_ciphers()

        # Performance metrics
        self.encrypt_count = 0
        self.decrypt_count = 0
        self.encrypt_time_ms = 0
        self.decrypt_time_ms = 0

    def _derive_base_key(self) -> bytes:
        """Derive base encryption key from settings."""
        try:
            # Use SECRET_KEY from settings as base for key derivation
            secret = getattr(settings, "SECRET_KEY", "default-secret-key").encode()

            # Add salt for key derivation
            salt = b"cache_encryption_salt_v1"  # In production, use random salt stored securely

            # Derive key using PBKDF2
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=salt,
                iterations=100000,
            )

            return kdf.derive(secret)

        except Exception as e:
            logger.error(f"Failed to derive encryption key: {e}")
            raise ValueError(
                "Failed to derive encryption key from configuration. "
                "Ensure SECRET_KEY is properly set in environment variables. "
                "This is required for secure cache encryption and cannot use fallback keys in production."
            ) from e

    def _initialize_ciphers(self):
        """Initialize Fernet ciphers for different encryption levels."""
        try:
            # Create different keys for different encryption levels
            for level in EncryptionLevel:
                if level == EncryptionLevel.NONE:
                    continue

                # Derive level-specific key
                level_salt = f"cache_encrypt_{level.value}".encode()
                level_key = hashlib.pbkdf2_hmac(
                    "sha256",
                    self.base_key,
                    level_salt,
                    100000,  # iterations
                    32,  # key length
                )

                # Create Fernet cipher
                fernet_key = base64.urlsafe_b64encode(level_key)
                self.ciphers[level] = Fernet(fernet_key)

        except Exception as e:
            logger.error(f"Failed to initialize ciphers: {e}")
            raise

    def encrypt_field(
        self, field_name: str, value: Any, level: EncryptionLevel
    ) -> Dict[str, Any]:
        """
        Encrypt a field value.

        Args:
            field_name: Name of the field
            value: Value to encrypt
            level: Encryption level to use

        Returns:
            Dictionary with encrypted data and metadata
        """
        if level == EncryptionLevel.NONE or value is None:
            return {"value": value, "encrypted": False}

        try:
            start_time = time.time()

            # Convert value to string for encryption
            if isinstance(value, (dict, list)):
                value_str = json.dumps(value, default=str)
            else:
                value_str = str(value)

            # Encrypt the value
            cipher = self.ciphers.get(level)
            if not cipher:
                logger.warning(
                    f"No cipher for encryption level {level}, storing plaintext"
                )
                return {"value": value, "encrypted": False}

            encrypted_bytes = cipher.encrypt(value_str.encode("utf-8"))
            encrypted_str = base64.urlsafe_b64encode(encrypted_bytes).decode("utf-8")

            # Create integrity hash
            integrity_hash = hashlib.sha256(
                f"{field_name}:{value_str}:{level.value}".encode()
            ).hexdigest()[:16]

            elapsed_ms = (time.time() - start_time) * 1000
            self.encrypt_count += 1
            self.encrypt_time_ms += elapsed_ms

            return {
                "value": encrypted_str,
                "encrypted": True,
                "encryption_level": level.value,
                "integrity_hash": integrity_hash,
                "encrypted_at": datetime.utcnow().isoformat(),
            }

        except Exception as e:
            logger.error(f"Failed to encrypt field {field_name}: {e}")
            # Return plaintext on encryption failure
            return {"value": value, "encrypted": False, "error": str(e)}

    def decrypt_field(self, field_name: str, encrypted_data: Dict[str, Any]) -> Any:
        """
        Decrypt a field value.

        Args:
            field_name: Name of the field
            encrypted_data: Encrypted data dictionary

        Returns:
            Decrypted value
        """
        if not encrypted_data.get("encrypted", False):
            return encrypted_data.get("value")

        try:
            start_time = time.time()

            # Get encryption details
            encrypted_str = encrypted_data["value"]
            level_str = encrypted_data.get("encryption_level", "basic")
            level = EncryptionLevel(level_str)

            # Get cipher for this level
            cipher = self.ciphers.get(level)
            if not cipher:
                logger.error(f"No cipher for encryption level {level}")
                return None

            # Decrypt the value
            encrypted_bytes = base64.urlsafe_b64decode(encrypted_str.encode("utf-8"))
            decrypted_bytes = cipher.decrypt(encrypted_bytes)
            decrypted_str = decrypted_bytes.decode("utf-8")

            # Try to parse as JSON if it looks like JSON
            try:
                if decrypted_str.startswith(("{", "[", '"')) or decrypted_str in (
                    "true",
                    "false",
                    "null",
                ):
                    return json.loads(decrypted_str)
            except Exception:
                pass

            elapsed_ms = (time.time() - start_time) * 1000
            self.decrypt_count += 1
            self.decrypt_time_ms += elapsed_ms

            return decrypted_str

        except Exception as e:
            logger.error(f"Failed to decrypt field {field_name}: {e}")
            return None

    def encrypt_data(self, data: Dict[str, Any], tenant_id: str) -> Dict[str, Any]:
        """
        Encrypt sensitive fields in a data dictionary.

        Args:
            data: Data dictionary to encrypt
            tenant_id: Tenant ID for additional security context

        Returns:
            Data dictionary with encrypted fields
        """
        if not isinstance(data, dict):
            return data

        encrypted_data = {}
        encryption_metadata = {
            "encrypted_fields": [],
            "tenant_id": tenant_id,
            "encrypted_at": datetime.utcnow().isoformat(),
        }

        for field_name, value in data.items():
            # Check if field should be encrypted
            encryption_level = FieldEncryptionConfig.should_encrypt_field(field_name)

            if encryption_level and value is not None:
                # Encrypt the field
                encrypted_field = self.encrypt_field(
                    field_name, value, encryption_level
                )
                encrypted_data[field_name] = encrypted_field
                encryption_metadata["encrypted_fields"].append(
                    {
                        "field": field_name,
                        "level": encryption_level.value,
                        "encrypted": encrypted_field["encrypted"],
                    }
                )
            else:
                # Store plaintext
                encrypted_data[field_name] = {"value": value, "encrypted": False}

        # Add encryption metadata
        encrypted_data["__encryption_metadata"] = encryption_metadata

        return encrypted_data

    def decrypt_data(self, encrypted_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Decrypt fields in an encrypted data dictionary.

        Args:
            encrypted_data: Encrypted data dictionary

        Returns:
            Data dictionary with decrypted fields
        """
        if not isinstance(encrypted_data, dict):
            return encrypted_data

        decrypted_data = {}

        for field_name, field_data in encrypted_data.items():
            if field_name == "__encryption_metadata":
                continue  # Skip metadata

            if isinstance(field_data, dict) and "value" in field_data:
                # Decrypt field
                decrypted_value = self.decrypt_field(field_name, field_data)
                decrypted_data[field_name] = decrypted_value
            else:
                # Not encrypted field data
                decrypted_data[field_name] = field_data

        return decrypted_data

    def get_encryption_stats(self) -> Dict[str, Any]:
        """Get encryption performance statistics."""
        total_operations = self.encrypt_count + self.decrypt_count

        return {
            "encrypt_count": self.encrypt_count,
            "decrypt_count": self.decrypt_count,
            "total_operations": total_operations,
            "avg_encrypt_time_ms": (self.encrypt_time_ms / max(self.encrypt_count, 1)),
            "avg_decrypt_time_ms": (self.decrypt_time_ms / max(self.decrypt_count, 1)),
            "total_encrypt_time_ms": self.encrypt_time_ms,
            "total_decrypt_time_ms": self.decrypt_time_ms,
        }


__all__ = ["SecureCacheEncoder"]
