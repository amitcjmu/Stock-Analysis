"""
CrewAI Flow Utilities

Contains helper functions and utilities for CrewAI flows including:
- LLM configuration and management
- Agent configuration
- Common utility functions
- Factory functions

Generated by CC for modularization while maintaining backward compatibility.
"""

import logging
from typing import Any, Dict, Optional

from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db

logger = logging.getLogger(__name__)


class MockLLM:
    """Mock LLM for fallback when real LLM is not available."""

    def __call__(self, prompt: str) -> str:
        """Mock LLM call that returns a fallback response."""
        return "LLM not available - using fallback response"


class CrewAIFlowUtils:
    """
    Utility functions and helpers for CrewAI flows.

    This class provides common utility functions, LLM management,
    agent configuration, and other helper methods used across
    CrewAI flow operations.
    """

    def __init__(self, db: Optional[AsyncSession] = None):
        """
        Initialize the utilities.

        Args:
            db: Optional database session
        """
        self.db = db
        self._llm = None

    def get_llm(self):
        """
        Get the LLM instance for CrewAI agents.

        Returns:
            LLM instance or MockLLM if real LLM not available
        """
        if not self._llm:
            try:
                from app.services.llm_config import get_crewai_llm

                self._llm = get_crewai_llm()
                logger.info("‚úÖ LLM initialized for CrewAI flows")
            except ImportError as e:
                logger.error(f"‚ùå Failed to import LLM config: {e}")

                # Return a mock LLM for fallback
                self._llm = MockLLM()
        return self._llm

    def get_agents(self) -> Dict[str, Any]:
        """
        Get all CrewAI agents for the discovery flow.

        Note: UnifiedDiscoveryFlow uses crews managed by UnifiedFlowCrewManager,
        not individual agents. This method returns None for all agents to match
        the flow_initialization.py pattern.

        Returns:
            Dict with agent names as keys and None as values (crews handle agents)
        """
        logger.info(
            "‚úÖ UnifiedDiscoveryFlow uses crews - returning None for individual agents"
        )

        # Return None for all agents as they are managed by crews
        return {
            "orchestrator": None,  # Not needed - UnifiedFlowCrewManager handles orchestration
            "data_validation_agent": None,  # Replaced by data_import_validation_crew
            "attribute_mapping_agent": None,  # Replaced by field_mapping_crew
            "data_cleansing_agent": None,  # Replaced by data_cleansing_crew
            "asset_inventory_agent": None,  # Now handled by persistent agents
            "dependency_analysis_agent": None,  # Replaced by app_server_dependency_crew
            "tech_debt_analysis_agent": None,  # Replaced by technical_debt_crew
        }

    @staticmethod
    def validate_context(context: Dict[str, Any]) -> bool:
        """
        Validate that context contains required fields.

        Args:
            context: Context dictionary to validate

        Returns:
            True if context is valid, False otherwise
        """
        required_fields = ["client_account_id", "engagement_id"]

        for field in required_fields:
            if not context.get(field):
                logger.warning(f"‚ö†Ô∏è Missing required context field: {field}")
                return False

        return True

    @staticmethod
    def create_error_response(
        flow_id: str, phase: str, error: str, method: str = "unknown"
    ) -> Dict[str, Any]:
        """
        Create standardized error response.

        Args:
            flow_id: Flow ID where error occurred
            phase: Phase where error occurred
            error: Error message
            method: Method that generated the error

        Returns:
            Standardized error response dictionary
        """
        return {
            "status": "error",
            "flow_id": flow_id,
            "phase": phase,
            "error": error,
            "method": method,
            "timestamp": (
                logger.handlers[0].formatter.formatTime(
                    logging.LogRecord(
                        name="",
                        level=0,
                        pathname="",
                        lineno=0,
                        msg="",
                        args=(),
                        exc_info=None,
                    )
                )
                if logger.handlers
                else "unknown"
            ),
        }

    @staticmethod
    def create_success_response(
        flow_id: str, phase: str, results: Dict[str, Any], method: str = "unknown"
    ) -> Dict[str, Any]:
        """
        Create standardized success response.

        Args:
            flow_id: Flow ID for successful operation
            phase: Phase that completed successfully
            results: Results data
            method: Method that generated the response

        Returns:
            Standardized success response dictionary
        """
        return {
            "status": "success",
            "flow_id": flow_id,
            "phase": phase,
            "results": results,
            "method": method,
        }

    @staticmethod
    def extract_flow_context(
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        flow_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Extract and standardize flow context from various inputs.

        Args:
            client_account_id: Client account ID
            engagement_id: Engagement ID
            user_id: User ID
            flow_id: Flow ID
            **kwargs: Additional context fields

        Returns:
            Standardized context dictionary
        """
        context = {
            "client_account_id": client_account_id,
            "engagement_id": engagement_id,
            "user_id": user_id,
            "approved_by": user_id,  # Alias for compatibility
            "flow_id": flow_id,
        }

        # Add any additional context fields
        context.update(kwargs)

        # Remove None values
        context = {k: v for k, v in context.items() if v is not None}

        return context

    @staticmethod
    def log_operation_start(operation: str, flow_id: str, **kwargs) -> None:
        """
        Log the start of an operation with consistent formatting.

        Args:
            operation: Name of the operation
            flow_id: Flow ID
            **kwargs: Additional context to log
        """
        logger.info(f"üöÄ Starting {operation} for flow: {flow_id}")
        if kwargs:
            logger.info(f"   Context: {kwargs}")

    @staticmethod
    def log_operation_success(operation: str, flow_id: str, **kwargs) -> None:
        """
        Log successful completion of an operation.

        Args:
            operation: Name of the operation
            flow_id: Flow ID
            **kwargs: Additional context to log
        """
        logger.info(f"‚úÖ {operation} completed successfully for flow: {flow_id}")
        if kwargs:
            logger.info(f"   Results: {kwargs}")

    @staticmethod
    def log_operation_error(
        operation: str, flow_id: str, error: Exception, **kwargs
    ) -> None:
        """
        Log operation error with consistent formatting.

        Args:
            operation: Name of the operation
            flow_id: Flow ID
            error: Exception that occurred
            **kwargs: Additional context to log
        """
        logger.error(f"‚ùå {operation} failed for flow: {flow_id}")
        logger.error(f"   Error: {error}")
        if kwargs:
            logger.error(f"   Context: {kwargs}")

    @staticmethod
    def sanitize_data_for_logging(data: Any, max_length: int = 200) -> str:
        """
        Sanitize data for safe logging (remove sensitive info, truncate long strings).

        Args:
            data: Data to sanitize
            max_length: Maximum length for string representation

        Returns:
            Sanitized string representation of data
        """
        try:
            # Convert to string
            data_str = str(data)

            # Truncate if too long
            if len(data_str) > max_length:
                data_str = data_str[:max_length] + "..."

            # Remove potentially sensitive data patterns
            sensitive_patterns = [
                ("password", "***"),
                ("token", "***"),
                ("key", "***"),
                ("secret", "***"),
            ]

            data_lower = data_str.lower()
            for pattern, replacement in sensitive_patterns:
                if pattern in data_lower:
                    # This is a simple replacement - in production you'd want more sophisticated sanitization
                    logger.warning(
                        f"‚ö†Ô∏è Potential sensitive data detected in logs, pattern: {pattern}"
                    )

            return data_str

        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Failed to sanitize data for logging: {e}")
            return "<data_sanitization_failed>"

    @staticmethod
    def measure_execution_time(func):
        """
        Decorator to measure and log execution time of functions.

        Args:
            func: Function to measure

        Returns:
            Decorated function that logs execution time
        """
        import time
        from functools import wraps

        @wraps(func)
        async def async_wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                execution_time = time.time() - start_time
                logger.info(f"‚è±Ô∏è {func.__name__} completed in {execution_time:.2f}s")
                return result
            except Exception as e:
                execution_time = time.time() - start_time
                logger.error(
                    f"‚è±Ô∏è {func.__name__} failed after {execution_time:.2f}s: {e}"
                )
                raise

        @wraps(func)
        def sync_wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = func(*args, **kwargs)
                execution_time = time.time() - start_time
                logger.info(f"‚è±Ô∏è {func.__name__} completed in {execution_time:.2f}s")
                return result
            except Exception as e:
                execution_time = time.time() - start_time
                logger.error(
                    f"‚è±Ô∏è {func.__name__} failed after {execution_time:.2f}s: {e}"
                )
                raise

        # Return appropriate wrapper based on whether function is async
        import asyncio

        if asyncio.iscoroutinefunction(func):
            return async_wrapper
        else:
            return sync_wrapper


# Factory function for dependency injection
async def get_crewai_flow_utils(db: AsyncSession = None) -> CrewAIFlowUtils:
    """
    Factory function to create CrewAI Flow Utils with proper dependencies.

    Args:
        db: Optional database session

    Returns:
        CrewAIFlowUtils instance
    """
    if not db:
        # Get database session from dependency injection
        async with get_db() as session:
            return CrewAIFlowUtils(db=session)

    return CrewAIFlowUtils(db=db)


# Standalone utility functions for convenience
def validate_flow_context(context: Dict[str, Any]) -> bool:
    """Standalone context validation function."""
    return CrewAIFlowUtils.validate_context(context)


def create_flow_error_response(
    flow_id: str, phase: str, error: str, method: str = "unknown"
) -> Dict[str, Any]:
    """Standalone error response creation function."""
    return CrewAIFlowUtils.create_error_response(flow_id, phase, error, method)


def create_flow_success_response(
    flow_id: str, phase: str, results: Dict[str, Any], method: str = "unknown"
) -> Dict[str, Any]:
    """Standalone success response creation function."""
    return CrewAIFlowUtils.create_success_response(flow_id, phase, results, method)


def extract_standard_flow_context(**kwargs) -> Dict[str, Any]:
    """Standalone context extraction function."""
    return CrewAIFlowUtils.extract_flow_context(**kwargs)
