"""
WebSocket Cache Events System for AI Stock Assess Platform

This system provides real-time cache invalidation events via WebSocket connections,
enabling immediate cache synchronization across multiple clients and browser tabs.

ðŸ”’ Security: Multi-tenant isolation, secure connections, event validation
âš¡ Performance: Efficient event broadcasting, connection pooling, minimal latency
ðŸŽ¯ Coherence: Real-time cache sync, event ordering, reliable delivery
ðŸ“Š Analytics: Connection metrics, event tracking, performance monitoring

Generated by CC (Claude Code)
"""

import asyncio

# from uuid import UUID  # Unused
from collections import defaultdict

# import json  # Unused
# import time  # Unused
from datetime import datetime

# from datetime import timedelta  # Unused
from typing import Any, Dict, List, Optional, Set
from uuid import uuid4

from fastapi import WebSocket, WebSocketDisconnect
from starlette.websockets import WebSocketState

from app.core.logging import get_logger
from app.services.cache_invalidation import WebSocketCacheEvent

logger = get_logger(__name__)


class WebSocketConnection:
    """
    Represents a WebSocket connection with metadata for cache event delivery.
    """

    def __init__(
        self,
        websocket: WebSocket,
        connection_id: str,
        user_id: str,
        client_account_id: str,
        engagement_id: Optional[str] = None,
    ):
        self.websocket = websocket
        self.connection_id = connection_id
        self.user_id = user_id
        self.client_account_id = client_account_id
        self.engagement_id = engagement_id
        self.connected_at = datetime.utcnow()
        self.last_ping = datetime.utcnow()
        self.events_sent = 0
        self.events_failed = 0

        # Event filtering preferences
        self.subscribed_events: Set[str] = {
            "cache_invalidation",
            "user_context_changed",
            "field_mappings_updated",
            "flow_state_changed",
            "engagement_modified",
            "asset_inventory_updated",
        }

    @property
    def is_connected(self) -> bool:
        """Check if WebSocket is still connected."""
        return (
            self.websocket.client_state == WebSocketState.CONNECTED
            and self.websocket.application_state == WebSocketState.CONNECTED
        )

    @property
    def connection_age_seconds(self) -> int:
        """Get connection age in seconds."""
        return int((datetime.utcnow() - self.connected_at).total_seconds())

    async def send_event(self, event: Dict[str, Any]) -> bool:
        """
        Send cache event to this connection.

        Args:
            event: Event dictionary to send

        Returns:
            True if sent successfully, False otherwise
        """
        if not self.is_connected:
            return False

        try:
            # Check if client is subscribed to this event type
            event_type = event.get("data", {}).get("event_type", "unknown")
            if event_type not in self.subscribed_events:
                return True  # Not subscribed, but not an error

            # Add connection metadata
            enriched_event = {
                **event,
                "connection_id": self.connection_id,
                "sent_at": datetime.utcnow().isoformat(),
            }

            # Send the event
            await self.websocket.send_json(enriched_event)
            self.events_sent += 1

            logger.debug(
                f"Sent cache event {event_type} to connection {self.connection_id}"
            )

            return True

        except Exception as e:
            self.events_failed += 1
            logger.error(
                f"Failed to send event to connection {self.connection_id}: {e}"
            )
            return False

    async def send_ping(self) -> bool:
        """Send ping to keep connection alive."""
        try:
            if self.is_connected:
                await self.websocket.send_json(
                    {"type": "ping", "timestamp": datetime.utcnow().isoformat()}
                )
                self.last_ping = datetime.utcnow()
                return True
        except Exception as e:
            logger.debug(f"Failed to ping connection {self.connection_id}: {e}")
        return False

    def get_stats(self) -> Dict[str, Any]:
        """Get connection statistics."""
        return {
            "connection_id": self.connection_id,
            "user_id": self.user_id,
            "client_account_id": self.client_account_id,
            "engagement_id": self.engagement_id,
            "connected_at": self.connected_at.isoformat(),
            "connection_age_seconds": self.connection_age_seconds,
            "last_ping": self.last_ping.isoformat(),
            "events_sent": self.events_sent,
            "events_failed": self.events_failed,
            "subscribed_events": list(self.subscribed_events),
            "is_connected": self.is_connected,
        }


class WebSocketCacheEventManager:
    """
    Manages WebSocket connections and broadcasts cache invalidation events.

    Features:
    - Multi-tenant connection isolation
    - Event filtering and subscription management
    - Connection health monitoring and cleanup
    - Performance metrics and monitoring
    - Graceful error handling and recovery
    """

    def __init__(self):
        # Connection management
        self.connections: Dict[str, WebSocketConnection] = {}
        self.connections_by_tenant: Dict[str, Set[str]] = defaultdict(set)
        self.connections_by_user: Dict[str, Set[str]] = defaultdict(set)

        # Event queue and delivery tracking
        self.event_queue: List[Dict[str, Any]] = []
        self.max_queue_size = 1000
        self.events_sent = 0
        self.events_failed = 0

        # Health monitoring
        self.cleanup_interval = 60  # seconds
        self.ping_interval = 30  # seconds
        self.max_connection_age = 3600  # 1 hour

        # Start background tasks
        self._cleanup_task: Optional[asyncio.Task] = None
        self._ping_task: Optional[asyncio.Task] = None
        self._start_background_tasks()

    def _start_background_tasks(self):
        """Start background tasks for connection management."""
        try:
            # Start cleanup task
            if not self._cleanup_task or self._cleanup_task.done():
                self._cleanup_task = asyncio.create_task(self._cleanup_connections())

            # Start ping task
            if not self._ping_task or self._ping_task.done():
                self._ping_task = asyncio.create_task(self._ping_connections())

        except Exception as e:
            logger.error(f"Failed to start background tasks: {e}")

    async def connect(
        self,
        websocket: WebSocket,
        user_id: str,
        client_account_id: str,
        engagement_id: Optional[str] = None,
    ) -> str:
        """
        Register a new WebSocket connection.

        Args:
            websocket: WebSocket connection
            user_id: User ID for the connection
            client_account_id: Client account for tenant isolation
            engagement_id: Optional engagement context

        Returns:
            Connection ID
        """
        try:
            # Generate unique connection ID
            connection_id = str(uuid4())

            # Accept the WebSocket connection
            await websocket.accept()

            # Create connection object
            connection = WebSocketConnection(
                websocket, connection_id, user_id, client_account_id, engagement_id
            )

            # Register connection
            self.connections[connection_id] = connection
            self.connections_by_tenant[client_account_id].add(connection_id)
            self.connections_by_user[user_id].add(connection_id)

            logger.info(
                f"WebSocket connected: {connection_id} "
                f"(user: {user_id}, tenant: {client_account_id})"
            )

            # Send welcome message
            await connection.send_event(
                {
                    "type": "welcome",
                    "data": {
                        "connection_id": connection_id,
                        "message": "Cache events WebSocket connected",
                        "subscribed_events": list(connection.subscribed_events),
                    },
                }
            )

            # Ensure background tasks are running
            self._start_background_tasks()

            return connection_id

        except Exception as e:
            logger.error(f"Failed to connect WebSocket: {e}")
            raise

    async def disconnect(self, connection_id: str):
        """
        Disconnect and clean up a WebSocket connection.

        Args:
            connection_id: Connection ID to disconnect
        """
        try:
            connection = self.connections.get(connection_id)
            if not connection:
                return

            # Remove from indexes
            self.connections_by_tenant[connection.client_account_id].discard(
                connection_id
            )
            self.connections_by_user[connection.user_id].discard(connection_id)

            # Remove from main connections
            del self.connections[connection_id]

            logger.info(
                f"WebSocket disconnected: {connection_id} "
                f"(events sent: {connection.events_sent}, failed: {connection.events_failed})"
            )

        except Exception as e:
            logger.error(f"Failed to disconnect WebSocket {connection_id}: {e}")

    async def broadcast_to_tenant(
        self,
        client_account_id: str,
        event: Dict[str, Any],
        exclude_connection_id: Optional[str] = None,
    ) -> int:
        """
        Broadcast event to all connections for a specific tenant.

        Args:
            client_account_id: Client account to broadcast to
            event: Event to broadcast
            exclude_connection_id: Optional connection to exclude

        Returns:
            Number of connections that received the event
        """
        try:
            connection_ids = self.connections_by_tenant.get(client_account_id, set())
            if not connection_ids:
                logger.debug(f"No connections for tenant {client_account_id}")
                return 0

            sent_count = 0
            failed_connections = []

            for connection_id in connection_ids.copy():
                if connection_id == exclude_connection_id:
                    continue

                connection = self.connections.get(connection_id)
                if not connection:
                    failed_connections.append(connection_id)
                    continue

                success = await connection.send_event(event)
                if success:
                    sent_count += 1
                    self.events_sent += 1
                else:
                    self.events_failed += 1
                    failed_connections.append(connection_id)

            # Clean up failed connections
            for connection_id in failed_connections:
                await self.disconnect(connection_id)

            logger.debug(
                f"Broadcasted event to {sent_count} connections in tenant {client_account_id}"
            )

            return sent_count

        except Exception as e:
            logger.error(f"Failed to broadcast to tenant {client_account_id}: {e}")
            return 0

    async def broadcast_to_user(
        self,
        user_id: str,
        event: Dict[str, Any],
        exclude_connection_id: Optional[str] = None,
    ) -> int:
        """
        Broadcast event to all connections for a specific user.

        Args:
            user_id: User ID to broadcast to
            event: Event to broadcast
            exclude_connection_id: Optional connection to exclude

        Returns:
            Number of connections that received the event
        """
        try:
            connection_ids = self.connections_by_user.get(user_id, set())
            if not connection_ids:
                return 0

            sent_count = 0
            failed_connections = []

            for connection_id in connection_ids.copy():
                if connection_id == exclude_connection_id:
                    continue

                connection = self.connections.get(connection_id)
                if not connection:
                    failed_connections.append(connection_id)
                    continue

                success = await connection.send_event(event)
                if success:
                    sent_count += 1
                    self.events_sent += 1
                else:
                    self.events_failed += 1
                    failed_connections.append(connection_id)

            # Clean up failed connections
            for connection_id in failed_connections:
                await self.disconnect(connection_id)

            return sent_count

        except Exception as e:
            logger.error(f"Failed to broadcast to user {user_id}: {e}")
            return 0

    async def broadcast_cache_event(self, cache_event: WebSocketCacheEvent) -> int:
        """
        Broadcast a cache invalidation event to relevant connections.

        Args:
            cache_event: Cache event to broadcast

        Returns:
            Number of connections that received the event
        """
        try:
            event_dict = cache_event.to_dict()

            # Broadcast to tenant
            return await self.broadcast_to_tenant(
                cache_event.client_account_id, event_dict
            )

        except Exception as e:
            logger.error(f"Failed to broadcast cache event: {e}")
            return 0

    async def update_subscription(
        self, connection_id: str, subscribed_events: List[str]
    ) -> bool:
        """
        Update event subscription for a connection.

        Args:
            connection_id: Connection ID
            subscribed_events: List of event types to subscribe to

        Returns:
            True if updated successfully
        """
        try:
            connection = self.connections.get(connection_id)
            if not connection:
                return False

            connection.subscribed_events = set(subscribed_events)

            await connection.send_event(
                {
                    "type": "subscription_updated",
                    "data": {
                        "subscribed_events": subscribed_events,
                        "message": "Event subscription updated",
                    },
                }
            )

            return True

        except Exception as e:
            logger.error(f"Failed to update subscription for {connection_id}: {e}")
            return False

    async def _cleanup_connections(self):
        """Background task to clean up stale connections."""
        while True:
            try:
                await asyncio.sleep(self.cleanup_interval)

                current_time = datetime.utcnow()
                stale_connections = []

                for connection_id, connection in self.connections.items():
                    # Check if connection is stale
                    age_seconds = (
                        current_time - connection.connected_at
                    ).total_seconds()
                    last_ping_age = (
                        current_time - connection.last_ping
                    ).total_seconds()

                    if (
                        not connection.is_connected
                        or age_seconds > self.max_connection_age
                        or last_ping_age > self.ping_interval * 3
                    ):  # 3 missed pings
                        stale_connections.append(connection_id)

                # Clean up stale connections
                for connection_id in stale_connections:
                    await self.disconnect(connection_id)

                if stale_connections:
                    logger.info(
                        f"Cleaned up {len(stale_connections)} stale WebSocket connections"
                    )

            except Exception as e:
                logger.error(f"Error in connection cleanup: {e}")

    async def _ping_connections(self):
        """Background task to ping connections and keep them alive."""
        while True:
            try:
                await asyncio.sleep(self.ping_interval)

                ping_tasks = []
                for connection in self.connections.values():
                    if connection.is_connected:
                        ping_tasks.append(connection.send_ping())

                if ping_tasks:
                    results = await asyncio.gather(*ping_tasks, return_exceptions=True)
                    successful_pings = sum(1 for result in results if result is True)

                    logger.debug(
                        f"Pinged {successful_pings}/{len(ping_tasks)} WebSocket connections"
                    )

            except Exception as e:
                logger.error(f"Error in connection ping: {e}")

    def get_stats(self) -> Dict[str, Any]:
        """Get WebSocket manager statistics."""
        tenant_stats = {}
        for tenant_id, connection_ids in self.connections_by_tenant.items():
            active_connections = [
                self.connections[conn_id]
                for conn_id in connection_ids
                if conn_id in self.connections
            ]
            tenant_stats[tenant_id] = {
                "total_connections": len(active_connections),
                "events_sent": sum(conn.events_sent for conn in active_connections),
                "events_failed": sum(conn.events_failed for conn in active_connections),
            }

        return {
            "total_connections": len(self.connections),
            "connections_by_tenant": len(self.connections_by_tenant),
            "connections_by_user": len(self.connections_by_user),
            "total_events_sent": self.events_sent,
            "total_events_failed": self.events_failed,
            "tenant_stats": tenant_stats,
            "background_tasks": {
                "cleanup_running": self._cleanup_task and not self._cleanup_task.done(),
                "ping_running": self._ping_task and not self._ping_task.done(),
            },
        }

    async def shutdown(self):
        """Gracefully shutdown the WebSocket manager."""
        try:
            # Cancel background tasks
            if self._cleanup_task and not self._cleanup_task.done():
                self._cleanup_task.cancel()

            if self._ping_task and not self._ping_task.done():
                self._ping_task.cancel()

            # Disconnect all connections
            connection_ids = list(self.connections.keys())
            for connection_id in connection_ids:
                await self.disconnect(connection_id)

            logger.info("WebSocket manager shutdown complete")

        except Exception as e:
            logger.error(f"Error during WebSocket manager shutdown: {e}")


# Global WebSocket manager instance
_websocket_manager: Optional[WebSocketCacheEventManager] = None


def get_websocket_manager() -> WebSocketCacheEventManager:
    """Get the global WebSocket manager instance."""
    global _websocket_manager
    if _websocket_manager is None:
        _websocket_manager = WebSocketCacheEventManager()
    return _websocket_manager


async def handle_websocket_connection(
    websocket: WebSocket,
    user_id: str,
    client_account_id: str,
    engagement_id: Optional[str] = None,
):
    """
    Handle a WebSocket connection for cache events.

    This function should be called from a WebSocket endpoint to handle
    the connection lifecycle and message processing.
    """
    manager = get_websocket_manager()
    connection_id = None

    try:
        # Connect
        connection_id = await manager.connect(
            websocket, user_id, client_account_id, engagement_id
        )

        # Handle messages
        while True:
            try:
                # Receive message from client
                data = await websocket.receive_json()

                # Handle different message types
                message_type = data.get("type", "unknown")

                if message_type == "pong":
                    # Client responded to ping
                    logger.debug(f"Received pong from {connection_id}")

                elif message_type == "subscribe":
                    # Update event subscription
                    events = data.get("events", [])
                    await manager.update_subscription(connection_id, events)

                elif message_type == "get_stats":
                    # Send connection stats
                    connection = manager.connections.get(connection_id)
                    if connection:
                        await connection.send_event(
                            {"type": "stats", "data": connection.get_stats()}
                        )

                else:
                    logger.debug(
                        f"Unknown message type from {connection_id}: {message_type}"
                    )

            except WebSocketDisconnect:
                break
            except Exception as e:
                logger.error(f"Error handling WebSocket message: {e}")
                break

    finally:
        # Cleanup on disconnect
        if connection_id:
            await manager.disconnect(connection_id)


__all__ = [
    "WebSocketCacheEventManager",
    "WebSocketConnection",
    "get_websocket_manager",
    "handle_websocket_connection",
]
