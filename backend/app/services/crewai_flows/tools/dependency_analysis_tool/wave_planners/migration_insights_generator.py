"""
Migration insights generation for wave planning.

Generated by CC (Claude Code)
"""

from typing import Any, Dict, List

from ..base import (
    ANALYSIS_TYPE_BOTTLENECK,
    ANALYSIS_TYPE_CIRCULAR_DEPENDENCY,
    ANALYSIS_TYPE_LOW_COUPLING,
    ANALYSIS_TYPE_HIGH_COUPLING,
    ANALYSIS_TYPE_CRITICAL_PATH,
    LOW_COUPLING_THRESHOLD,
    HIGH_COUPLING_THRESHOLD,
    RISK_HIGH,
    RISK_MEDIUM,
    RISK_LOW,
)


class MigrationInsightsGenerator:
    """Generates migration insights based on dependency analysis."""

    @staticmethod
    def generate_migration_insights(
        dependency_graph: Dict[str, Any], critical_analysis: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """Generate migration insights based on dependency analysis"""
        insights = []

        # Insight about bottlenecks
        bottlenecks = critical_analysis.get("bottlenecks", [])
        if bottlenecks:
            top_bottleneck = bottlenecks[0]
            insights.append(
                {
                    "type": ANALYSIS_TYPE_BOTTLENECK,
                    "severity": RISK_HIGH,
                    "message": (
                        f"{top_bottleneck['node_name']} is a critical bottleneck with "
                        f"{top_bottleneck['total_connections']} dependencies"
                    ),
                    "recommendation": "Consider migrating this component early with careful planning",
                    "affected_assets": [top_bottleneck["node_name"]],
                }
            )

        # Insight about circular dependencies
        circular = critical_analysis.get("circular_dependencies", [])
        if circular:
            insights.append(
                {
                    "type": ANALYSIS_TYPE_CIRCULAR_DEPENDENCY,
                    "severity": RISK_HIGH,
                    "message": f"Found {len(circular)} circular dependencies that need resolution",
                    "recommendation": "Migrate circular dependent components together as a unit",
                    "affected_assets": [c["nodes"] for c in circular],
                }
            )

        # Insight about isolated components
        node_count = dependency_graph.get("node_count", 0)
        if node_count > 0:
            density = dependency_graph.get("density", 0)
            if density < LOW_COUPLING_THRESHOLD:
                insights.append(
                    {
                        "type": ANALYSIS_TYPE_LOW_COUPLING,
                        "severity": RISK_LOW,
                        "message": "System has low coupling, which is good for migration",
                        "recommendation": "Components can be migrated independently",
                        "affected_assets": [],
                    }
                )
            elif density > HIGH_COUPLING_THRESHOLD:
                insights.append(
                    {
                        "type": ANALYSIS_TYPE_HIGH_COUPLING,
                        "severity": RISK_HIGH,
                        "message": "System has high coupling, requiring careful migration planning",
                        "recommendation": "Consider wave-based migration with dependency groups",
                        "affected_assets": [],
                    }
                )

        # Insight about critical paths
        paths = critical_analysis.get("critical_paths", [])
        if paths:
            longest_path = max(paths, key=lambda x: x["length"]) if paths else None
            if longest_path:
                insights.append(
                    {
                        "type": ANALYSIS_TYPE_CRITICAL_PATH,
                        "severity": RISK_MEDIUM,
                        "message": f"Longest dependency chain has {longest_path['length']} components",
                        "recommendation": "Test end-to-end functionality after each migration step",
                        "affected_assets": longest_path.get("nodes", []),
                    }
                )

        return insights

    @staticmethod
    def generate_wave_planning_recommendations(
        dependency_graph: Dict[str, Any], critical_analysis: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate specific wave planning recommendations."""
        recommendations = {
            "total_waves": 1,
            "wave_strategy": "single_wave",
            "waves": [],
            "reasoning": [],
        }

        node_count = dependency_graph.get("node_count", 0)
        edge_count = dependency_graph.get("edge_count", 0)
        density = dependency_graph.get("density", 0)

        # Determine wave strategy based on complexity
        if node_count <= 5:
            recommendations["wave_strategy"] = "single_wave"
            recommendations["total_waves"] = 1
            recommendations["reasoning"].append(
                "Small system - can migrate in single wave"
            )
        elif density > HIGH_COUPLING_THRESHOLD:
            recommendations["wave_strategy"] = "dependency_groups"
            recommendations["total_waves"] = min(3, node_count // 3)
            recommendations["reasoning"].append(
                "High coupling requires grouped migration"
            )
        elif len(critical_analysis.get("circular_dependencies", [])) > 0:
            recommendations["wave_strategy"] = "circular_resolution"
            recommendations["total_waves"] = 2
            recommendations["reasoning"].append(
                "Circular dependencies need special handling"
            )
        else:
            recommendations["wave_strategy"] = "dependency_order"
            recommendations["total_waves"] = min(4, node_count // 2)
            recommendations["reasoning"].append(
                "Medium complexity - wave-based approach"
            )

        return recommendations
