"""
Critical path analysis for dependency graphs.

Generated by CC (Claude Code)
"""

from typing import Any, Dict, List

from ..base import (
    BOTTLENECK_THRESHOLD,
    HIGH_CONNECTIVITY_THRESHOLD,
    RISK_HIGH,
    RISK_MEDIUM,
)


class CriticalPathAnalyzer:
    """Analyzes critical paths and bottlenecks in dependency graphs."""

    @staticmethod
    def analyze_critical_paths(dependency_graph: Dict[str, Any]) -> Dict[str, Any]:
        """Identify critical paths and bottlenecks in the dependency graph"""
        nodes = dependency_graph.get("nodes", [])
        edges = dependency_graph.get("edges", [])

        # Count incoming and outgoing edges for each node
        edge_counts = {}
        for node in nodes:
            node_id = node["id"]
            incoming = sum(1 for e in edges if e["target"] == node_id)
            outgoing = sum(1 for e in edges if e["source"] == node_id)
            edge_counts[node_id] = {
                "incoming": incoming,
                "outgoing": outgoing,
                "total": incoming + outgoing,
                "node": node,
            }

        # Identify bottlenecks (nodes with high connectivity)
        bottlenecks = []
        for node_id, counts in edge_counts.items():
            if counts["total"] > BOTTLENECK_THRESHOLD:  # Threshold for bottleneck
                bottlenecks.append(
                    {
                        "node_id": node_id,
                        "node_name": counts["node"]["label"],
                        "incoming_connections": counts["incoming"],
                        "outgoing_connections": counts["outgoing"],
                        "total_connections": counts["total"],
                        "risk_level": (
                            RISK_HIGH
                            if counts["total"] > HIGH_CONNECTIVITY_THRESHOLD
                            else RISK_MEDIUM
                        ),
                    }
                )

        # Detect circular dependencies
        circular_deps = CriticalPathAnalyzer.detect_circular_dependencies(edges)

        # Identify critical paths (chains of dependencies)
        critical_paths = CriticalPathAnalyzer.find_critical_paths(nodes, edges)

        return {
            "bottlenecks": sorted(
                bottlenecks, key=lambda x: x["total_connections"], reverse=True
            ),
            "circular_dependencies": circular_deps,
            "critical_paths": critical_paths,
        }

    @staticmethod
    def detect_circular_dependencies(
        edges: List[Dict[str, Any]],
    ) -> List[Dict[str, Any]]:
        """Detect circular dependencies in the graph"""
        circular = []
        adjacency = {}

        # Build adjacency list
        for edge in edges:
            source = edge["source"]
            target = edge["target"]
            if source not in adjacency:
                adjacency[source] = []
            adjacency[source].append(target)

        # Simple cycle detection (for pairs)
        for source, targets in adjacency.items():
            for target in targets:
                if target in adjacency and source in adjacency[target]:
                    cycle = sorted([source, target])
                    cycle_key = f"{cycle[0]}-{cycle[1]}"
                    if not any(c["cycle_id"] == cycle_key for c in circular):
                        circular.append(
                            {
                                "cycle_id": cycle_key,
                                "nodes": cycle,
                                "type": "bidirectional",
                                "severity": RISK_HIGH,
                            }
                        )

        return circular

    @staticmethod
    def find_critical_paths(
        nodes: List[Dict[str, Any]], edges: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Find critical dependency paths through the graph"""
        paths = []

        # Build adjacency list
        adjacency = {}
        for edge in edges:
            source = edge["source"]
            target = edge["target"]
            if source not in adjacency:
                adjacency[source] = []
            adjacency[source].append(target)

        # Find leaf nodes (no outgoing edges)
        leaf_nodes = []
        for node in nodes:
            node_id = node["id"]
            if node_id not in adjacency:
                leaf_nodes.append(node_id)

        # For each leaf, trace back to find longest path
        for leaf in leaf_nodes:
            path = CriticalPathAnalyzer._trace_longest_path(leaf, edges, nodes)
            if len(path) > 1:  # Only include paths with multiple nodes
                paths.append(
                    {
                        "path_id": f"path_{len(paths)}",
                        "nodes": path,
                        "length": len(path),
                        "end_node": leaf,
                    }
                )

        return sorted(paths, key=lambda x: x["length"], reverse=True)

    @staticmethod
    def _trace_longest_path(
        start_node: str, edges: List[Dict[str, Any]], nodes: List[Dict[str, Any]]
    ) -> List[str]:
        """Trace the longest path leading to a node using dynamic programming"""
        # Build reverse adjacency (incoming edges)
        reverse_adj = {}
        for edge in edges:
            target = edge["target"]
            source = edge["source"]
            if target not in reverse_adj:
                reverse_adj[target] = []
            reverse_adj[target].append(source)

        # Memoization for longest path from each node
        memo = {}
        
        def find_longest_path_from(node_id):
            """Find the longest path starting from node_id using DP"""
            if node_id in memo:
                return memo[node_id]
            
            # If no predecessors, this is a root node
            if node_id not in reverse_adj or not reverse_adj[node_id]:
                memo[node_id] = [node_id]
                return [node_id]
            
            # Find the longest path among all predecessors
            longest = []
            for pred in reverse_adj[node_id]:
                pred_path = find_longest_path_from(pred)
                if len(pred_path) > len(longest):
                    longest = pred_path.copy()
            
            # Add current node to the path
            longest.append(node_id)
            memo[node_id] = longest
            return longest
        
        return find_longest_path_from(start_node)
