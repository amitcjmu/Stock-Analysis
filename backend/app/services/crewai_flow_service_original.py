"""
CrewAI Flow Service - V2 Discovery Flow Integration

This service bridges CrewAI flows with the V2 Discovery Flow architecture.
Uses flow_id as single source of truth instead of session_id.

Modularized by CC to improve maintainability while preserving backward compatibility.
"""

import logging
from datetime import datetime
from typing import TYPE_CHECKING, Any, Dict, List, Optional

from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db

# Modular components - Generated by CC
from app.services.crewai_flow_executor import CrewAIFlowExecutor
from app.services.crewai_flow_lifecycle import CrewAIFlowLifecycleManager
from app.services.crewai_flow_monitoring import CrewAIFlowMonitoring
from app.services.crewai_flow_state_manager import CrewAIFlowStateManager
from app.services.crewai_flow_utils import CrewAIFlowUtils

# from app.models.discovery_asset import DiscoveryAsset  # Model removed - using Asset model instead
# V2 Discovery Flow Models
# V2 Discovery Flow Services
from app.services.discovery_flow_service import DiscoveryFlowService

# CrewAI Flow Integration (Conditional)
if TYPE_CHECKING:
    from app.services.crewai_flows.unified_discovery_flow import UnifiedDiscoveryFlow
else:
    try:
        from app.services.crewai_flows.unified_discovery_flow import (
            UnifiedDiscoveryFlow,
        )

        CREWAI_FLOWS_AVAILABLE = True
    except ImportError:
        CREWAI_FLOWS_AVAILABLE = False
        UnifiedDiscoveryFlow = None

logger = logging.getLogger(__name__)


class CrewAIFlowService:
    """
    V2 CrewAI Flow Service - Bridges CrewAI flows with Discovery Flow architecture.

    Key Changes:
    - Uses flow_id instead of session_id
    - Integrates with V2 Discovery Flow models
    - Provides graceful fallback when CrewAI flows unavailable
    - Multi-tenant isolation through context-aware repositories
    - Modularized by CC for improved maintainability

    This class now serves as a facade that delegates to specialized modules:
    - CrewAIFlowStateManager: State and status management
    - CrewAIFlowExecutor: Flow execution logic
    - CrewAIFlowLifecycleManager: Lifecycle operations (pause/resume/cleanup)
    - CrewAIFlowMonitoring: Error tracking and metrics
    - CrewAIFlowUtils: Helper functions and utilities
    """

    def __init__(self, db: Optional[AsyncSession] = None):
        self.db = db
        self._discovery_flow_service: Optional[DiscoveryFlowService] = None
        self._llm = None

        # Initialize modular components - Generated by CC
        self._state_manager = CrewAIFlowStateManager(db)
        self._executor = CrewAIFlowExecutor(db)
        self._lifecycle_manager = CrewAIFlowLifecycleManager(db)
        self._monitoring = CrewAIFlowMonitoring(db)
        self._utils = CrewAIFlowUtils(db)

        # Inject this service instance into lifecycle manager for resume operations
        # This maintains the existing API while using modular components
        self._lifecycle_manager._crewai_service = self

    async def _get_discovery_flow_service(
        self, context: Dict[str, Any]
    ) -> DiscoveryFlowService:
        """Get or create discovery flow service with context."""
        if not self._discovery_flow_service:
            # Create a new database session if one wasn't provided
            from app.core.database import AsyncSessionLocal

            if not self.db:
                logger.info(
                    "ðŸ” Creating new database session for V2 Discovery Flow service"
                )
                self.db = AsyncSessionLocal()

            # Create RequestContext from the context dict
            from app.core.context import RequestContext

            request_context = RequestContext(
                client_account_id=context.get("client_account_id"),
                engagement_id=context.get("engagement_id"),
                user_id=context.get("approved_by") or context.get("user_id"),
            )

            self._discovery_flow_service = DiscoveryFlowService(
                self.db, request_context
            )

        return self._discovery_flow_service

    def get_llm(self):
        """Get the LLM instance for CrewAI agents."""
        # Delegate to utils module - Generated by CC
        return self._utils.get_llm()

    def get_agents(self) -> Dict[str, Any]:
        """
        Get all CrewAI agents for the discovery flow.

        Note: UnifiedDiscoveryFlow uses crews managed by UnifiedFlowCrewManager,
        not individual agents. This method returns None for all agents to match
        the flow_initialization.py pattern.
        """
        # Delegate to utils module - Generated by CC
        return self._utils.get_agents()

    async def initialize_flow(
        self,
        flow_id: str,
        context: Dict[str, Any],
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Initialize a new CrewAI flow using V2 Discovery Flow architecture.

        Args:
            flow_id: Discovery Flow ID (replaces session_id)
            context: Request context with client/engagement info
            metadata: Optional flow metadata
        """
        # Delegate to lifecycle manager - Generated by CC
        return await self._lifecycle_manager.initialize_flow(flow_id, context, metadata)

    async def get_flow_status(
        self, flow_id: str, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Get comprehensive flow status using V2 architecture.

        Args:
            flow_id: Discovery Flow ID
            context: Request context
        """
        # Delegate to state manager - Generated by CC
        return await self._state_manager.get_flow_status(flow_id, context)

    async def advance_flow_phase(
        self, flow_id: str, next_phase: str, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Advance flow to next phase using V2 architecture.

        Args:
            flow_id: Discovery Flow ID
            next_phase: Target phase name
            context: Request context
        """
        # Delegate to state manager - Generated by CC
        return await self._state_manager.advance_flow_phase(
            flow_id, next_phase, context
        )

    async def get_active_flows(self, context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Get all active flows for the current context.

        Args:
            context: Request context with client/engagement info
        """
        # Delegate to state manager - Generated by CC
        return await self._state_manager.get_active_flows(context)

    async def cleanup_flow(
        self, flow_id: str, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Clean up a flow and all associated data.

        Args:
            flow_id: Discovery Flow ID
            context: Request context
        """
        # Delegate to lifecycle manager - Generated by CC
        return await self._lifecycle_manager.cleanup_flow(flow_id, context)

    async def pause_flow(
        self, flow_id: str, reason: str = "user_requested"
    ) -> Dict[str, Any]:
        """
        Pause a running CrewAI discovery flow at the current node.
        This preserves the flow state and allows resumption from the same point.

        Args:
            flow_id: Discovery Flow ID
            reason: Reason for pausing the flow
        """
        # Delegate to lifecycle manager - Generated by CC
        return await self._lifecycle_manager.pause_flow(flow_id, reason)

    async def resume_flow(
        self, flow_id: str, resume_context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Resume a paused CrewAI discovery flow from the last saved state.
        This continues execution from the exact node where it was paused.

        Args:
            flow_id: Discovery Flow ID
            resume_context: Optional context for resumption (user input, etc.)

        Returns:
            Dict containing resume status and result information

        Raises:
            ValueError: If flow not found
            InvalidFlowStateError: If flow is in a terminal state (deleted, cancelled, completed, failed)
            CrewAIExecutionError: If CrewAI flow initialization or execution fails

        Note:
            Only flows with resumable statuses can be resumed. Terminal statuses
            ['deleted', 'cancelled', 'completed', 'failed'] will raise InvalidFlowStateError.
        """
        # Delegate to lifecycle manager - Generated by CC
        return await self._lifecycle_manager.resume_flow(flow_id, resume_context)

    async def resume_flow_at_phase(
        self, flow_id: str, phase: str, resume_context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Resume a CrewAI discovery flow at a specific phase with optional human input.
        This is for human-in-the-loop scenarios where user provides input to continue.

        Args:
            flow_id: Discovery Flow ID
            phase: Target phase to resume at
            resume_context: Context including human input and phase data
        """
        # Delegate to lifecycle manager - Generated by CC
        return await self._lifecycle_manager.resume_flow_at_phase(
            flow_id, phase, resume_context
        )

    def add_error(
        self, error_message: str, phase: str = None, details: Dict[str, Any] = None
    ):
        """Add error to the flow service for tracking"""
        # Delegate to monitoring module - Generated by CC
        self._monitoring.add_error(error_message, phase, details)

    # ========================================
    # MISSING CREWAI EXECUTION METHODS
    # ========================================

    async def execute_data_import_validation(
        self,
        flow_id: str,
        raw_data: List[Dict[str, Any]],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Execute data import validation phase.
        This method validates imported data and prepares it for field mapping.
        """
        # Delegate to executor module - Generated by CC
        return await self._executor.execute_data_import_validation(
            flow_id, raw_data, client_account_id, engagement_id, user_id, **kwargs
        )

    async def generate_field_mapping_suggestions(
        self,
        flow_id: str,
        validation_result: Dict[str, Any],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Generate field mapping suggestions based on validation results.
        This method analyzes field patterns and suggests mappings to standard schema.
        """
        # Delegate to executor module - Generated by CC
        return await self._executor.generate_field_mapping_suggestions(
            flow_id,
            validation_result,
            client_account_id,
            engagement_id,
            user_id,
            **kwargs,
        )

    async def apply_field_mappings(
        self,
        flow_id: str,
        approved_mappings: Dict[str, str],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Apply approved field mappings to transform data.
        This method applies user-approved field mappings and prepares data for cleansing.
        """
        # Delegate to executor module - Generated by CC
        return await self._executor.apply_field_mappings(
            flow_id,
            approved_mappings,
            client_account_id,
            engagement_id,
            user_id,
            **kwargs,
        )

    async def execute_data_cleansing(
        self,
        flow_id: str,
        field_mappings: Dict[str, str],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Execute data cleansing phase.
        This method cleanses and standardizes data using the applied field mappings.
        """
        # Delegate to executor module - Generated by CC
        return await self._executor.execute_data_cleansing(
            flow_id, field_mappings, client_account_id, engagement_id, user_id, **kwargs
        )
        try:
            logger.info(f"ðŸ§¹ Executing data cleansing for flow: {flow_id}")

            # Placeholder implementation for data cleansing
            # In a real implementation, this would apply various cleansing rules
            cleansing_results = {
                "records_processed": 0,
                "records_cleaned": 0,
                "records_failed": 0,
                "quality_improvements": {},
                "cleansing_operations": [
                    "standardized_hostnames",
                    "validated_ip_addresses",
                    "normalized_operating_systems",
                    "cleaned_environment_tags",
                ],
                "overall_quality_score": 0.85,
            }

            logger.info(
                f"âœ… Data cleansing completed with quality score: {cleansing_results['overall_quality_score']}"
            )

            return {
                "status": "completed",
                "phase": "data_cleansing",
                "results": cleansing_results,
                "flow_id": flow_id,
                "method": "execute_data_cleansing",
            }

        except Exception as e:
            logger.error(f"âŒ Data cleansing failed for flow {flow_id}: {e}")
            import traceback

            logger.error(f"Traceback: {traceback.format_exc()}")

            return {
                "status": "failed",
                "phase": "data_cleansing",
                "error": str(e),
                "flow_id": flow_id,
                "method": "execute_data_cleansing",
            }

    async def create_discovery_assets(
        self,
        flow_id: str,
        cleaned_data: List[Dict[str, Any]],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Create discovery assets from cleaned data.
        This method creates asset records in the database from cleansed data.
        """
        try:
            logger.info(f"ðŸ—ï¸ Creating discovery assets for flow: {flow_id}")
            logger.info(f"ðŸ“Š Processing {len(cleaned_data)} cleaned records")

            # Placeholder implementation for asset creation
            # In a real implementation, this would create actual asset records
            asset_creation_results = {
                "assets_created": len(cleaned_data),
                "success_rate": 0.95,
                "asset_types": {
                    "servers": len(
                        [r for r in cleaned_data if r.get("type") == "server"]
                    ),
                    "applications": len(
                        [r for r in cleaned_data if r.get("type") == "application"]
                    ),
                    "devices": len(
                        [
                            r
                            for r in cleaned_data
                            if r.get("type") not in ["server", "application"]
                        ]
                    ),
                },
                "creation_timestamp": datetime.utcnow().isoformat(),
            }

            logger.info(
                f"âœ… Discovery assets created: {asset_creation_results['assets_created']} assets"
            )

            return {
                "status": "completed",
                "phase": "asset_creation",
                "results": asset_creation_results,
                "flow_id": flow_id,
                "method": "create_discovery_assets",
            }

        except Exception as e:
            logger.error(f"âŒ Discovery asset creation failed for flow {flow_id}: {e}")
            import traceback

            logger.error(f"Traceback: {traceback.format_exc()}")

            return {
                "status": "failed",
                "phase": "asset_creation",
                "error": str(e),
                "flow_id": flow_id,
                "method": "create_discovery_assets",
            }

    async def execute_analysis_phases(
        self,
        flow_id: str,
        assets: List[Dict[str, Any]],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Execute analysis phases (asset inventory, dependency analysis, tech debt analysis).
        This method runs the final analysis phases on the created assets.
        """
        try:
            logger.info(f"ðŸ“Š Executing analysis phases for flow: {flow_id}")
            logger.info(f"ðŸ” Analyzing {len(assets)} assets")

            # Placeholder implementation for analysis phases
            analysis_results = {
                "asset_inventory": {
                    "total_assets": len(assets),
                    "servers": len([a for a in assets if a.get("type") == "server"]),
                    "applications": len(
                        [a for a in assets if a.get("type") == "application"]
                    ),
                    "other_devices": len(
                        [
                            a
                            for a in assets
                            if a.get("type") not in ["server", "application"]
                        ]
                    ),
                },
                "dependency_analysis": {
                    "dependencies_found": 25,
                    "hosting_relationships": 15,
                    "application_dependencies": 10,
                },
                "tech_debt_analysis": {
                    "legacy_systems_identified": 8,
                    "modernization_candidates": 12,
                    "risk_score": 0.65,
                },
                "analysis_timestamp": datetime.utcnow().isoformat(),
            }

            logger.info(
                f"âœ… Analysis phases completed for {analysis_results['asset_inventory']['total_assets']} assets"
            )

            return {
                "status": "completed",
                "phase": "analysis",
                "results": analysis_results,
                "flow_id": flow_id,
                "method": "execute_analysis_phases",
            }

        except Exception as e:
            logger.error(f"âŒ Analysis phases failed for flow {flow_id}: {e}")
            import traceback

            logger.error(f"Traceback: {traceback.format_exc()}")

            return {
                "status": "failed",
                "phase": "analysis",
                "error": str(e),
                "flow_id": flow_id,
                "method": "execute_analysis_phases",
            }

    async def execute_flow_phase(
        self,
        flow_id: str,
        phase_name: str,
        phase_input: Dict[str, Any],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Generic method to execute any flow phase.
        This method routes to the appropriate phase-specific method.
        """
        try:
            logger.info(f"ðŸš€ Executing flow phase: {phase_name} for flow: {flow_id}")

            # Route to appropriate phase method
            if phase_name == "data_import_validation":
                return await self.execute_data_import_validation(
                    flow_id=flow_id,
                    raw_data=phase_input.get("raw_data", []),
                    client_account_id=client_account_id,
                    engagement_id=engagement_id,
                    user_id=user_id,
                    **kwargs,
                )
            elif phase_name == "field_mapping":
                if phase_input.get("approved_mappings"):
                    return await self.apply_field_mappings(
                        flow_id=flow_id,
                        approved_mappings=phase_input["approved_mappings"],
                        client_account_id=client_account_id,
                        engagement_id=engagement_id,
                        user_id=user_id,
                        **kwargs,
                    )
                else:
                    return await self.generate_field_mapping_suggestions(
                        flow_id=flow_id,
                        validation_result=phase_input.get("validation_result", {}),
                        client_account_id=client_account_id,
                        engagement_id=engagement_id,
                        user_id=user_id,
                        **kwargs,
                    )
            elif phase_name == "data_cleansing":
                return await self.execute_data_cleansing(
                    flow_id=flow_id,
                    field_mappings=phase_input.get("field_mappings", {}),
                    client_account_id=client_account_id,
                    engagement_id=engagement_id,
                    user_id=user_id,
                    **kwargs,
                )
            elif phase_name == "asset_creation":
                return await self.create_discovery_assets(
                    flow_id=flow_id,
                    cleaned_data=phase_input.get("cleaned_data", []),
                    client_account_id=client_account_id,
                    engagement_id=engagement_id,
                    user_id=user_id,
                    **kwargs,
                )
            elif phase_name == "analysis":
                return await self.execute_analysis_phases(
                    flow_id=flow_id,
                    assets=phase_input.get("assets", []),
                    client_account_id=client_account_id,
                    engagement_id=engagement_id,
                    user_id=user_id,
                    **kwargs,
                )
            else:
                # Unknown phase
                logger.warning(f"âš ï¸ Unknown flow phase: {phase_name}")
                return {
                    "status": "failed",
                    "phase": phase_name,
                    "error": f"Unknown phase: {phase_name}",
                    "flow_id": flow_id,
                    "method": "execute_flow_phase",
                }

        except Exception as e:
            logger.error(
                f"âŒ Flow phase execution failed: {phase_name} for flow {flow_id}: {e}"
            )
            import traceback

            logger.error(f"Traceback: {traceback.format_exc()}")

            return {
                "status": "failed",
                "phase": phase_name,
                "error": str(e),
                "flow_id": flow_id,
                "method": "execute_flow_phase",
            }


# Factory function for dependency injection
async def get_crewai_flow_service(
    db: AsyncSession = None, context: Dict[str, Any] = None
) -> CrewAIFlowService:
    """
    Factory function to create CrewAI Flow Service with proper dependencies.
    """
    if not db:
        # Get database session from dependency injection
        async with get_db() as session:
            return CrewAIFlowService(db=session)

    return CrewAIFlowService(db=db)
