"""
Shared State Manager for Multi-Process Environments

This module provides a SharedStateManager that uses Redis for shared state
persistence across multiple process/worker instances, with fallback to
in-memory storage when Redis is not available.

Generated by CC (Claude Code)
"""

from typing import Any, Dict, Optional

from app.core.logging import get_logger
from app.services.caching.redis_cache import RedisCache

logger = get_logger(__name__)


class SharedStateManager:
    """
    Manages shared state across multiple processes using Redis as the primary
    storage backend with in-memory fallback for development/testing scenarios.

    This solves the critical issue where RetryHandler, FallbackOrchestrator,
    and TTLManager use in-memory state that won't be shared across multiple
    process/worker instances in production.
    """

    def __init__(
        self, redis_cache: Optional[RedisCache] = None, key_prefix: str = "shared_state"
    ):
        self.redis_cache = redis_cache
        self.key_prefix = key_prefix
        self.fallback_storage: Dict[str, Any] = {}
        self.use_redis = self.redis_cache is not None and self.redis_cache.enabled

        if not self.use_redis:
            logger.warning(
                "SharedStateManager falling back to in-memory storage. "
                "State will not be shared across multiple processes."
            )
        else:
            logger.info("SharedStateManager using Redis for shared state persistence")

    def _get_cache_key(self, key: str) -> str:
        """Generate cache key with prefix"""
        return f"{self.key_prefix}:{key}"

    async def get(self, key: str, default: Any = None) -> Any:
        """
        Get value from shared state storage

        Args:
            key: The state key
            default: Default value if key not found

        Returns:
            The stored value or default
        """
        cache_key = self._get_cache_key(key)

        if self.use_redis:
            try:
                value = await self.redis_cache.get(cache_key)
                return value if value is not None else default
            except Exception as e:
                logger.error(f"Redis get failed for key {key}: {e}")
                # Fall back to in-memory storage
                return self.fallback_storage.get(key, default)
        else:
            return self.fallback_storage.get(key, default)

    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        """
        Set value in shared state storage

        Args:
            key: The state key
            value: The value to store
            ttl: Time to live in seconds (Redis only)

        Returns:
            True if successful, False otherwise
        """
        cache_key = self._get_cache_key(key)

        if self.use_redis:
            try:
                # Use default TTL of 24 hours for state data if not specified
                ttl = ttl or 86400
                success = await self.redis_cache.set(cache_key, value, ttl)
                if success:
                    # Also store in fallback for immediate access
                    self.fallback_storage[key] = value
                return success
            except Exception as e:
                logger.error(f"Redis set failed for key {key}: {e}")
                # Fall back to in-memory storage
                self.fallback_storage[key] = value
                return True
        else:
            self.fallback_storage[key] = value
            return True

    async def delete(self, key: str) -> bool:
        """
        Delete value from shared state storage

        Args:
            key: The state key

        Returns:
            True if successful, False otherwise
        """
        cache_key = self._get_cache_key(key)

        if self.use_redis:
            try:
                success = await self.redis_cache.delete(cache_key)
                # Also remove from fallback storage
                self.fallback_storage.pop(key, None)
                return success
            except Exception as e:
                logger.error(f"Redis delete failed for key {key}: {e}")
                # Fall back to in-memory storage
                self.fallback_storage.pop(key, None)
                return True
        else:
            self.fallback_storage.pop(key, None)
            return True

    async def exists(self, key: str) -> bool:
        """
        Check if key exists in shared state storage

        Args:
            key: The state key

        Returns:
            True if key exists, False otherwise
        """
        cache_key = self._get_cache_key(key)

        if self.use_redis:
            try:
                return await self.redis_cache.exists(cache_key)
            except Exception as e:
                logger.error(f"Redis exists failed for key {key}: {e}")
                # Fall back to in-memory storage
                return key in self.fallback_storage
        else:
            return key in self.fallback_storage

    async def increment(self, key: str, amount: int = 1) -> int:
        """
        Atomically increment a numeric value

        Args:
            key: The state key
            amount: Amount to increment by

        Returns:
            The new value after increment
        """
        cache_key = self._get_cache_key(key)

        if self.use_redis and hasattr(self.redis_cache.client, "incrby"):
            try:
                if self.redis_cache.client_type == "upstash":
                    return self.redis_cache.client.incrby(cache_key, amount)
                else:
                    return await self.redis_cache.client.incrby(cache_key, amount)
            except Exception as e:
                logger.error(f"Redis increment failed for key {key}: {e}")
                # Fall back to get/set pattern

        # Fallback implementation using get/set
        current_value = await self.get(key, 0)
        try:
            new_value = int(current_value) + amount
        except (ValueError, TypeError):
            new_value = amount

        await self.set(key, new_value)
        return new_value

    async def set_if_not_exists(
        self, key: str, value: Any, ttl: Optional[int] = None
    ) -> bool:
        """
        Set value only if key doesn't exist

        Args:
            key: The state key
            value: The value to store
            ttl: Time to live in seconds (Redis only)

        Returns:
            True if value was set, False if key already existed
        """
        if await self.exists(key):
            return False

        return await self.set(key, value, ttl)

    async def get_multiple(self, keys: list[str]) -> Dict[str, Any]:
        """
        Get multiple values at once

        Args:
            keys: List of state keys

        Returns:
            Dictionary mapping keys to values
        """
        result = {}
        for key in keys:
            result[key] = await self.get(key)
        return result

    async def set_multiple(
        self, data: Dict[str, Any], ttl: Optional[int] = None
    ) -> bool:
        """
        Set multiple values at once

        Args:
            data: Dictionary of key-value pairs
            ttl: Time to live in seconds (Redis only)

        Returns:
            True if all sets were successful, False otherwise
        """
        success = True
        for key, value in data.items():
            if not await self.set(key, value, ttl):
                success = False
        return success

    async def cleanup_expired(self) -> int:
        """
        Clean up expired entries (in-memory only, Redis handles TTL automatically)

        Returns:
            Number of entries cleaned up
        """
        if self.use_redis:
            # Redis handles TTL automatically, no cleanup needed
            return 0

        # For in-memory storage, we don't track TTL, so no cleanup needed
        # This could be enhanced in the future to support TTL for in-memory storage
        return 0

    def get_stats(self) -> Dict[str, Any]:
        """
        Get statistics about the shared state manager

        Returns:
            Dictionary with statistics
        """
        return {
            "using_redis": self.use_redis,
            "fallback_entries": len(self.fallback_storage),
            "key_prefix": self.key_prefix,
            "redis_available": (
                self.redis_cache is not None and self.redis_cache.enabled
                if self.redis_cache
                else False
            ),
        }


# Factory function for dependency injection
def create_shared_state_manager(
    redis_cache: Optional[RedisCache] = None, key_prefix: str = "shared_state"
) -> SharedStateManager:
    """Create SharedStateManager with dependencies"""
    return SharedStateManager(redis_cache, key_prefix)


# Singleton instances for different use cases
_retry_state_manager: Optional[SharedStateManager] = None
_ttl_state_manager: Optional[SharedStateManager] = None
_fallback_state_manager: Optional[SharedStateManager] = None


def get_retry_state_manager() -> Optional[SharedStateManager]:
    """Get singleton SharedStateManager for retry handler state"""
    return _retry_state_manager


def get_ttl_state_manager() -> Optional[SharedStateManager]:
    """Get singleton SharedStateManager for TTL manager state"""
    return _ttl_state_manager


def get_fallback_state_manager() -> Optional[SharedStateManager]:
    """Get singleton SharedStateManager for fallback orchestrator state"""
    return _fallback_state_manager


def set_retry_state_manager(manager: SharedStateManager) -> None:
    """Set singleton SharedStateManager for retry handler state"""
    global _retry_state_manager
    _retry_state_manager = manager


def set_ttl_state_manager(manager: SharedStateManager) -> None:
    """Set singleton SharedStateManager for TTL manager state"""
    global _ttl_state_manager
    _ttl_state_manager = manager


def set_fallback_state_manager(manager: SharedStateManager) -> None:
    """Set singleton SharedStateManager for fallback orchestrator state"""
    global _fallback_state_manager
    _fallback_state_manager = manager
