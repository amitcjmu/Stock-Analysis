"""
Transformation rule engine.

Generated by CC (Claude Code)
"""

import logging
import re
from typing import Any, Dict

from .base import TransformationRule

logger = logging.getLogger(__name__)


class TransformationRuleEngine:
    """Handles application of custom transformation rules."""

    async def apply_custom_transformations(
        self, data: Dict[str, Any], config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Apply custom transformation rules."""
        transformed = data.copy()
        rules = config.get("rules", [])

        for rule in rules:
            rule_type = rule.get("type")

            if rule_type == TransformationRule.FIELD_MAPPING.value:
                transformed = self._apply_field_mapping_rule(transformed, rule)

            elif rule_type == TransformationRule.VALUE_CONVERSION.value:
                transformed = self._apply_value_conversion_rule(transformed, rule)

            elif rule_type == TransformationRule.FIELD_SPLIT.value:
                transformed = self._apply_field_split_rule(transformed, rule)

            elif rule_type == TransformationRule.FIELD_MERGE.value:
                transformed = self._apply_field_merge_rule(transformed, rule)

            elif rule_type == TransformationRule.REGEX_EXTRACT.value:
                transformed = self._apply_regex_extract_rule(transformed, rule)

            elif rule_type == TransformationRule.CONDITIONAL.value:
                transformed = self._apply_conditional_rule(transformed, rule)

        return transformed

    def _apply_field_mapping_rule(
        self, data: Dict[str, Any], rule: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Apply field mapping transformation rule."""
        source_field = rule.get("source_field")
        target_field = rule.get("target_field")

        if source_field in data:
            data[target_field] = data[source_field]
            if rule.get("remove_source", False):
                del data[source_field]

        return data

    def _apply_value_conversion_rule(
        self, data: Dict[str, Any], rule: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Apply value conversion transformation rule."""
        field = rule.get("field")
        conversion_type = rule.get("conversion_type")

        if field in data:
            value = data[field]

            if conversion_type == "uppercase":
                data[field] = str(value).upper()
            elif conversion_type == "lowercase":
                data[field] = str(value).lower()
            elif conversion_type == "int":
                try:
                    data[field] = int(value)
                except (ValueError, TypeError):
                    pass
            elif conversion_type == "float":
                try:
                    data[field] = float(value)
                except (ValueError, TypeError):
                    pass
            elif conversion_type == "bool":
                data[field] = str(value).lower() in ["true", "yes", "1", "on"]
            elif conversion_type == "bytes_to_gb":
                try:
                    data[field] = round(float(value) / (1024**3), 2)
                except (ValueError, TypeError):
                    pass

        return data

    def _apply_field_split_rule(
        self, data: Dict[str, Any], rule: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Apply field split transformation rule."""
        source_field = rule.get("source_field")
        delimiter = rule.get("delimiter", " ")
        target_fields = rule.get("target_fields", [])

        if source_field in data and isinstance(data[source_field], str):
            parts = data[source_field].split(delimiter)
            for i, target_field in enumerate(target_fields):
                if i < len(parts):
                    data[target_field] = parts[i].strip()

        return data

    def _apply_field_merge_rule(
        self, data: Dict[str, Any], rule: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Apply field merge transformation rule."""
        source_fields = rule.get("source_fields", [])
        target_field = rule.get("target_field")
        delimiter = rule.get("delimiter", " ")

        values = []
        for field in source_fields:
            if field in data and data[field]:
                values.append(str(data[field]))

        if values:
            data[target_field] = delimiter.join(values)

        return data

    def _apply_regex_extract_rule(
        self, data: Dict[str, Any], rule: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Apply regex extraction transformation rule."""
        source_field = rule.get("source_field")
        pattern = rule.get("pattern")
        target_field = rule.get("target_field")

        if source_field in data and pattern:
            try:
                match = re.search(pattern, str(data[source_field]))
                if match:
                    if match.groups():
                        data[target_field] = match.group(1)
                    else:
                        data[target_field] = match.group(0)
            except re.error:
                logger.error(f"Invalid regex pattern: {pattern}")

        return data

    def _apply_conditional_rule(
        self, data: Dict[str, Any], rule: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Apply conditional transformation rule."""
        condition = rule.get("condition", {})
        field = condition.get("field")
        operator = condition.get("operator")
        value = condition.get("value")

        if field in data:
            field_value = data[field]
            condition_met = False

            if operator == "equals":
                condition_met = field_value == value
            elif operator == "not_equals":
                condition_met = field_value != value
            elif operator == "contains":
                condition_met = str(value) in str(field_value)
            elif operator == "greater_than":
                try:
                    condition_met = float(field_value) > float(value)
                except (ValueError, TypeError):
                    pass
            elif operator == "less_than":
                try:
                    condition_met = float(field_value) < float(value)
                except (ValueError, TypeError):
                    pass

            if condition_met:
                # Apply transformation if condition is met
                transform = rule.get("transform", {})
                target_field = transform.get("field")
                target_value = transform.get("value")
                if target_field:
                    data[target_field] = target_value

        return data
