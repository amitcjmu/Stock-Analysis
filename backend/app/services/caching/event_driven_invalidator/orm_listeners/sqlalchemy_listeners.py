"""
SQLAlchemy ORM event listeners for cache invalidation.

Generated by CC (Claude Code)
"""

import json
from typing import Any, Callable, Dict, List, Optional, Type

from sqlalchemy import event

from app.core.logging import get_logger
from app.models.base import Base
from app.services.caching.invalidation_strategies import InvalidationTrigger

from ..base import EventSource
from ..detectors import EntityChangeDetector
from ..events import CacheInvalidationEvent

logger = get_logger(__name__)


class SQLAlchemyEventListeners:
    """Manages SQLAlchemy ORM event listeners for cache invalidation."""

    def __init__(
        self,
        entity_change_detector: EntityChangeDetector,
        event_queue_callback: Callable,
    ):
        """
        Initialize SQLAlchemy event listeners.

        Args:
            entity_change_detector: Entity change detector instance
            event_queue_callback: Callback function to queue events
        """
        self.entity_change_detector = entity_change_detector
        self._queue_event = event_queue_callback
        self._orm_listeners_registered = False

    def register_orm_listeners(self) -> None:
        """Register SQLAlchemy ORM event listeners for all model classes"""
        if self._orm_listeners_registered:
            return

        # Register listeners for all model classes
        for model_class in self._get_model_classes():
            event.listen(model_class, "after_insert", self._on_orm_insert)
            event.listen(model_class, "after_update", self._on_orm_update)
            event.listen(model_class, "after_delete", self._on_orm_delete)

        self._orm_listeners_registered = True
        logger.info("SQLAlchemy ORM event listeners registered")

    def unregister_orm_listeners(self) -> None:
        """Unregister SQLAlchemy ORM event listeners"""
        if not self._orm_listeners_registered:
            return

        # Unregister listeners for all model classes
        for model_class in self._get_model_classes():
            event.remove(model_class, "after_insert", self._on_orm_insert)
            event.remove(model_class, "after_update", self._on_orm_update)
            event.remove(model_class, "after_delete", self._on_orm_delete)

        self._orm_listeners_registered = False
        logger.info("SQLAlchemy ORM event listeners unregistered")

    def _get_model_classes(self) -> List[Type]:
        """Get all SQLAlchemy model classes recursively"""
        model_classes = []

        def get_all_subclasses(cls):
            """Recursively get all subclasses of a class"""
            all_subclasses = []

            for subclass in cls.__subclasses__():
                all_subclasses.append(subclass)
                all_subclasses.extend(get_all_subclasses(subclass))

            return all_subclasses

        # Get all classes that inherit from Base (recursively)
        for cls in get_all_subclasses(Base):
            if hasattr(cls, "__tablename__"):
                model_classes.append(cls)

        # Remove duplicates while preserving order
        seen = set()
        unique_models = []
        for cls in model_classes:
            if cls not in seen:
                seen.add(cls)
                unique_models.append(cls)

        return unique_models

    def _on_orm_insert(self, mapper, connection, target) -> None:
        """Handle ORM insert events"""
        try:
            entity_info = self._extract_entity_info(target)
            if not entity_info:
                return

            event = CacheInvalidationEvent(
                source=EventSource.DATABASE_ORM,
                trigger=InvalidationTrigger.DATA_MODIFICATION,
                entity_type=entity_info["entity_type"],
                entity_id=entity_info["entity_id"],
                client_account_id=entity_info["client_account_id"],
                user_id=entity_info.get("user_id"),
                engagement_id=entity_info.get("engagement_id"),
                operation="INSERT",
                new_values=self._extract_entity_values(target),
            )

            self._queue_event(event)

        except Exception as e:
            logger.error(f"Error handling ORM insert: {e}")

    def _on_orm_update(self, mapper, connection, target) -> None:
        """Handle ORM update events"""
        try:
            entity_info = self._extract_entity_info(target)
            if not entity_info:
                return

            # Get old and new values
            old_values = {}
            new_values = self._extract_entity_values(target)

            # Get changed attributes from SQLAlchemy inspection
            changed_attributes = self.entity_change_detector.get_changed_attributes(
                target
            )

            # Check if changes are cache-relevant
            if not self.entity_change_detector.has_cache_relevant_changes(
                target, changed_attributes
            ):
                return

            event = CacheInvalidationEvent(
                source=EventSource.DATABASE_ORM,
                trigger=InvalidationTrigger.DATA_MODIFICATION,
                entity_type=entity_info["entity_type"],
                entity_id=entity_info["entity_id"],
                client_account_id=entity_info["client_account_id"],
                user_id=entity_info.get("user_id"),
                engagement_id=entity_info.get("engagement_id"),
                operation="UPDATE",
                old_values=old_values,
                new_values=new_values,
                changed_attributes=changed_attributes,
            )

            self._queue_event(event)

        except Exception as e:
            logger.error(f"Error handling ORM update: {e}")

    def _on_orm_delete(self, mapper, connection, target) -> None:
        """Handle ORM delete events"""
        try:
            entity_info = self._extract_entity_info(target)
            if not entity_info:
                return

            event = CacheInvalidationEvent(
                source=EventSource.DATABASE_ORM,
                trigger=InvalidationTrigger.DATA_MODIFICATION,
                entity_type=entity_info["entity_type"],
                entity_id=entity_info["entity_id"],
                client_account_id=entity_info["client_account_id"],
                user_id=entity_info.get("user_id"),
                engagement_id=entity_info.get("engagement_id"),
                operation="DELETE",
                old_values=self._extract_entity_values(target),
            )

            self._queue_event(event)

        except Exception as e:
            logger.error(f"Error handling ORM delete: {e}")

    def _extract_entity_info(self, entity: Any) -> Optional[Dict[str, Any]]:
        """Extract entity information for cache invalidation"""
        entity_type = entity.__class__.__name__.lower()

        # Extract entity ID
        entity_id = None
        if hasattr(entity, "id"):
            entity_id = str(entity.id)
        elif hasattr(entity, "uuid"):
            entity_id = str(entity.uuid)
        else:
            return None

        # Extract client account ID for multi-tenant isolation
        client_account_id = None
        if hasattr(entity, "client_account_id"):
            client_account_id = str(entity.client_account_id)
        elif hasattr(entity, "client_id"):
            client_account_id = str(entity.client_id)
        else:
            # Some entities might not have direct client association
            # For now, we'll skip them, but could be enhanced to look up relationships
            return None

        result = {
            "entity_type": entity_type,
            "entity_id": entity_id,
            "client_account_id": client_account_id,
        }

        # Extract optional fields
        if hasattr(entity, "user_id"):
            result["user_id"] = str(entity.user_id)
        if hasattr(entity, "engagement_id"):
            result["engagement_id"] = str(entity.engagement_id)

        return result

    def _extract_entity_values(self, entity: Any) -> Dict[str, Any]:
        """Extract entity attribute values for change tracking"""
        values = {}

        # Get all column attributes
        if hasattr(entity, "__table__"):
            for column in entity.__table__.columns:
                attr_name = column.name
                if hasattr(entity, attr_name):
                    attr_value = getattr(entity, attr_name)
                    # Convert to serializable format
                    if attr_value is not None:
                        try:
                            json.dumps(attr_value, default=str)  # Test serializability
                            values[attr_name] = attr_value
                        except (TypeError, ValueError):
                            values[attr_name] = str(attr_value)

        return values
