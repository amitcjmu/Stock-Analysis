"""
TTL calculation strategies implementation.

This module contains various TTL calculation strategies including static,
adaptive, predictive, system-aware, and hybrid approaches.

Generated by CC (Claude Code)
"""

from datetime import datetime
from typing import Any, Dict, Optional

from app.constants.cache_keys import CacheKeys
from app.core.logging import get_logger

from .base import TTLRecommendation, TTLStrategy, CacheAccessPattern

logger = get_logger(__name__)


class TTLStrategies:
    """Container for all TTL calculation strategies"""

    def __init__(self, access_patterns: Dict[str, CacheAccessPattern]):
        self.access_patterns = access_patterns

        # Strategy weights for hybrid approach
        self.strategy_weights = {
            TTLStrategy.STATIC: 0.2,
            TTLStrategy.ADAPTIVE: 0.3,
            TTLStrategy.PREDICTIVE: 0.3,
            TTLStrategy.SYSTEM_LOAD_AWARE: 0.2,
        }

    def calculate_static_ttl(
        self, cache_key: str, data_type: Optional[str], metadata: Dict[str, Any]
    ) -> TTLRecommendation:
        """Calculate static TTL based on data type"""
        # Use CacheKeys TTL recommendations
        ttl_seconds = CacheKeys.get_ttl_recommendation(cache_key)

        # Apply data type specific adjustments
        if data_type:
            if data_type in ["user_session", "authentication"]:
                ttl_seconds = max(ttl_seconds, 3600)  # At least 1 hour
            elif data_type in ["analytics", "reports"]:
                ttl_seconds = min(ttl_seconds, 1800)  # At most 30 minutes

        return TTLRecommendation(
            cache_key=cache_key,
            recommended_ttl_seconds=ttl_seconds,
            strategy_used=TTLStrategy.STATIC,
            confidence=0.8,
            reasoning=f"Static TTL based on cache key type and data type: {data_type}",
            factors={"data_type": data_type, "base_ttl": ttl_seconds},
        )

    def calculate_adaptive_ttl(
        self, cache_key: str, metadata: Dict[str, Any]
    ) -> TTLRecommendation:
        """Calculate adaptive TTL based on access patterns"""
        pattern = self.access_patterns.get(cache_key)
        base_ttl = CacheKeys.get_ttl_recommendation(cache_key)

        if not pattern:
            return TTLRecommendation(
                cache_key=cache_key,
                recommended_ttl_seconds=base_ttl,
                strategy_used=TTLStrategy.ADAPTIVE,
                confidence=0.5,
                reasoning="No access pattern data available, using base TTL",
                factors={"base_ttl": base_ttl},
            )

        # Adjust TTL based on access patterns
        multiplier = 1.0

        if pattern.is_hot_data:
            # Hot data gets longer TTL to reduce refresh overhead
            multiplier = 2.0
        elif pattern.is_cold_data:
            # Cold data gets shorter TTL to save memory
            multiplier = 0.5
        else:
            # Normal data, adjust based on hit ratio
            multiplier = 0.5 + (pattern.hit_ratio * 1.5)  # 0.5 to 2.0 range

        adjusted_ttl = int(base_ttl * multiplier)

        # Set refresh window for hot data
        refresh_before_expiry = pattern.is_hot_data
        refresh_window = int(adjusted_ttl * 0.1) if refresh_before_expiry else 0

        return TTLRecommendation(
            cache_key=cache_key,
            recommended_ttl_seconds=adjusted_ttl,
            strategy_used=TTLStrategy.ADAPTIVE,
            confidence=0.9,
            reasoning=(
                f"Adaptive TTL based on access pattern: "
                f"{'hot' if pattern.is_hot_data else 'cold' if pattern.is_cold_data else 'normal'} data"
            ),
            factors={
                "base_ttl": base_ttl,
                "multiplier": multiplier,
                "hit_ratio": pattern.hit_ratio,
                "access_frequency": pattern.access_frequency_per_hour,
                "is_hot_data": pattern.is_hot_data,
                "is_cold_data": pattern.is_cold_data,
            },
            refresh_before_expiry=refresh_before_expiry,
            refresh_window_seconds=refresh_window,
        )

    def calculate_predictive_ttl(
        self, cache_key: str, metadata: Dict[str, Any]
    ) -> TTLRecommendation:
        """Calculate predictive TTL based on predicted access patterns"""
        pattern = self.access_patterns.get(cache_key)
        base_ttl = CacheKeys.get_ttl_recommendation(cache_key)

        if not pattern or not pattern.access_times:
            return TTLRecommendation(
                cache_key=cache_key,
                recommended_ttl_seconds=base_ttl,
                strategy_used=TTLStrategy.PREDICTIVE,
                confidence=0.5,
                reasoning="Insufficient data for prediction, using base TTL",
                factors={"base_ttl": base_ttl},
            )

        # Predict next access time
        next_access = pattern.predict_next_access()
        if not next_access:
            return self.calculate_adaptive_ttl(cache_key, metadata)

        # Calculate TTL to cover until next predicted access with some buffer
        time_until_next_access = (next_access - datetime.utcnow()).total_seconds()
        buffer_seconds = max(
            300, time_until_next_access * 0.2
        )  # 20% buffer, minimum 5 minutes
        predicted_ttl = int(time_until_next_access + buffer_seconds)

        # Bound the TTL to reasonable limits
        min_ttl = base_ttl // 2
        max_ttl = base_ttl * 3
        predicted_ttl = max(min_ttl, min(predicted_ttl, max_ttl))

        return TTLRecommendation(
            cache_key=cache_key,
            recommended_ttl_seconds=predicted_ttl,
            strategy_used=TTLStrategy.PREDICTIVE,
            confidence=0.8,
            reasoning=f"Predictive TTL based on next access prediction: {next_access.isoformat()}",
            factors={
                "base_ttl": base_ttl,
                "predicted_next_access": next_access.isoformat(),
                "time_until_next_access": time_until_next_access,
                "buffer_seconds": buffer_seconds,
                "average_interval": pattern.average_access_interval_seconds,
            },
            refresh_before_expiry=True,
            refresh_window_seconds=int(buffer_seconds),
        )

    def calculate_system_aware_ttl(
        self, cache_key: str, metadata: Dict[str, Any]
    ) -> TTLRecommendation:
        """Calculate system load-aware TTL"""
        base_ttl = CacheKeys.get_ttl_recommendation(cache_key)

        # Get current system load metrics
        current_load = self._get_current_system_load()
        memory_pressure = self._get_memory_pressure()

        # Adjust TTL based on system metrics
        load_multiplier = 1.0

        if current_load > 0.8:  # High system load
            load_multiplier *= 0.7  # Shorter TTL to reduce memory pressure
        elif current_load < 0.3:  # Low system load
            load_multiplier *= 1.3  # Longer TTL since we have capacity

        if memory_pressure > 0.8:  # High memory pressure
            load_multiplier *= 0.6  # Significantly shorter TTL
        elif memory_pressure < 0.4:  # Low memory pressure
            load_multiplier *= 1.2  # Slightly longer TTL

        adjusted_ttl = int(base_ttl * load_multiplier)

        return TTLRecommendation(
            cache_key=cache_key,
            recommended_ttl_seconds=adjusted_ttl,
            strategy_used=TTLStrategy.SYSTEM_LOAD_AWARE,
            confidence=0.7,
            reasoning=f"System-aware TTL: load={current_load:.2f}, memory_pressure={memory_pressure:.2f}",
            factors={
                "base_ttl": base_ttl,
                "system_load": current_load,
                "memory_pressure": memory_pressure,
                "load_multiplier": load_multiplier,
            },
        )

    def calculate_hybrid_ttl(
        self, cache_key: str, data_type: Optional[str], metadata: Dict[str, Any]
    ) -> TTLRecommendation:
        """Calculate hybrid TTL using weighted combination of strategies"""
        # Get recommendations from different strategies
        static_rec = self.calculate_static_ttl(cache_key, data_type, metadata)
        adaptive_rec = self.calculate_adaptive_ttl(cache_key, metadata)
        predictive_rec = self.calculate_predictive_ttl(cache_key, metadata)
        system_rec = self.calculate_system_aware_ttl(cache_key, metadata)

        # Calculate weighted average
        recommendations = [
            (static_rec, self.strategy_weights[TTLStrategy.STATIC]),
            (adaptive_rec, self.strategy_weights[TTLStrategy.ADAPTIVE]),
            (predictive_rec, self.strategy_weights[TTLStrategy.PREDICTIVE]),
            (system_rec, self.strategy_weights[TTLStrategy.SYSTEM_LOAD_AWARE]),
        ]

        total_weight = sum(weight for _, weight in recommendations)
        weighted_ttl = (
            sum(rec.recommended_ttl_seconds * weight for rec, weight in recommendations)
            / total_weight
        )

        final_ttl = int(weighted_ttl)

        # Calculate overall confidence
        confidence = (
            sum(rec.confidence * weight for rec, weight in recommendations)
            / total_weight
        )

        # Determine refresh settings
        refresh_recommendations = [
            rec for rec, _ in recommendations if rec.refresh_before_expiry
        ]
        refresh_before_expiry = len(refresh_recommendations) >= 2  # Majority vote
        refresh_window = int(final_ttl * 0.1) if refresh_before_expiry else 0

        return TTLRecommendation(
            cache_key=cache_key,
            recommended_ttl_seconds=final_ttl,
            strategy_used=TTLStrategy.HYBRID,
            confidence=confidence,
            reasoning="Hybrid TTL using weighted combination of all strategies",
            factors={
                "static_ttl": static_rec.recommended_ttl_seconds,
                "adaptive_ttl": adaptive_rec.recommended_ttl_seconds,
                "predictive_ttl": predictive_rec.recommended_ttl_seconds,
                "system_aware_ttl": system_rec.recommended_ttl_seconds,
                "weights": dict(self.strategy_weights),
                "final_ttl": final_ttl,
            },
            refresh_before_expiry=refresh_before_expiry,
            refresh_window_seconds=refresh_window,
        )

    def _get_current_system_load(self) -> float:
        """Get current system load (0.0 to 1.0)"""
        try:
            import psutil

            return psutil.cpu_percent(interval=0.1) / 100.0
        except ImportError:
            # Fallback if psutil not available
            return 0.5

    def _get_memory_pressure(self) -> float:
        """Get current memory pressure (0.0 to 1.0)"""
        try:
            import psutil

            memory = psutil.virtual_memory()
            return memory.percent / 100.0
        except ImportError:
            # Fallback if psutil not available
            return 0.5
