"""
Utility functions for TTL management.

This module contains helper functions and utilities used throughout
the TTL management system.

Generated by CC (Claude Code)
"""

from typing import Dict, List

from app.core.logging import get_logger
from .base import CacheAccessPattern

logger = get_logger(__name__)


def evict_old_patterns(
    access_patterns: Dict[str, CacheAccessPattern], max_patterns: int
) -> None:
    """
    Evict old access patterns to control memory usage.

    Args:
        access_patterns: Dictionary of cache access patterns
        max_patterns: Maximum number of patterns to keep
    """
    if len(access_patterns) < max_patterns:
        return

    # Sort patterns by last access time and remove oldest 10%
    patterns_by_age = sorted(
        access_patterns.items(),
        key=lambda x: x[1].last_access or x[1].creation_time,
    )

    evict_count = len(patterns_by_age) // 10  # Remove 10%
    for cache_key, _ in patterns_by_age[:evict_count]:
        del access_patterns[cache_key]

    logger.debug(f"Evicted {evict_count} old access patterns")


def warm_cache_keys(
    cache_keys: List[str], access_patterns: Dict[str, CacheAccessPattern], warm_callback
) -> List[str]:
    """
    Identify hot cache keys for warming.

    Args:
        cache_keys: List of cache keys to check
        access_patterns: Dictionary of cache access patterns
        warm_callback: Function to call for warming cache

    Returns:
        List of hot cache keys that were warmed
    """
    hot_keys = []

    for cache_key in cache_keys:
        pattern = access_patterns.get(cache_key)
        if pattern and pattern.is_hot_data:
            hot_keys.append(cache_key)

    if hot_keys:
        try:
            warm_callback(hot_keys)
            logger.info(f"Warmed cache for {len(hot_keys)} hot keys")
        except Exception as e:
            logger.error(f"Cache warming failed: {e}")

    return hot_keys


def calculate_metrics_summary(metrics) -> Dict[str, float]:
    """
    Calculate summary metrics for TTL management.

    Args:
        metrics: TTLMetrics object

    Returns:
        Dictionary of summary metrics
    """
    total_refresh_tasks = metrics.refresh_tasks_scheduled
    success_rate = 0.0
    if total_refresh_tasks > 0:
        success_rate = (metrics.refresh_tasks_completed / total_refresh_tasks) * 100

    return {
        "success_rate": success_rate,
        "average_processing_time_ms": metrics.average_processing_time_ms,
        "total_calculations": metrics.total_ttl_calculations,
        "cache_hits_prevented": metrics.cache_hits_prevented,
    }


def validate_ttl_recommendation(recommendation) -> bool:
    """
    Validate a TTL recommendation for basic sanity checks.

    Args:
        recommendation: TTLRecommendation object

    Returns:
        True if recommendation is valid, False otherwise
    """
    if not recommendation:
        return False

    # Check basic field requirements
    if not recommendation.cache_key:
        return False

    if recommendation.recommended_ttl_seconds <= 0:
        return False

    if not (0.0 <= recommendation.confidence <= 1.0):
        return False

    # Check refresh window doesn't exceed TTL
    if (
        recommendation.refresh_before_expiry
        and recommendation.refresh_window_seconds
        >= recommendation.recommended_ttl_seconds
    ):
        return False

    return True


def get_system_metrics() -> Dict[str, float]:
    """
    Get current system metrics for load-aware calculations.

    Returns:
        Dictionary containing system load and memory pressure
    """
    try:
        import psutil

        cpu_percent = psutil.cpu_percent(interval=0.1)
        memory = psutil.virtual_memory()

        return {
            "cpu_load": cpu_percent / 100.0,
            "memory_pressure": memory.percent / 100.0,
            "available_memory_gb": memory.available / (1024**3),
        }
    except ImportError:
        # Fallback if psutil not available
        return {"cpu_load": 0.5, "memory_pressure": 0.5, "available_memory_gb": 4.0}
