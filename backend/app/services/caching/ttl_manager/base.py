"""
Base classes, enums, and dataclasses for TTL management.

This module contains the core data structures and enums used throughout
the TTL management system.

Generated by CC (Claude Code)
"""

from collections import defaultdict, deque
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Tuple


class TTLStrategy(Enum):
    """TTL calculation strategies"""

    STATIC = "static"  # Fixed TTL based on data type
    ADAPTIVE = "adaptive"  # TTL adapts based on access patterns
    PREDICTIVE = "predictive"  # TTL based on predicted access patterns
    SYSTEM_LOAD_AWARE = "system_aware"  # TTL adapts to system load
    HYBRID = "hybrid"  # Combination of multiple strategies


class RefreshPriority(Enum):
    """Background refresh priority levels"""

    CRITICAL = 1  # Authentication, security data
    HIGH = 2  # User context, active sessions
    MEDIUM = 3  # Client data, engagement data
    LOW = 4  # Analytics, reports
    BACKGROUND = 5  # Optimization, cleanup


@dataclass
class CacheAccessPattern:
    """Tracks access patterns for a cache key"""

    cache_key: str
    total_accesses: int = 0
    hits: int = 0
    misses: int = 0
    access_times: deque = field(default_factory=lambda: deque(maxlen=100))
    last_access: Optional[datetime] = None
    creation_time: datetime = field(default_factory=datetime.utcnow)
    average_access_interval_seconds: float = 0
    peak_access_periods: List[Tuple[int, int]] = field(
        default_factory=list
    )  # (hour_start, hour_end)

    @property
    def hit_ratio(self) -> float:
        """Calculate hit ratio"""
        total = self.hits + self.misses
        return self.hits / total if total > 0 else 0.0

    @property
    def access_frequency_per_hour(self) -> float:
        """Calculate access frequency per hour"""
        if not self.access_times or len(self.access_times) < 2:
            return 0.0

        oldest_access = self.access_times[0]
        newest_access = self.access_times[-1]
        time_span_hours = (newest_access - oldest_access).total_seconds() / 3600

        return len(self.access_times) / max(time_span_hours, 1.0)

    @property
    def is_hot_data(self) -> bool:
        """Check if this is frequently accessed hot data"""
        return (
            self.access_frequency_per_hour > 10  # More than 10 accesses per hour
            and self.hit_ratio > 0.8  # High hit ratio
        )

    @property
    def is_cold_data(self) -> bool:
        """Check if this is infrequently accessed cold data"""
        return (
            self.access_frequency_per_hour < 1  # Less than 1 access per hour
            and self.last_access
            and (datetime.utcnow() - self.last_access).total_seconds()
            > 3600  # No access in last hour
        )

    def record_access(self, was_hit: bool) -> None:
        """Record a cache access"""
        now = datetime.utcnow()
        self.total_accesses += 1
        self.access_times.append(now)
        self.last_access = now

        if was_hit:
            self.hits += 1
        else:
            self.misses += 1

        # Update average access interval
        if len(self.access_times) >= 2:
            intervals = []
            for i in range(1, len(self.access_times)):
                interval = (
                    self.access_times[i] - self.access_times[i - 1]
                ).total_seconds()
                intervals.append(interval)
            self.average_access_interval_seconds = sum(intervals) / len(intervals)

    def predict_next_access(self) -> Optional[datetime]:
        """Predict when this key will likely be accessed next"""
        if not self.last_access or self.average_access_interval_seconds == 0:
            return None

        return self.last_access + timedelta(
            seconds=self.average_access_interval_seconds
        )


@dataclass
class TTLRecommendation:
    """TTL recommendation with reasoning"""

    cache_key: str
    recommended_ttl_seconds: int
    strategy_used: TTLStrategy
    confidence: float  # 0.0 to 1.0
    reasoning: str
    factors: Dict[str, Any] = field(default_factory=dict)
    refresh_before_expiry: bool = False
    refresh_window_seconds: int = 0

    def should_refresh_early(self, current_ttl_remaining: int) -> bool:
        """Check if cache should be refreshed before expiry"""
        if not self.refresh_before_expiry:
            return False
        return current_ttl_remaining <= self.refresh_window_seconds


@dataclass
class RefreshTask:
    """Background refresh task"""

    cache_key: str
    priority: RefreshPriority
    refresh_callback: Callable[[str], Any]
    scheduled_time: datetime
    created_at: datetime = field(default_factory=datetime.utcnow)
    retry_count: int = 0
    max_retries: int = 3

    @property
    def is_due(self) -> bool:
        """Check if refresh task is due"""
        return datetime.utcnow() >= self.scheduled_time

    @property
    def should_retry(self) -> bool:
        """Check if task should be retried"""
        return self.retry_count < self.max_retries


@dataclass
class TTLMetrics:
    """TTL management metrics"""

    total_ttl_calculations: int = 0
    strategy_usage: Dict[TTLStrategy, int] = field(
        default_factory=lambda: defaultdict(int)
    )
    refresh_tasks_scheduled: int = 0
    refresh_tasks_completed: int = 0
    refresh_tasks_failed: int = 0
    cache_hits_prevented: int = 0  # Estimated cache misses prevented by refresh
    total_processing_time_ms: float = 0
    average_processing_time_ms: float = 0
    last_reset: datetime = field(default_factory=datetime.utcnow)

    def update_calculation(
        self, strategy: TTLStrategy, processing_time_ms: float
    ) -> None:
        """Update metrics for TTL calculation"""
        self.total_ttl_calculations += 1
        self.strategy_usage[strategy] += 1
        self.total_processing_time_ms += processing_time_ms

        if self.total_ttl_calculations > 0:
            self.average_processing_time_ms = (
                self.total_processing_time_ms / self.total_ttl_calculations
            )
