"""
Cache Consistency Checker - Modularized Implementation

This module provides comprehensive cache consistency verification and repair
functionality through a modularized architecture for better maintainability
and extensibility.

Architecture Overview:
â”œâ”€â”€ base.py              # Core types, enums, and dataclasses
â”œâ”€â”€ exceptions.py        # Specialized exception classes
â”œâ”€â”€ validators.py        # Consistency validation implementations
â”œâ”€â”€ synchronizers.py     # Data synchronization with database
â”œâ”€â”€ conflict_resolvers.py# Repair strategies and conflict resolution
â”œâ”€â”€ monitors.py          # Metrics, alerts, and health monitoring
â”œâ”€â”€ policies.py          # Consistency policies and rules
â”œâ”€â”€ recovery.py          # Audit operations and scheduled tasks
â””â”€â”€ cache_consistency_checker.py # Main orchestrator class

Key Features:
ðŸ”’ Security: Multi-tenant isolation and secure consistency verification
âš¡ Performance: Optimized consistency checks with minimal database queries
ðŸŽ¯ Coherence: Comprehensive data integrity verification and repair
ðŸ“Š Analytics: Detailed consistency metrics and audit trails
ðŸ”§ Modular: Clean separation of concerns for maintainability

Usage:
    ```python
    from app.services.caching.cache_consistency_checker import (
        CacheConsistencyChecker,
        ConsistencyCheckType,
        create_cache_consistency_checker,
    )

    # Create checker instance
    checker = await create_cache_consistency_checker(redis_cache, db_session)

    # Perform consistency check
    result = await checker.check_cache_consistency(
        "user:123:context",
        ConsistencyCheckType.DEEP
    )

    # Run full audit
    report = await checker.run_full_consistency_audit()
    ```

Generated by CC (Claude Code)
"""

# Core base classes and types - Main exports for backward compatibility
from .base import (
    ConsistencyCheckType,
    ConsistencyStatus,
    RepairAction,
    ConsistencyCheckResult,
    ConsistencyAuditReport,
    ConsistencyMetrics,
    ConsistencyConfiguration,
    EntityInfo,
    DEFAULT_CONFIG,
    CACHE_KEY_PATTERNS,
    PERFORMANCE_THRESHOLDS,
    create_default_metrics,
    create_default_configuration,
    validate_cache_key,
    validate_data_size,
    calculate_confidence_score,
)

# Main orchestrator class - Primary export
from .cache_consistency_checker import (
    CacheConsistencyChecker,
    create_cache_consistency_checker,
)

# Exception classes
from .exceptions import (
    CacheConsistencyError,
    ConsistencyCheckError,
    ConsistencyRepairError,
    ConsistencyValidationError,
    ConsistencyAuditError,
    QuarantineError,
    MetricsCollectionError,
    ScheduledAuditError,
)

# Validator components
from .validators import (
    CacheKeyParser,
    DataComparator,
    SchemaValidator,
    ConsistencyValidator,
)

# Synchronizer components
from .synchronizers import (
    DatabaseSessionManager,
    EntityDataExtractor,
    CacheMetadataRetriever,
    DataSynchronizer,
)

# Conflict resolution components
from .conflict_resolvers import (
    QuarantineManager,
    RepairActionDeterminer,
    RepairHandler,
    ConflictResolver,
)

# Monitoring components
from .monitors import (
    PerformanceMetrics,
    AlertManager,
    HealthChecker,
    ConsistencyMonitor,
)

# Policy components
from .policies import (
    Priority,
    RiskLevel,
    ConsistencyPolicy,
    EntityTypePolicy,
    DataAgePolicy,
    BusinessHoursPolicy,
    InconsistencyPatternPolicy,
    CompliancePolicy,
    ResourceUtilizationPolicy,
)

# Policy engine
from .policy_engine import PolicyEngine

# Recovery components
from .recovery import (
    BulkConsistencyChecker,
    AuditReportGenerator,
    ScheduledAuditManager,
)

# Main exports for backward compatibility - preserve original interface
__all__ = [
    # Primary class and factory (main interface)
    "CacheConsistencyChecker",
    "create_cache_consistency_checker",
    # Core types and enums (essential for users)
    "ConsistencyCheckType",
    "ConsistencyStatus",
    "RepairAction",
    "ConsistencyCheckResult",
    "ConsistencyAuditReport",
    "ConsistencyMetrics",
    "ConsistencyConfiguration",
    # Exception classes (for error handling)
    "CacheConsistencyError",
    "ConsistencyCheckError",
    "ConsistencyRepairError",
    "ConsistencyValidationError",
    "ConsistencyAuditError",
    "QuarantineError",
    "MetricsCollectionError",
    "ScheduledAuditError",
    # Factory functions (utility)
    "create_default_metrics",
    "create_default_configuration",
    # Constants (configuration)
    "DEFAULT_CONFIG",
    "CACHE_KEY_PATTERNS",
    "PERFORMANCE_THRESHOLDS",
    # Advanced components (for extensibility)
    "ConsistencyValidator",
    "DataSynchronizer",
    "ConflictResolver",
    "ConsistencyMonitor",
    "PolicyEngine",
    "ScheduledAuditManager",
    # Utility classes (for advanced usage)
    "CacheKeyParser",
    "DataComparator",
    "SchemaValidator",
    "QuarantineManager",
    "PerformanceMetrics",
    "AlertManager",
    "HealthChecker",
    "BulkConsistencyChecker",
    "AuditReportGenerator",
    # Policy classes (for customization)
    "Priority",
    "RiskLevel",
    "ConsistencyPolicy",
    "EntityTypePolicy",
    "DataAgePolicy",
    "BusinessHoursPolicy",
    "InconsistencyPatternPolicy",
    "CompliancePolicy",
    "ResourceUtilizationPolicy",
    # Entity and validation utilities
    "EntityInfo",
    "validate_cache_key",
    "validate_data_size",
    "calculate_confidence_score",
    # Session and data management
    "DatabaseSessionManager",
    "EntityDataExtractor",
    "CacheMetadataRetriever",
    # Repair components
    "RepairActionDeterminer",
    "RepairHandler",
]

# Version information
__version__ = "2.0.0"
__author__ = "Cache Consistency Team"
__description__ = (
    "Modularized cache consistency checker with comprehensive validation, "
    "repair, monitoring, and policy-based operations"
)

# Backward compatibility aliases - ensure existing code continues to work
# These provide the exact same interface as the original implementation
CacheConsistencyChecker = CacheConsistencyChecker
ConsistencyCheckResult = ConsistencyCheckResult
ConsistencyAuditReport = ConsistencyAuditReport
ConsistencyMetrics = ConsistencyMetrics
create_cache_consistency_checker = create_cache_consistency_checker

# Legacy imports that may be used by existing code
ConsistencyCheckType = ConsistencyCheckType
ConsistencyStatus = ConsistencyStatus
RepairAction = RepairAction

# Configuration defaults
DEFAULT_BATCH_SIZE = DEFAULT_CONFIG.batch_size
DEFAULT_MAX_CONCURRENT = DEFAULT_CONFIG.max_concurrent_checks
DEFAULT_CHECK_INTERVAL = DEFAULT_CONFIG.default_check_interval_hours
DEFAULT_PERFORMANCE_THRESHOLD = DEFAULT_CONFIG.performance_impact_threshold


# Utility functions for common operations
def create_default_checker(redis_cache, db_session=None, **kwargs):
    """
    Create a CacheConsistencyChecker with default configuration.

    Args:
        redis_cache: Redis cache instance
        db_session: Optional database session
        **kwargs: Additional configuration options

    Returns:
        CacheConsistencyChecker instance
    """
    import asyncio

    async def _create():
        config = create_default_configuration(**kwargs) if kwargs else None
        return CacheConsistencyChecker(redis_cache, db_session, config)

    # For synchronous usage (backward compatibility)
    try:
        loop = asyncio.get_event_loop()
        return loop.run_until_complete(_create())
    except RuntimeError:
        # If no event loop is running, return the coroutine
        return _create()


def get_consistency_metrics_summary(checker: CacheConsistencyChecker) -> dict:
    """
    Get a summary of consistency metrics.

    Args:
        checker: CacheConsistencyChecker instance

    Returns:
        Dictionary with metrics summary
    """
    metrics = checker.get_consistency_metrics()
    return {
        "total_checks": metrics.get("total_checks", 0),
        "consistency_score": metrics.get("consistency_score", 0),
        "repair_success_rate": metrics.get("repairs", {}).get("success_rate", 0),
        "last_audit": metrics.get("last_audit_time"),
        "quarantined_items": metrics.get("quarantined_items", 0),
    }


# Module initialization
def _initialize_module():
    """Initialize the cache consistency checker module"""
    import logging

    logger = logging.getLogger(__name__)
    logger.info(f"Cache Consistency Checker module initialized (version {__version__})")
    logger.info("Modularized architecture loaded with enhanced functionality")


# Initialize module on import
_initialize_module()

# Export utility functions
__all__.extend(
    [
        "create_default_checker",
        "get_consistency_metrics_summary",
    ]
)

# Module metadata for introspection
__module_info__ = {
    "name": "cache_consistency_checker",
    "version": __version__,
    "description": __description__,
    "architecture": "modularized",
    "components": [
        "base",
        "exceptions",
        "validators",
        "synchronizers",
        "conflict_resolvers",
        "monitors",
        "policies",
        "recovery",
    ],
    "main_class": "CacheConsistencyChecker",
    "factory_function": "create_cache_consistency_checker",
    "backward_compatible": True,
}
