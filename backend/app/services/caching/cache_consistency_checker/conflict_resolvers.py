"""
Cache Consistency Conflict Resolvers

This module implements repair strategies for cache consistency violations:
- Repair action determination based on inconsistency type
- Specific repair handlers for different scenarios
- Quarantine management for suspicious data
- Retry logic and error handling for repair operations

ðŸ”’ Security: Safe repair operations with data validation
âš¡ Performance: Efficient repair strategies with minimal system impact
ðŸŽ¯ Coherence: Comprehensive repair coverage for all inconsistency types

Generated by CC (Claude Code)
"""

import asyncio
from datetime import datetime
from typing import Any, Dict, List, Optional

from app.constants.cache_keys import CacheKeys
from app.core.logging import get_logger
from app.services.caching.redis_cache import RedisCache

from .base import (
    ConsistencyCheckResult,
    ConsistencyStatus,
    RepairAction,
)
from .exceptions import ConsistencyRepairError, QuarantineError
from .synchronizers import DataSynchronizer
from .validators import CacheKeyParser

logger = get_logger(__name__)


class QuarantineManager:
    """Manages quarantined cache data"""

    def __init__(self, max_items: int = 10000):
        self.quarantine_storage: Dict[str, Dict[str, Any]] = {}
        self.max_items = max_items

    def quarantine_data(
        self,
        cache_key: str,
        data: Any,
        reason: str,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> bool:
        """Add data to quarantine storage"""
        try:
            # Check storage limits
            if len(self.quarantine_storage) >= self.max_items:
                # Remove oldest entries to make space
                oldest_keys = sorted(
                    self.quarantine_storage.keys(),
                    key=lambda k: self.quarantine_storage[k]["quarantined_at"],
                )[
                    :100
                ]  # Remove 100 oldest entries

                for old_key in oldest_keys:
                    del self.quarantine_storage[old_key]

            quarantine_entry = {
                "data": data,
                "quarantined_at": datetime.utcnow().isoformat(),
                "reason": reason,
                "metadata": metadata or {},
            }

            self.quarantine_storage[cache_key] = quarantine_entry
            logger.info(f"Quarantined data for {cache_key}: {reason}")
            return True

        except Exception as e:
            logger.error(f"Failed to quarantine data for {cache_key}: {e}")
            return False

    def get_quarantined_data(self, cache_key: str) -> Optional[Dict[str, Any]]:
        """Retrieve quarantined data"""
        return self.quarantine_storage.get(cache_key)

    def remove_from_quarantine(self, cache_key: str) -> bool:
        """Remove data from quarantine"""
        try:
            if cache_key in self.quarantine_storage:
                del self.quarantine_storage[cache_key]
                logger.info(f"Removed {cache_key} from quarantine")
                return True
            return False
        except Exception as e:
            logger.error(f"Failed to remove {cache_key} from quarantine: {e}")
            return False

    def get_quarantine_summary(self) -> Dict[str, Any]:
        """Get summary of quarantined items"""
        return {
            "total_items": len(self.quarantine_storage),
            "oldest_entry": (
                min(
                    entry["quarantined_at"]
                    for entry in self.quarantine_storage.values()
                )
                if self.quarantine_storage
                else None
            ),
            "most_recent": (
                max(
                    entry["quarantined_at"]
                    for entry in self.quarantine_storage.values()
                )
                if self.quarantine_storage
                else None
            ),
            "reasons": list(
                set(entry["reason"] for entry in self.quarantine_storage.values())
            ),
        }

    def cleanup_expired_quarantine(self, retention_days: int = 7) -> int:
        """Remove expired quarantine entries"""
        from datetime import timedelta

        cutoff_time = datetime.utcnow() - timedelta(days=retention_days)
        expired_keys = []

        for key, entry in self.quarantine_storage.items():
            try:
                quarantine_time = datetime.fromisoformat(entry["quarantined_at"])
                if quarantine_time < cutoff_time:
                    expired_keys.append(key)
            except (ValueError, KeyError):
                # Invalid timestamp, consider it expired
                expired_keys.append(key)

        for key in expired_keys:
            del self.quarantine_storage[key]

        if expired_keys:
            logger.info(f"Cleaned up {len(expired_keys)} expired quarantine entries")

        return len(expired_keys)


class RepairActionDeterminer:
    """Determines appropriate repair actions for different inconsistency types"""

    @staticmethod
    def determine_repair_action(result: ConsistencyCheckResult) -> RepairAction:
        """Determine appropriate repair action for inconsistency"""
        if result.status == ConsistencyStatus.MISSING:
            return RepairAction.REFRESH_FROM_DB
        elif result.status == ConsistencyStatus.ORPHANED:
            return RepairAction.DELETE_ORPHANED
        elif result.status == ConsistencyStatus.CORRUPTED:
            return RepairAction.QUARANTINE
        elif result.status == ConsistencyStatus.INCONSISTENT:
            # For inconsistent data, prefer refresh unless confidence is very low
            if result.confidence < 0.3:
                return RepairAction.QUARANTINE
            else:
                return RepairAction.REFRESH_FROM_DB
        elif result.status == ConsistencyStatus.STALE:
            return RepairAction.REFRESH_FROM_DB
        else:
            return RepairAction.INVALIDATE_CACHE

    @staticmethod
    def validate_repair_action(
        result: ConsistencyCheckResult, action: RepairAction
    ) -> bool:
        """Validate that repair action is appropriate for the inconsistency"""
        valid_actions = {
            ConsistencyStatus.MISSING: [RepairAction.REFRESH_FROM_DB],
            ConsistencyStatus.ORPHANED: [
                RepairAction.DELETE_ORPHANED,
                RepairAction.INVALIDATE_CACHE,
            ],
            ConsistencyStatus.CORRUPTED: [
                RepairAction.QUARANTINE,
                RepairAction.INVALIDATE_CACHE,
            ],
            ConsistencyStatus.INCONSISTENT: [
                RepairAction.REFRESH_FROM_DB,
                RepairAction.QUARANTINE,
            ],
            ConsistencyStatus.STALE: [
                RepairAction.REFRESH_FROM_DB,
                RepairAction.INVALIDATE_CACHE,
            ],
        }

        return action in valid_actions.get(result.status, [])


class RepairHandler:
    """Handles specific repair operations"""

    def __init__(
        self,
        redis_cache: RedisCache,
        data_synchronizer: DataSynchronizer,
        quarantine_manager: QuarantineManager,
    ):
        self.redis_cache = redis_cache
        self.data_synchronizer = data_synchronizer
        self.quarantine_manager = quarantine_manager
        self.key_parser = CacheKeyParser()

    async def repair_refresh_from_db(self, result: ConsistencyCheckResult) -> bool:
        """Repair by refreshing cache from database"""
        try:
            # Parse cache key to get entity info
            entity_info = self.key_parser.parse_cache_key(result.cache_key)
            if not entity_info or not entity_info.is_valid:
                logger.error(f"Cannot parse cache key for refresh: {result.cache_key}")
                return False

            # Get fresh data from database
            db_value = await self.data_synchronizer.get_database_value(
                entity_info, None
            )

            if db_value is None:
                # No database data, delete cache entry
                logger.info(
                    f"No database data for {result.cache_key}, deleting cache entry"
                )
                return await self.redis_cache.delete(result.cache_key)

            # Update cache with fresh data
            ttl = CacheKeys.get_ttl_recommendation(result.cache_key)
            success = await self.redis_cache.set(result.cache_key, db_value, ttl)

            if success:
                logger.info(f"Successfully refreshed cache for {result.cache_key}")
            else:
                logger.error(f"Failed to refresh cache for {result.cache_key}")

            return success

        except Exception as e:
            logger.error(f"Refresh from DB failed for {result.cache_key}: {e}")
            raise ConsistencyRepairError(
                f"Refresh from DB failed: {e}",
                cache_key=result.cache_key,
                repair_action="refresh_from_db",
            )

    async def repair_invalidate_cache(self, result: ConsistencyCheckResult) -> bool:
        """Repair by invalidating cache entry"""
        try:
            success = await self.redis_cache.delete(result.cache_key)

            if success:
                logger.info(f"Successfully invalidated cache for {result.cache_key}")
            else:
                logger.warning(
                    f"Cache invalidation returned false for {result.cache_key}"
                )

            return success

        except Exception as e:
            logger.error(f"Cache invalidation failed for {result.cache_key}: {e}")
            raise ConsistencyRepairError(
                f"Cache invalidation failed: {e}",
                cache_key=result.cache_key,
                repair_action="invalidate_cache",
            )

    async def repair_delete_orphaned(self, result: ConsistencyCheckResult) -> bool:
        """Repair by deleting orphaned cache entry"""
        try:
            # Same as invalidate, but with different logging context
            success = await self.redis_cache.delete(result.cache_key)

            if success:
                logger.info(
                    f"Successfully deleted orphaned cache entry for {result.cache_key}"
                )
            else:
                logger.warning(
                    f"Orphaned entry deletion returned false for {result.cache_key}"
                )

            return success

        except Exception as e:
            logger.error(f"Orphaned entry deletion failed for {result.cache_key}: {e}")
            raise ConsistencyRepairError(
                f"Orphaned entry deletion failed: {e}",
                cache_key=result.cache_key,
                repair_action="delete_orphaned",
            )

    async def repair_quarantine(self, result: ConsistencyCheckResult) -> bool:
        """Repair by quarantining suspicious data"""
        try:
            # Quarantine the data
            success = self.quarantine_manager.quarantine_data(
                result.cache_key,
                result.cache_value,
                result.details,
                metadata={
                    "status": result.status.value,
                    "check_type": result.check_type.value,
                    "confidence": result.confidence,
                    "timestamp": result.timestamp.isoformat(),
                },
            )

            if not success:
                logger.error(f"Failed to quarantine data for {result.cache_key}")
                return False

            # Delete from cache
            await self.redis_cache.delete(result.cache_key)

            logger.info(f"Successfully quarantined data for {result.cache_key}")
            return True

        except Exception as e:
            logger.error(f"Quarantine failed for {result.cache_key}: {e}")
            raise QuarantineError(
                f"Quarantine failed: {e}",
                cache_key=result.cache_key,
                quarantine_reason=result.details,
            )

    async def repair_update_database(self, result: ConsistencyCheckResult) -> bool:
        """Repair by updating database (rare case)"""
        # This is a dangerous operation and should be used very carefully
        logger.warning(
            f"Database update repair requested for {result.cache_key} - "
            "this operation is not implemented for safety reasons"
        )
        return False


class ConflictResolver:
    """Main conflict resolution orchestrator"""

    def __init__(
        self,
        redis_cache: RedisCache,
        data_synchronizer: DataSynchronizer,
        quarantine_manager: Optional[QuarantineManager] = None,
        max_retry_attempts: int = 3,
        retry_delay_seconds: float = 1.0,
    ):
        self.redis_cache = redis_cache
        self.data_synchronizer = data_synchronizer
        self.quarantine_manager = quarantine_manager or QuarantineManager()
        self.max_retry_attempts = max_retry_attempts
        self.retry_delay_seconds = retry_delay_seconds

        self.repair_handler = RepairHandler(
            redis_cache, data_synchronizer, self.quarantine_manager
        )
        self.action_determiner = RepairActionDeterminer()

        # Map repair actions to handler methods
        self.repair_handlers = {
            RepairAction.REFRESH_FROM_DB: self.repair_handler.repair_refresh_from_db,
            RepairAction.INVALIDATE_CACHE: self.repair_handler.repair_invalidate_cache,
            RepairAction.DELETE_ORPHANED: self.repair_handler.repair_delete_orphaned,
            RepairAction.QUARANTINE: self.repair_handler.repair_quarantine,
            RepairAction.UPDATE_DATABASE: self.repair_handler.repair_update_database,
        }

    async def resolve_inconsistency(self, result: ConsistencyCheckResult) -> bool:
        """
        Resolve a single inconsistency with retry logic.

        Args:
            result: ConsistencyCheckResult indicating the inconsistency

        Returns:
            True if repair was successful
        """
        if not result.needs_repair:
            return True

        # Determine repair action if not already suggested
        if not result.suggested_repair:
            result.suggested_repair = self.action_determiner.determine_repair_action(
                result
            )

        # Validate repair action
        if not self.action_determiner.validate_repair_action(
            result, result.suggested_repair
        ):
            logger.error(
                f"Invalid repair action {result.suggested_repair} for status {result.status}"
            )
            return False

        repair_handler = self.repair_handlers.get(result.suggested_repair)
        if not repair_handler:
            logger.error(f"No repair handler for action: {result.suggested_repair}")
            return False

        # Attempt repair with retry logic
        for attempt in range(self.max_retry_attempts):
            try:
                success = await repair_handler(result)

                if success:
                    logger.info(
                        f"Successfully repaired inconsistency for {result.cache_key} "
                        f"using action {result.suggested_repair.value}"
                    )
                    return True
                else:
                    logger.warning(
                        f"Repair attempt {attempt + 1} failed for {result.cache_key} "
                        f"using action {result.suggested_repair.value}"
                    )

                # Wait before retry (except for last attempt)
                if attempt < self.max_retry_attempts - 1:
                    await asyncio.sleep(self.retry_delay_seconds)

            except Exception as e:
                logger.error(
                    f"Repair attempt {attempt + 1} failed for {result.cache_key}: {e}"
                )

                # Wait before retry (except for last attempt)
                if attempt < self.max_retry_attempts - 1:
                    await asyncio.sleep(self.retry_delay_seconds)

        logger.error(
            f"All repair attempts failed for {result.cache_key} "
            f"after {self.max_retry_attempts} attempts"
        )
        return False

    async def resolve_bulk_inconsistencies(
        self, results: List[ConsistencyCheckResult]
    ) -> List[bool]:
        """Resolve multiple inconsistencies"""
        repair_results = []

        for result in results:
            try:
                success = await self.resolve_inconsistency(result)
                repair_results.append(success)
            except Exception as e:
                logger.error(f"Bulk repair failed for {result.cache_key}: {e}")
                repair_results.append(False)

        return repair_results

    def get_quarantine_summary(self) -> Dict[str, Any]:
        """Get summary of quarantined items"""
        return self.quarantine_manager.get_quarantine_summary()

    def cleanup_quarantine(self, retention_days: int = 7) -> int:
        """Remove expired quarantine entries"""
        return self.quarantine_manager.cleanup_expired_quarantine(retention_days)


# Export all conflict resolution classes
__all__ = [
    "QuarantineManager",
    "RepairActionDeterminer",
    "RepairHandler",
    "ConflictResolver",
]
