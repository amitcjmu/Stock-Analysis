"""
Cache Consistency Policy Engine

This module implements the policy evaluation engine for cache consistency management:
- Policy evaluation and application logic
- Priority and risk level assessment
- Check type determination based on policies
- Policy management (enable/disable, add/remove)

ðŸ”’ Security: Policy-based access control and data protection
âš¡ Performance: Intelligent prioritization for optimal system performance
ðŸŽ¯ Coherence: Comprehensive policy framework for all consistency scenarios

Generated by CC (Claude Code)
"""

from typing import Any, Dict, List, Optional

from app.core.logging import get_logger

from .base import (
    ConsistencyCheckType,
    ConsistencyConfiguration,
    create_default_configuration,
)
from .policies import (
    BusinessHoursPolicy,
    CompliancePolicy,
    ConsistencyPolicy,
    DataAgePolicy,
    EntityTypePolicy,
    InconsistencyPatternPolicy,
    Priority,
    ResourceUtilizationPolicy,
    RiskLevel,
)

logger = get_logger(__name__)


class PolicyEngine:
    """Engine for evaluating and applying consistency policies"""

    def __init__(self, config: Optional[ConsistencyConfiguration] = None):
        self.config = config or create_default_configuration()
        self.policies: List[ConsistencyPolicy] = []
        self._initialize_default_policies()

    def _initialize_default_policies(self) -> None:
        """Initialize default policy set"""
        self.policies = [
            EntityTypePolicy(),
            DataAgePolicy(),
            BusinessHoursPolicy(),
            InconsistencyPatternPolicy(),
            CompliancePolicy(),
            ResourceUtilizationPolicy(),
        ]

    def add_policy(self, policy: ConsistencyPolicy) -> None:
        """Add a custom policy"""
        self.policies.append(policy)

    def remove_policy(self, policy_name: str) -> bool:
        """Remove a policy by name"""
        for i, policy in enumerate(self.policies):
            if policy.name == policy_name:
                del self.policies[i]
                return True
        return False

    def enable_policy(self, policy_name: str) -> bool:
        """Enable a policy by name"""
        for policy in self.policies:
            if policy.name == policy_name:
                policy.enabled = True
                return True
        return False

    def disable_policy(self, policy_name: str) -> bool:
        """Disable a policy by name"""
        for policy in self.policies:
            if policy.name == policy_name:
                policy.enabled = False
                return True
        return False

    def evaluate_priority(self, context: Dict[str, Any]) -> Priority:
        """Evaluate priority based on all applicable policies"""
        applicable_policies = []

        for policy in self.policies:
            if policy.enabled and policy.evaluate(context):
                applicable_policies.append(policy)

        if not applicable_policies:
            return Priority.MEDIUM

        # Get priorities from all applicable policies
        priorities = [policy.get_priority(context) for policy in applicable_policies]

        # Return the highest priority
        priority_order = [
            Priority.CRITICAL,
            Priority.HIGH,
            Priority.MEDIUM,
            Priority.LOW,
            Priority.DEFERRED,
        ]

        for priority in priority_order:
            if priority in priorities:
                return priority

        return Priority.MEDIUM

    def evaluate_risk_level(self, context: Dict[str, Any]) -> RiskLevel:
        """Evaluate risk level based on all applicable policies"""
        applicable_policies = []

        for policy in self.policies:
            if policy.enabled and policy.evaluate(context):
                applicable_policies.append(policy)

        if not applicable_policies:
            return RiskLevel.MEDIUM

        # Get risk levels from all applicable policies
        risk_levels = [policy.get_risk_level(context) for policy in applicable_policies]

        # Return the highest risk level
        risk_order = [
            RiskLevel.CRITICAL,
            RiskLevel.HIGH,
            RiskLevel.MEDIUM,
            RiskLevel.LOW,
        ]

        for risk_level in risk_order:
            if risk_level in risk_levels:
                return risk_level

        return RiskLevel.MEDIUM

    def should_defer_check(self, context: Dict[str, Any]) -> bool:
        """Determine if a consistency check should be deferred"""
        priority = self.evaluate_priority(context)

        # Defer low priority checks during high-risk periods
        if priority == Priority.DEFERRED:
            return True

        # Consider resource utilization
        for policy in self.policies:
            if (
                policy.enabled
                and isinstance(policy, ResourceUtilizationPolicy)
                and not policy.evaluate(context)
                and priority in [Priority.LOW, Priority.MEDIUM]
            ):
                return True

        return False

    def determine_check_type(self, context: Dict[str, Any]) -> ConsistencyCheckType:
        """Determine appropriate check type based on policies"""
        priority = self.evaluate_priority(context)
        risk_level = self.evaluate_risk_level(context)

        # High priority/risk scenarios need deep checks
        if priority in [Priority.CRITICAL, Priority.HIGH] or risk_level in [
            RiskLevel.CRITICAL,
            RiskLevel.HIGH,
        ]:
            return ConsistencyCheckType.DEEP

        # Medium priority/risk scenarios use checksum
        if priority == Priority.MEDIUM or risk_level == RiskLevel.MEDIUM:
            return ConsistencyCheckType.CHECKSUM

        # Low priority scenarios use basic checks
        return ConsistencyCheckType.BASIC

    def record_inconsistency_pattern(self, cache_key: str) -> None:
        """Record an inconsistency pattern for policy learning"""
        for policy in self.policies:
            if isinstance(policy, InconsistencyPatternPolicy):
                policy.record_inconsistency(cache_key)

    def get_policy_summary(self) -> Dict[str, Any]:
        """Get summary of current policy configuration"""
        return {
            "total_policies": len(self.policies),
            "enabled_policies": sum(1 for p in self.policies if p.enabled),
            "policy_names": [p.name for p in self.policies],
            "enabled_policy_names": [p.name for p in self.policies if p.enabled],
        }


# Export policy engine class
__all__ = [
    "PolicyEngine",
]
