"""
Cache Consistency Policies

This module implements consistency policies and rules for cache management:
- Consistency check scheduling policies
- Repair action selection policies
- Priority-based consistency checking
- Risk assessment for different data types
- Compliance and governance rules

ðŸ”’ Security: Policy-based access control and data protection
âš¡ Performance: Intelligent prioritization for optimal system performance
ðŸŽ¯ Coherence: Comprehensive policy framework for all consistency scenarios

Generated by CC (Claude Code)
"""

from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Set

from app.core.logging import get_logger

logger = get_logger(__name__)


class Priority(Enum):
    """Priority levels for consistency operations"""

    CRITICAL = "critical"  # Must be checked immediately
    HIGH = "high"  # Should be checked within 1 hour
    MEDIUM = "medium"  # Should be checked within 6 hours
    LOW = "low"  # Can be checked within 24 hours
    DEFERRED = "deferred"  # Can be checked during maintenance windows


class RiskLevel(Enum):
    """Risk levels for different types of inconsistencies"""

    CRITICAL = "critical"  # Data corruption or security issues
    HIGH = "high"  # Business logic errors or user impact
    MEDIUM = "medium"  # Performance degradation
    LOW = "low"  # Minor inconsistencies with no immediate impact


class ConsistencyPolicy:
    """Base class for consistency policies"""

    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.enabled = True

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Evaluate if policy conditions are met"""
        raise NotImplementedError

    def get_priority(self, context: Dict[str, Any]) -> Priority:
        """Get priority level for this policy"""
        return Priority.MEDIUM

    def get_risk_level(self, context: Dict[str, Any]) -> RiskLevel:
        """Get risk level for this policy"""
        return RiskLevel.MEDIUM


class EntityTypePolicy(ConsistencyPolicy):
    """Policy based on entity type priority"""

    def __init__(self):
        super().__init__(
            "entity_type_priority",
            "Prioritizes consistency checks based on entity type importance",
        )
        self.entity_priorities = {
            "user": Priority.HIGH,
            "client": Priority.CRITICAL,
            "engagement": Priority.HIGH,
            "flow": Priority.MEDIUM,
        }
        self.entity_risks = {
            "user": RiskLevel.HIGH,
            "client": RiskLevel.CRITICAL,
            "engagement": RiskLevel.HIGH,
            "flow": RiskLevel.MEDIUM,
        }

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Always applicable for any entity"""
        return True

    def get_priority(self, context: Dict[str, Any]) -> Priority:
        """Get priority based on entity type"""
        entity_info = context.get("entity_info")
        if entity_info and hasattr(entity_info, "entity_type"):
            return self.entity_priorities.get(entity_info.entity_type, Priority.MEDIUM)
        return Priority.MEDIUM

    def get_risk_level(self, context: Dict[str, Any]) -> RiskLevel:
        """Get risk level based on entity type"""
        entity_info = context.get("entity_info")
        if entity_info and hasattr(entity_info, "entity_type"):
            return self.entity_risks.get(entity_info.entity_type, RiskLevel.MEDIUM)
        return RiskLevel.MEDIUM


class DataAgePolicy(ConsistencyPolicy):
    """Policy based on data age and staleness"""

    def __init__(self):
        super().__init__(
            "data_age_priority",
            "Prioritizes consistency checks based on data age and staleness",
        )
        self.staleness_thresholds = {
            "user": timedelta(hours=6),
            "client": timedelta(hours=1),
            "engagement": timedelta(hours=4),
            "flow": timedelta(hours=12),
        }

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Check if data is approaching staleness threshold"""
        entity_info = context.get("entity_info")
        last_update = context.get("last_update")

        if not entity_info or not last_update:
            return False

        threshold = self.staleness_thresholds.get(
            entity_info.entity_type, timedelta(hours=24)
        )

        age = datetime.utcnow() - last_update
        return age > threshold * 0.8  # Check when 80% of threshold is reached

    def get_priority(self, context: Dict[str, Any]) -> Priority:
        """Get priority based on data age"""
        entity_info = context.get("entity_info")
        last_update = context.get("last_update")

        if not entity_info or not last_update:
            return Priority.MEDIUM

        threshold = self.staleness_thresholds.get(
            entity_info.entity_type, timedelta(hours=24)
        )

        age = datetime.utcnow() - last_update

        if age > threshold * 2:
            return Priority.CRITICAL
        elif age > threshold:
            return Priority.HIGH
        elif age > threshold * 0.8:
            return Priority.MEDIUM
        else:
            return Priority.LOW

    def get_risk_level(self, context: Dict[str, Any]) -> RiskLevel:
        """Get risk level based on data age"""
        priority = self.get_priority(context)

        risk_mapping = {
            Priority.CRITICAL: RiskLevel.HIGH,
            Priority.HIGH: RiskLevel.MEDIUM,
            Priority.MEDIUM: RiskLevel.MEDIUM,
            Priority.LOW: RiskLevel.LOW,
        }

        return risk_mapping.get(priority, RiskLevel.MEDIUM)


class BusinessHoursPolicy(ConsistencyPolicy):
    """Policy that considers business hours for scheduling"""

    def __init__(self):
        super().__init__(
            "business_hours_scheduling",
            "Adjusts consistency check scheduling based on business hours",
        )
        self.business_start_hour = 8
        self.business_end_hour = 18
        self.timezone_offset = 0  # UTC offset for business hours

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Check if current time is within business hours"""
        now = datetime.utcnow()
        current_hour = now.hour + self.timezone_offset

        return self.business_start_hour <= current_hour < self.business_end_hour

    def get_priority(self, context: Dict[str, Any]) -> Priority:
        """Adjust priority based on business hours"""
        base_priority = context.get("base_priority", Priority.MEDIUM)

        if self.evaluate(context):
            # During business hours, be more conservative
            if base_priority == Priority.LOW:
                return Priority.DEFERRED
            else:
                return base_priority
        else:
            # Outside business hours, can be more aggressive
            if base_priority == Priority.DEFERRED:
                return Priority.LOW
            else:
                return base_priority


class InconsistencyPatternPolicy(ConsistencyPolicy):
    """Policy based on historical inconsistency patterns"""

    def __init__(self):
        super().__init__(
            "inconsistency_pattern_priority",
            "Prioritizes checks based on historical inconsistency patterns",
        )
        self.problematic_keys: Set[str] = set()
        self.pattern_history: Dict[str, List[datetime]] = {}

    def record_inconsistency(self, cache_key: str) -> None:
        """Record an inconsistency for pattern analysis"""
        self.problematic_keys.add(cache_key)

        if cache_key not in self.pattern_history:
            self.pattern_history[cache_key] = []

        self.pattern_history[cache_key].append(datetime.utcnow())

        # Keep only recent history (last 30 days)
        cutoff = datetime.utcnow() - timedelta(days=30)
        self.pattern_history[cache_key] = [
            dt for dt in self.pattern_history[cache_key] if dt > cutoff
        ]

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Check if key has a history of inconsistencies"""
        cache_key = context.get("cache_key")
        return cache_key in self.problematic_keys

    def get_priority(self, context: Dict[str, Any]) -> Priority:
        """Get priority based on inconsistency history"""
        cache_key = context.get("cache_key")

        if cache_key not in self.pattern_history:
            return Priority.MEDIUM

        recent_inconsistencies = len(self.pattern_history[cache_key])

        if recent_inconsistencies >= 5:
            return Priority.CRITICAL
        elif recent_inconsistencies >= 3:
            return Priority.HIGH
        elif recent_inconsistencies >= 1:
            return Priority.MEDIUM
        else:
            return Priority.LOW

    def get_risk_level(self, context: Dict[str, Any]) -> RiskLevel:
        """Get risk level based on inconsistency pattern"""
        priority = self.get_priority(context)

        risk_mapping = {
            Priority.CRITICAL: RiskLevel.CRITICAL,
            Priority.HIGH: RiskLevel.HIGH,
            Priority.MEDIUM: RiskLevel.MEDIUM,
            Priority.LOW: RiskLevel.LOW,
        }

        return risk_mapping.get(priority, RiskLevel.MEDIUM)


class CompliancePolicy(ConsistencyPolicy):
    """Policy for compliance and regulatory requirements"""

    def __init__(self):
        super().__init__(
            "compliance_requirements",
            "Ensures consistency checks meet compliance requirements",
        )
        self.compliance_entities = {"user", "client", "engagement"}
        self.audit_trail_required = True
        self.max_inconsistency_duration = timedelta(hours=4)

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Check if compliance policies apply"""
        entity_info = context.get("entity_info")
        if not entity_info:
            return False

        return entity_info.entity_type in self.compliance_entities

    def get_priority(self, context: Dict[str, Any]) -> Priority:
        """Compliance-related data gets high priority"""
        if self.evaluate(context):
            return Priority.HIGH
        return Priority.MEDIUM

    def get_risk_level(self, context: Dict[str, Any]) -> RiskLevel:
        """Compliance violations are high risk"""
        if self.evaluate(context):
            inconsistency_age = context.get("inconsistency_age", timedelta(0))
            if inconsistency_age > self.max_inconsistency_duration:
                return RiskLevel.CRITICAL
            else:
                return RiskLevel.HIGH
        return RiskLevel.MEDIUM


class ResourceUtilizationPolicy(ConsistencyPolicy):
    """Policy based on system resource utilization"""

    def __init__(self):
        super().__init__(
            "resource_utilization",
            "Adjusts consistency checking based on system resource usage",
        )
        self.cpu_threshold = 80.0  # Percentage
        self.memory_threshold = 80.0  # Percentage
        self.max_concurrent_checks = 5

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Check if resource usage is within acceptable limits"""
        cpu_usage = context.get("cpu_usage", 0)
        memory_usage = context.get("memory_usage", 0)
        concurrent_checks = context.get("concurrent_checks", 0)

        return (
            cpu_usage < self.cpu_threshold
            and memory_usage < self.memory_threshold
            and concurrent_checks < self.max_concurrent_checks
        )

    def get_priority(self, context: Dict[str, Any]) -> Priority:
        """Adjust priority based on resource usage"""
        base_priority = context.get("base_priority", Priority.MEDIUM)

        if not self.evaluate(context):
            # High resource usage - defer non-critical checks
            if base_priority in [Priority.LOW, Priority.MEDIUM]:
                return Priority.DEFERRED
            else:
                return base_priority
        else:
            return base_priority


# Export all policy classes
__all__ = [
    "Priority",
    "RiskLevel",
    "ConsistencyPolicy",
    "EntityTypePolicy",
    "DataAgePolicy",
    "BusinessHoursPolicy",
    "InconsistencyPatternPolicy",
    "CompliancePolicy",
    "ResourceUtilizationPolicy",
]
