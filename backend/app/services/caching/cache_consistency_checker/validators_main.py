"""
Cache Consistency Main Validators

This module implements the main consistency validation logic:
- Basic consistency checks (existence and TTL)
- Deep consistency checks (full data comparison)
- Checksum-based integrity verification
- Schema validation coordination

ðŸ”’ Security: Safe data comparison without exposing sensitive information
âš¡ Performance: Optimized validation algorithms with minimal database queries
ðŸŽ¯ Coherence: Comprehensive validation coverage for all data types

Generated by CC (Claude Code)
"""

import time
from typing import Callable, Optional

from app.core.logging import get_logger
from app.services.caching.redis_cache import RedisCache

from .base import (
    ConsistencyCheckResult,
    ConsistencyCheckType,
    ConsistencyStatus,
    RepairAction,
    calculate_confidence_score,
)
from .exceptions import ConsistencyCheckError, ConsistencyValidationError
from .validator_utils import CacheKeyParser, DataComparator, SchemaValidator

logger = get_logger(__name__)


class ConsistencyValidator:
    """Main validator class for consistency checks"""

    def __init__(self, redis_cache: RedisCache):
        self.redis_cache = redis_cache
        self.key_parser = CacheKeyParser()
        self.data_comparator = DataComparator()
        self.schema_validator = SchemaValidator()

    async def check_basic_consistency(
        self, cache_key: str, client_account_id: Optional[str]
    ) -> ConsistencyCheckResult:
        """Perform basic consistency check (existence and TTL)"""
        start_time = time.time()

        try:
            # Check if cache entry exists
            cache_value = await self.redis_cache.get(cache_key)
            execution_time = (time.time() - start_time) * 1000

            if cache_value is None:
                return ConsistencyCheckResult(
                    cache_key=cache_key,
                    status=ConsistencyStatus.MISSING,
                    check_type=ConsistencyCheckType.BASIC,
                    details="Cache entry not found",
                    suggested_repair=RepairAction.REFRESH_FROM_DB,
                    confidence=0.9,
                    execution_time_ms=execution_time,
                )

            # Check TTL
            ttl = await self.redis_cache.get_ttl(cache_key)
            if ttl == 0:  # Key exists but has no TTL
                return ConsistencyCheckResult(
                    cache_key=cache_key,
                    cache_value=cache_value,
                    status=ConsistencyStatus.STALE,
                    check_type=ConsistencyCheckType.BASIC,
                    details="Cache entry has no TTL set",
                    suggested_repair=RepairAction.REFRESH_FROM_DB,
                    confidence=0.7,
                    execution_time_ms=execution_time,
                )

            # Basic consistency passed
            return ConsistencyCheckResult(
                cache_key=cache_key,
                cache_value=cache_value,
                status=ConsistencyStatus.CONSISTENT,
                check_type=ConsistencyCheckType.BASIC,
                details="Basic consistency check passed",
                confidence=0.8,
                execution_time_ms=execution_time,
            )

        except Exception as e:
            execution_time = (time.time() - start_time) * 1000
            logger.error(f"Basic consistency check failed for {cache_key}: {e}")
            raise ConsistencyCheckError(
                f"Basic consistency check failed: {e}",
                cache_key=cache_key,
                check_type="basic",
            )

    async def check_deep_consistency(
        self,
        cache_key: str,
        client_account_id: Optional[str],
        database_value_getter: Callable,
    ) -> ConsistencyCheckResult:
        """Perform deep consistency check (full data comparison)"""
        start_time = time.time()

        try:
            # Get cache data
            cache_value = await self.redis_cache.get(cache_key)

            if cache_value is None:
                execution_time = (time.time() - start_time) * 1000
                return ConsistencyCheckResult(
                    cache_key=cache_key,
                    status=ConsistencyStatus.MISSING,
                    check_type=ConsistencyCheckType.DEEP,
                    details="Cache entry missing",
                    suggested_repair=RepairAction.REFRESH_FROM_DB,
                    confidence=0.9,
                    execution_time_ms=execution_time,
                )

            # Parse cache key for entity info
            entity_info = self.key_parser.parse_cache_key(cache_key)
            if not entity_info or not entity_info.is_valid:
                execution_time = (time.time() - start_time) * 1000
                return ConsistencyCheckResult(
                    cache_key=cache_key,
                    cache_value=cache_value,
                    status=ConsistencyStatus.CORRUPTED,
                    check_type=ConsistencyCheckType.DEEP,
                    details="Invalid cache key format",
                    suggested_repair=RepairAction.QUARANTINE,
                    confidence=0.8,
                    execution_time_ms=execution_time,
                )

            # Get database value
            db_value = await database_value_getter(entity_info, client_account_id)

            if db_value is None:
                execution_time = (time.time() - start_time) * 1000
                return ConsistencyCheckResult(
                    cache_key=cache_key,
                    cache_value=cache_value,
                    status=ConsistencyStatus.ORPHANED,
                    check_type=ConsistencyCheckType.DEEP,
                    details="No corresponding database record",
                    suggested_repair=RepairAction.DELETE_ORPHANED,
                    confidence=0.8,
                    execution_time_ms=execution_time,
                )

            # Compare data
            is_consistent = self.data_comparator.compare_data(cache_value, db_value)
            execution_time = (time.time() - start_time) * 1000

            if is_consistent:
                return ConsistencyCheckResult(
                    cache_key=cache_key,
                    cache_value=cache_value,
                    status=ConsistencyStatus.CONSISTENT,
                    check_type=ConsistencyCheckType.DEEP,
                    details="Cache and database data match",
                    confidence=0.95,
                    execution_time_ms=execution_time,
                )
            else:
                return ConsistencyCheckResult(
                    cache_key=cache_key,
                    cache_value=cache_value,
                    status=ConsistencyStatus.INCONSISTENT,
                    check_type=ConsistencyCheckType.DEEP,
                    details="Cache and database data differ",
                    suggested_repair=RepairAction.REFRESH_FROM_DB,
                    confidence=0.9,
                    execution_time_ms=execution_time,
                )

        except Exception as e:
            execution_time = (time.time() - start_time) * 1000
            logger.error(f"Deep consistency check failed for {cache_key}: {e}")
            raise ConsistencyCheckError(
                f"Deep consistency check failed: {e}",
                cache_key=cache_key,
                check_type="deep",
            )

    async def check_checksum_consistency(
        self,
        cache_key: str,
        client_account_id: Optional[str],
        database_value_getter: Callable,
    ) -> ConsistencyCheckResult:
        """Perform checksum-based consistency check"""
        start_time = time.time()

        try:
            # Get cache data
            cache_value = await self.redis_cache.get(cache_key)
            if cache_value is None:
                execution_time = (time.time() - start_time) * 1000
                return ConsistencyCheckResult(
                    cache_key=cache_key,
                    status=ConsistencyStatus.MISSING,
                    check_type=ConsistencyCheckType.CHECKSUM,
                    details="Cache entry missing",
                    suggested_repair=RepairAction.REFRESH_FROM_DB,
                    confidence=0.9,
                    execution_time_ms=execution_time,
                )

            # Calculate cache data checksum
            cache_checksum = self.data_comparator.calculate_checksum(cache_value)

            # Get expected checksum from metadata or calculate from database
            entity_info = self.key_parser.parse_cache_key(cache_key)
            if entity_info and entity_info.is_valid:
                db_value = await database_value_getter(entity_info, client_account_id)
                if db_value is not None:
                    expected_checksum = self.data_comparator.calculate_checksum(
                        db_value
                    )

                    execution_time = (time.time() - start_time) * 1000

                    if cache_checksum == expected_checksum:
                        return ConsistencyCheckResult(
                            cache_key=cache_key,
                            cache_value=cache_value,
                            status=ConsistencyStatus.CONSISTENT,
                            check_type=ConsistencyCheckType.CHECKSUM,
                            details="Checksums match",
                            confidence=calculate_confidence_score(
                                ConsistencyCheckType.CHECKSUM, True, 1.0
                            ),
                            execution_time_ms=execution_time,
                        )
                    else:
                        return ConsistencyCheckResult(
                            cache_key=cache_key,
                            cache_value=cache_value,
                            status=ConsistencyStatus.INCONSISTENT,
                            check_type=ConsistencyCheckType.CHECKSUM,
                            details=f"Checksum mismatch: {cache_checksum} != {expected_checksum}",
                            suggested_repair=RepairAction.REFRESH_FROM_DB,
                            confidence=calculate_confidence_score(
                                ConsistencyCheckType.CHECKSUM, True, 0.9
                            ),
                            execution_time_ms=execution_time,
                        )

            execution_time = (time.time() - start_time) * 1000
            return ConsistencyCheckResult(
                cache_key=cache_key,
                cache_value=cache_value,
                status=ConsistencyStatus.CONSISTENT,
                check_type=ConsistencyCheckType.CHECKSUM,
                details="No database reference for checksum comparison",
                confidence=0.5,
                execution_time_ms=execution_time,
            )

        except Exception as e:
            execution_time = (time.time() - start_time) * 1000
            logger.error(f"Checksum consistency check failed for {cache_key}: {e}")
            raise ConsistencyCheckError(
                f"Checksum consistency check failed: {e}",
                cache_key=cache_key,
                check_type="checksum",
            )

    async def check_schema_consistency(
        self, cache_key: str, client_account_id: Optional[str]
    ) -> ConsistencyCheckResult:
        """Perform schema validation consistency check"""
        start_time = time.time()

        try:
            # Get cache data
            cache_value = await self.redis_cache.get(cache_key)
            execution_time = (time.time() - start_time) * 1000

            if cache_value is None:
                return ConsistencyCheckResult(
                    cache_key=cache_key,
                    status=ConsistencyStatus.MISSING,
                    check_type=ConsistencyCheckType.SCHEMA_VALIDATION,
                    details="Cache entry missing",
                    suggested_repair=RepairAction.REFRESH_FROM_DB,
                    confidence=0.9,
                    execution_time_ms=execution_time,
                )

            # Validate schema
            validation_result = self.schema_validator.validate_cache_data_schema(
                cache_key, cache_value
            )

            if validation_result["valid"]:
                return ConsistencyCheckResult(
                    cache_key=cache_key,
                    cache_value=cache_value,
                    status=ConsistencyStatus.CONSISTENT,
                    check_type=ConsistencyCheckType.SCHEMA_VALIDATION,
                    details="Schema validation passed",
                    confidence=0.8,
                    execution_time_ms=execution_time,
                )
            else:
                return ConsistencyCheckResult(
                    cache_key=cache_key,
                    cache_value=cache_value,
                    status=ConsistencyStatus.CORRUPTED,
                    check_type=ConsistencyCheckType.SCHEMA_VALIDATION,
                    details=f"Schema validation failed: {validation_result['errors']}",
                    suggested_repair=RepairAction.QUARANTINE,
                    confidence=0.7,
                    execution_time_ms=execution_time,
                )

        except Exception as e:
            execution_time = (time.time() - start_time) * 1000
            logger.error(f"Schema consistency check failed for {cache_key}: {e}")
            raise ConsistencyValidationError(
                f"Schema validation failed: {e}",
                cache_key=cache_key,
                validation_type="schema",
                validation_errors=[str(e)],
            )


# Export main validator class
__all__ = [
    "ConsistencyValidator",
]
