"""
Cache Consistency Synchronizers

This module implements data synchronization operations for cache consistency:
- Database value extraction for different entity types
- Cache-database synchronization utilities
- Multi-tenant data isolation handling
- Session management for database operations

ðŸ”’ Security: Multi-tenant isolation and secure database access
âš¡ Performance: Optimized database queries with connection pooling
ðŸŽ¯ Coherence: Comprehensive entity data extraction and synchronization

Generated by CC (Claude Code)
"""

from typing import Any, Dict, List, Optional

from sqlalchemy import and_, select
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.logging import get_logger
from app.models.cache_metadata import CacheMetadata

from .base import EntityInfo
from .exceptions import ConsistencyCheckError

logger = get_logger(__name__)


class DatabaseSessionManager:
    """Manages database sessions for consistency checking operations"""

    def __init__(self, db_session: Optional[AsyncSession] = None):
        self.db_session = db_session

    async def get_session(self) -> AsyncSession:
        """Get database session with proper resource management"""
        if self.db_session is not None:
            return self.db_session

        # Create on-demand session with proper cleanup
        from app.core.database import AsyncSessionLocal

        return AsyncSessionLocal()

    async def close_session_if_created(self, session: AsyncSession) -> None:
        """Close session if it was created on-demand"""
        if session is not None and self.db_session is None:
            await session.close()


class EntityDataExtractor:
    """Extracts entity data from database for consistency checking"""

    def __init__(self, session_manager: DatabaseSessionManager):
        self.session_manager = session_manager

    async def extract_user_data(
        self, user_id: str, client_account_id: Optional[str]
    ) -> Optional[Dict[str, Any]]:
        """Extract user data from database"""
        session = None
        try:
            from app.models.user import User

            session = await self.session_manager.get_session()
            stmt = select(User).where(User.id == user_id)

            # Add client account filtering if specified
            if client_account_id:
                stmt = stmt.where(
                    getattr(User, "client_account_id", None) == client_account_id
                )

            result = await session.execute(stmt)
            user = result.scalar_one_or_none()

            if not user:
                return None

            return {
                "id": str(user.id),
                "email": user.email,
                "full_name": user.full_name,
                "is_active": user.is_active,
                "role": getattr(user, "role", None),
                "client_account_id": getattr(user, "client_account_id", None),
                "created_at": getattr(user, "created_at", None),
                "updated_at": getattr(user, "updated_at", None),
            }
        except Exception as e:
            logger.error(f"Failed to extract user data for {user_id}: {e}")
            return None
        finally:
            await self.session_manager.close_session_if_created(session)

    async def extract_client_data(
        self, client_id: str, client_account_id: Optional[str]
    ) -> Optional[Dict[str, Any]]:
        """Extract client data from database"""
        session = None
        try:
            from app.models.client_account import ClientAccount

            session = await self.session_manager.get_session()
            stmt = select(ClientAccount).where(ClientAccount.id == client_id)

            # Multi-tenant isolation - ensure client belongs to account
            if client_account_id:
                stmt = stmt.where(ClientAccount.id == client_account_id)

            result = await session.execute(stmt)
            client = result.scalar_one_or_none()

            if not client:
                return None

            return {
                "id": str(client.id),
                "name": client.name,
                "is_active": client.is_active,
                "settings": getattr(client, "settings", {}),
                "created_at": getattr(client, "created_at", None),
                "updated_at": getattr(client, "updated_at", None),
            }
        except Exception as e:
            logger.error(f"Failed to extract client data for {client_id}: {e}")
            return None
        finally:
            await self.session_manager.close_session_if_created(session)

    async def extract_engagement_data(
        self, engagement_id: str, client_account_id: Optional[str]
    ) -> Optional[Dict[str, Any]]:
        """Extract engagement data from database"""
        session = None
        try:
            from app.models.engagement import Engagement

            session = await self.session_manager.get_session()
            stmt = select(Engagement).where(Engagement.id == engagement_id)

            # Multi-tenant isolation
            if client_account_id:
                stmt = stmt.where(
                    getattr(Engagement, "client_account_id", None) == client_account_id
                )

            result = await session.execute(stmt)
            engagement = result.scalar_one_or_none()

            if not engagement:
                return None

            return {
                "id": str(engagement.id),
                "name": engagement.name,
                "status": getattr(engagement, "status", None),
                "is_active": getattr(engagement, "is_active", True),
                "client_account_id": getattr(engagement, "client_account_id", None),
                "metadata": getattr(engagement, "metadata", {}),
                "created_at": getattr(engagement, "created_at", None),
                "updated_at": getattr(engagement, "updated_at", None),
            }
        except Exception as e:
            logger.error(f"Failed to extract engagement data for {engagement_id}: {e}")
            return None
        finally:
            await self.session_manager.close_session_if_created(session)

    async def extract_flow_data(
        self, flow_id: str, client_account_id: Optional[str]
    ) -> Optional[Dict[str, Any]]:
        """Extract flow data from database"""
        session = None
        try:
            # Import flow models - these may vary based on implementation
            try:
                from app.models.crewai_flow_state_extensions import (
                    CrewAIFlowStateExtensions,
                )
                from app.models.discovery_flow import DiscoveryFlow

                session = await self.session_manager.get_session()

                # Try to get from master table first
                stmt = select(CrewAIFlowStateExtensions).where(
                    CrewAIFlowStateExtensions.flow_id == flow_id
                )

                if client_account_id:
                    stmt = stmt.where(
                        CrewAIFlowStateExtensions.client_account_id == client_account_id
                    )

                result = await session.execute(stmt)
                flow_state = result.scalar_one_or_none()

                if flow_state:
                    # Get detailed flow data
                    detail_stmt = select(DiscoveryFlow).where(
                        DiscoveryFlow.flow_id == flow_id
                    )
                    detail_result = await session.execute(detail_stmt)
                    flow_detail = detail_result.scalar_one_or_none()

                    return {
                        "flow_id": str(flow_state.flow_id),
                        "state": getattr(flow_state, "state", None),
                        "client_account_id": getattr(
                            flow_state, "client_account_id", None
                        ),
                        "engagement_id": getattr(flow_state, "engagement_id", None),
                        "flow_type": (
                            getattr(flow_detail, "flow_type", None)
                            if flow_detail
                            else None
                        ),
                        "status": (
                            getattr(flow_detail, "status", None)
                            if flow_detail
                            else None
                        ),
                        "metadata": getattr(flow_state, "metadata", {}),
                        "created_at": getattr(flow_state, "created_at", None),
                        "updated_at": getattr(flow_state, "updated_at", None),
                    }

            except ImportError:
                logger.warning(
                    "Flow models not available - skipping flow data extraction"
                )
                return None

            return None

        except Exception as e:
            logger.error(f"Failed to extract flow data for {flow_id}: {e}")
            return None
        finally:
            await self.session_manager.close_session_if_created(session)


class CacheMetadataRetriever:
    """Retrieves cache metadata for consistency operations"""

    def __init__(self, session_manager: DatabaseSessionManager):
        self.session_manager = session_manager

    async def get_all_cache_keys(
        self, client_account_id: Optional[str] = None
    ) -> List[str]:
        """Get all cache keys for consistency checking"""
        session = None
        try:
            session = await self.session_manager.get_session()

            # Build query with optional client filtering
            stmt = (
                select(CacheMetadata.cache_key)
                .where(
                    and_(
                        CacheMetadata.is_active == True,  # noqa: E712
                        (
                            CacheMetadata.client_account_id == client_account_id
                            if client_account_id
                            else True
                        ),
                    )
                )
                .limit(1000)  # Limit for performance
            )

            result = await session.execute(stmt)
            cache_keys = [row[0] for row in result.fetchall()]

            logger.debug(
                f"Retrieved {len(cache_keys)} cache keys for consistency checking"
            )
            return cache_keys

        except Exception as e:
            logger.error(f"Failed to get cache keys: {e}")
            return []
        finally:
            await self.session_manager.close_session_if_created(session)

    async def get_cache_metadata(self, cache_key: str) -> Optional[Dict[str, Any]]:
        """Get metadata for specific cache key"""
        session = None
        try:
            session = await self.session_manager.get_session()

            stmt = select(CacheMetadata).where(CacheMetadata.cache_key == cache_key)
            result = await session.execute(stmt)
            metadata = result.scalar_one_or_none()

            if not metadata:
                return None

            return {
                "cache_key": metadata.cache_key,
                "entity_type": getattr(metadata, "entity_type", None),
                "entity_id": getattr(metadata, "entity_id", None),
                "client_account_id": getattr(metadata, "client_account_id", None),
                "created_at": getattr(metadata, "created_at", None),
                "updated_at": getattr(metadata, "updated_at", None),
                "ttl": getattr(metadata, "ttl", None),
                "is_active": metadata.is_active,
            }

        except Exception as e:
            logger.error(f"Failed to get cache metadata for {cache_key}: {e}")
            return None
        finally:
            await self.session_manager.close_session_if_created(session)


class DataSynchronizer:
    """Main synchronizer class for cache-database operations"""

    def __init__(self, db_session: Optional[AsyncSession] = None):
        self.session_manager = DatabaseSessionManager(db_session)
        self.entity_extractor = EntityDataExtractor(self.session_manager)
        self.metadata_retriever = CacheMetadataRetriever(self.session_manager)

        # Data extractors for different entity types
        self.data_extractors = {
            "user": self.entity_extractor.extract_user_data,
            "client": self.entity_extractor.extract_client_data,
            "engagement": self.entity_extractor.extract_engagement_data,
            "flow": self.entity_extractor.extract_flow_data,
        }

    async def get_database_value(
        self, entity_info: EntityInfo, client_account_id: Optional[str]
    ) -> Optional[Any]:
        """Get corresponding value from database for given entity"""
        if not entity_info or not entity_info.is_valid:
            return None

        entity_type = entity_info.entity_type
        entity_id = entity_info.entity_id

        extractor = self.data_extractors.get(entity_type)
        if not extractor:
            logger.warning(
                f"No data extractor available for entity type: {entity_type}"
            )
            return None

        try:
            return await extractor(entity_id, client_account_id)
        except Exception as e:
            logger.error(
                f"Failed to extract database value for {entity_type}:{entity_id}: {e}"
            )
            raise ConsistencyCheckError(
                f"Database value extraction failed: {e}",
                details={
                    "entity_type": entity_type,
                    "entity_id": entity_id,
                    "client_account_id": client_account_id,
                },
            )

    async def get_all_cache_keys(
        self, client_account_id: Optional[str] = None
    ) -> List[str]:
        """Get all cache keys for consistency checking"""
        return await self.metadata_retriever.get_all_cache_keys(client_account_id)

    async def get_cache_metadata(self, cache_key: str) -> Optional[Dict[str, Any]]:
        """Get metadata for specific cache key"""
        return await self.metadata_retriever.get_cache_metadata(cache_key)

    async def validate_multi_tenant_access(
        self, entity_info: EntityInfo, client_account_id: Optional[str]
    ) -> bool:
        """Validate that entity access respects multi-tenant isolation"""
        if not client_account_id:
            # No tenant restriction - allow access
            return True

        try:
            # Get entity data and check client_account_id
            db_value = await self.get_database_value(entity_info, client_account_id)

            if db_value is None:
                # Entity doesn't exist or no access
                return False

            # Check if entity belongs to the specified client account
            entity_client_id = db_value.get("client_account_id")
            if entity_client_id and entity_client_id != client_account_id:
                logger.warning(
                    f"Multi-tenant access violation: entity {entity_info.entity_type}:"
                    f"{entity_info.entity_id} belongs to {entity_client_id}, "
                    f"not {client_account_id}"
                )
                return False

            return True

        except Exception as e:
            logger.error(f"Multi-tenant validation failed: {e}")
            return False

    async def sync_cache_from_database(
        self, entity_info: EntityInfo, client_account_id: Optional[str]
    ) -> Optional[Any]:
        """Synchronize cache data from database source"""
        try:
            # Validate multi-tenant access
            if not await self.validate_multi_tenant_access(
                entity_info, client_account_id
            ):
                logger.warning(
                    f"Multi-tenant access denied for {entity_info.entity_type}:{entity_info.entity_id}"
                )
                return None

            # Get fresh data from database
            db_value = await self.get_database_value(entity_info, client_account_id)

            if db_value is None:
                logger.info(
                    f"No database data found for {entity_info.entity_type}:{entity_info.entity_id}"
                )

            return db_value

        except Exception as e:
            logger.error(
                f"Cache synchronization failed for {entity_info.entity_type}:{entity_info.entity_id}: {e}"
            )
            raise ConsistencyCheckError(
                f"Cache synchronization failed: {e}",
                details={
                    "entity_type": entity_info.entity_type,
                    "entity_id": entity_info.entity_id,
                    "client_account_id": client_account_id,
                },
            )


# Export all synchronizer classes
__all__ = [
    "DatabaseSessionManager",
    "EntityDataExtractor",
    "CacheMetadataRetriever",
    "DataSynchronizer",
]
