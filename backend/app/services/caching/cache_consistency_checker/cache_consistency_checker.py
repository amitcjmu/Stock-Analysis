"""
Cache Consistency Checker - Main Orchestrator

This module provides the main CacheConsistencyChecker class that orchestrates
all the modularized components for comprehensive cache consistency verification
and repair operations.

Features:
- Multiple consistency check types (basic, deep, checksum, schema)
- Automatic inconsistency detection and repair
- Scheduled consistency audits
- Performance impact monitoring
- Comprehensive metrics and reporting
- Multi-tenant isolation and security

ðŸ”’ Security: Multi-tenant isolation and secure consistency verification
âš¡ Performance: Optimized consistency checks with minimal database queries
ðŸŽ¯ Coherence: Comprehensive data integrity verification and repair
ðŸ“Š Analytics: Detailed consistency metrics and audit trails

Generated by CC (Claude Code)
"""

from typing import Any, Dict, List, Optional

from sqlalchemy.ext.asyncio import AsyncSession

from app.core.config import settings
from app.core.logging import get_logger
from app.services.caching.redis_cache import RedisCache

from .base import (
    ConsistencyAuditReport,
    ConsistencyCheckResult,
    ConsistencyCheckType,
    ConsistencyConfiguration,
    create_default_configuration,
)
from .conflict_resolvers import ConflictResolver
from .monitors import ConsistencyMonitor
from .policy_engine import PolicyEngine
from .recovery import ScheduledAuditManager
from .synchronizers import DataSynchronizer
from .validators import ConsistencyValidator

logger = get_logger(__name__)


class CacheConsistencyChecker:
    """
    Comprehensive cache consistency checker that verifies and repairs
    cache-database consistency across the auth performance system.

    This class orchestrates all the modularized components to provide
    a unified interface for cache consistency operations.
    """

    def __init__(
        self,
        redis_cache: RedisCache,
        db_session: Optional[AsyncSession] = None,
        config: Optional[ConsistencyConfiguration] = None,
    ):
        self.redis_cache = redis_cache
        self.db_session = db_session
        self.config = config or self._create_config_from_settings()

        # Initialize core components
        self.data_synchronizer = DataSynchronizer(db_session)
        self.validator = ConsistencyValidator(redis_cache)
        self.monitor = ConsistencyMonitor(self.config.max_recent_results)
        self.policy_engine = PolicyEngine(self.config)
        self.conflict_resolver = ConflictResolver(
            redis_cache,
            self.data_synchronizer,
            max_retry_attempts=self.config.repair_retry_attempts,
            retry_delay_seconds=self.config.repair_retry_delay_seconds,
        )
        self.audit_manager = ScheduledAuditManager(
            redis_cache, self.data_synchronizer, self.monitor, self.config
        )

        logger.info("CacheConsistencyChecker initialized with modularized components")

    def _create_config_from_settings(self) -> ConsistencyConfiguration:
        """Create configuration from application settings"""
        return create_default_configuration(
            batch_size=settings.get("CACHE_CONSISTENCY_BATCH_SIZE", 100),
            max_concurrent_checks=settings.get("CACHE_CONSISTENCY_MAX_CONCURRENT", 5),
            default_check_interval_hours=settings.get(
                "CACHE_CONSISTENCY_CHECK_INTERVAL", 24
            ),
            performance_impact_threshold=settings.get(
                "CACHE_CONSISTENCY_PERFORMANCE_THRESHOLD", 0.1
            ),
            enable_quarantine=settings.get("CACHE_CONSISTENCY_ENABLE_QUARANTINE", True),
            quarantine_max_items=settings.get(
                "CACHE_CONSISTENCY_QUARANTINE_MAX", 10000
            ),
        )

    async def start_scheduled_audits(self) -> None:
        """Start scheduled consistency audits"""
        await self.audit_manager.start_scheduled_audits()

    async def stop_scheduled_audits(self) -> None:
        """Stop scheduled consistency audits"""
        await self.audit_manager.stop_scheduled_audits()

    async def check_cache_consistency(
        self,
        cache_key: str,
        check_type: ConsistencyCheckType = ConsistencyCheckType.BASIC,
        client_account_id: Optional[str] = None,
    ) -> ConsistencyCheckResult:
        """
        Check consistency of a single cache key.

        Args:
            cache_key: Cache key to check
            check_type: Type of consistency check to perform
            client_account_id: Client account for multi-tenant isolation

        Returns:
            ConsistencyCheckResult with details
        """
        try:
            # Create context for policy evaluation
            context = {
                "cache_key": cache_key,
                "client_account_id": client_account_id,
                "check_type": check_type,
            }

            # Check if this check should be deferred by policy
            if self.policy_engine.should_defer_check(context):
                result = ConsistencyCheckResult(
                    cache_key=cache_key,
                    status=self.monitor.metrics.status_distribution.get(
                        self.monitor.metrics.status_distribution.keys()
                        .__iter__()
                        .__next__(),
                        "consistent",
                    ),
                    check_type=check_type,
                    details="Check deferred by policy",
                    confidence=0.5,
                )
            else:
                # Determine appropriate check type based on policies
                policy_check_type = self.policy_engine.determine_check_type(context)
                actual_check_type = (
                    policy_check_type if policy_check_type != check_type else check_type
                )

                # Perform the consistency check using the validator
                if actual_check_type == ConsistencyCheckType.BASIC:
                    result = await self.validator.check_basic_consistency(
                        cache_key, client_account_id
                    )
                elif actual_check_type == ConsistencyCheckType.DEEP:
                    result = await self.validator.check_deep_consistency(
                        cache_key,
                        client_account_id,
                        self.data_synchronizer.get_database_value,
                    )
                elif actual_check_type == ConsistencyCheckType.CHECKSUM:
                    result = await self.validator.check_checksum_consistency(
                        cache_key,
                        client_account_id,
                        self.data_synchronizer.get_database_value,
                    )
                elif actual_check_type == ConsistencyCheckType.SCHEMA_VALIDATION:
                    result = await self.validator.check_schema_consistency(
                        cache_key, client_account_id
                    )
                else:
                    result = await self.validator.check_basic_consistency(
                        cache_key, client_account_id
                    )

            # Record the result in the monitor
            self.monitor.record_check_result(result)

            # Record inconsistency patterns for policy learning
            if result.needs_repair:
                self.policy_engine.record_inconsistency_pattern(cache_key)

            return result

        except Exception as e:
            logger.error(f"Consistency check failed for {cache_key}: {e}")
            # Create error result
            error_result = ConsistencyCheckResult(
                cache_key=cache_key,
                status="corrupted",
                check_type=check_type,
                details=f"Check failed: {e}",
                confidence=0.0,
            )
            self.monitor.record_check_result(error_result)
            return error_result

    async def check_bulk_consistency(
        self,
        cache_keys: List[str],
        check_type: ConsistencyCheckType = ConsistencyCheckType.BASIC,
        client_account_id: Optional[str] = None,
    ) -> List[ConsistencyCheckResult]:
        """Check consistency of multiple cache keys in batches"""
        return await self.audit_manager.bulk_checker.check_bulk_consistency(
            cache_keys,
            check_type,
            client_account_id,
            self.data_synchronizer.get_database_value,
        )

    async def run_full_consistency_audit(
        self,
        client_account_id: Optional[str] = None,
        check_type: ConsistencyCheckType = ConsistencyCheckType.DEEP,
    ) -> ConsistencyAuditReport:
        """
        Run comprehensive consistency audit across all cache entries.

        Args:
            client_account_id: Specific client to audit (None for platform-wide)
            check_type: Type of consistency check to perform

        Returns:
            ConsistencyAuditReport with comprehensive results
        """
        return await self.audit_manager.run_full_consistency_audit(
            client_account_id, check_type
        )

    async def repair_inconsistency(self, result: ConsistencyCheckResult) -> bool:
        """
        Repair a single inconsistency.

        Args:
            result: ConsistencyCheckResult indicating the inconsistency

        Returns:
            True if repair was successful
        """
        return await self.conflict_resolver.resolve_inconsistency(result)

    def get_consistency_metrics(self) -> Dict[str, Any]:
        """Get comprehensive consistency metrics"""
        base_metrics = self.monitor.get_comprehensive_metrics()

        # Add quarantine information
        quarantine_summary = self.conflict_resolver.get_quarantine_summary()
        base_metrics["quarantined_items"] = quarantine_summary.get("total_items", 0)
        base_metrics["quarantine_summary"] = quarantine_summary

        # Add policy information
        base_metrics["policy_summary"] = self.policy_engine.get_policy_summary()

        # Add audit information
        base_metrics["audit_history_count"] = len(
            self.audit_manager.get_audit_history()
        )
        base_metrics["scheduled_audits_running"] = self.audit_manager.is_audit_running()

        return base_metrics

    def reset_metrics(self) -> None:
        """Reset consistency metrics"""
        self.monitor.reset_metrics()
        logger.info("Consistency metrics reset")

    async def health_check(self) -> Dict[str, Any]:
        """Perform health check on consistency checker"""
        quarantine_count = self.conflict_resolver.get_quarantine_summary().get(
            "total_items", 0
        )
        scheduled_audits_running = self.audit_manager.is_audit_running()

        health = await self.monitor.get_health_status(
            quarantine_count, scheduled_audits_running
        )

        # Add component-specific health information
        health["components"] = {
            "validator": {"status": "healthy"},
            "synchronizer": {"status": "healthy"},
            "conflict_resolver": {
                "status": "healthy",
                "quarantined_items": quarantine_count,
            },
            "monitor": {
                "status": "healthy",
                "total_checks": self.monitor.metrics.total_checks,
            },
            "policy_engine": {
                "status": "healthy",
                "enabled_policies": self.policy_engine.get_policy_summary()[
                    "enabled_policies"
                ],
            },
            "audit_manager": {
                "status": "healthy" if scheduled_audits_running else "degraded",
                "scheduled_audits_running": scheduled_audits_running,
            },
        }

        return health

    def get_audit_history(self, limit: int = 10) -> List[ConsistencyAuditReport]:
        """Get recent audit history"""
        return self.audit_manager.get_audit_history(limit)

    def get_audit_trends(self) -> Dict[str, Any]:
        """Get audit trend analysis"""
        return self.audit_manager.get_audit_trends()

    def cleanup_quarantine(self, retention_days: int = 7) -> int:
        """Remove expired quarantine entries"""
        return self.conflict_resolver.cleanup_quarantine(retention_days)

    def get_policy_summary(self) -> Dict[str, Any]:
        """Get policy configuration summary"""
        return self.policy_engine.get_policy_summary()

    def enable_policy(self, policy_name: str) -> bool:
        """Enable a specific policy"""
        return self.policy_engine.enable_policy(policy_name)

    def disable_policy(self, policy_name: str) -> bool:
        """Disable a specific policy"""
        return self.policy_engine.disable_policy(policy_name)

    # Legacy method compatibility
    async def _get_all_cache_keys(self, client_account_id: Optional[str]) -> List[str]:
        """Legacy method for backward compatibility"""
        return await self.data_synchronizer.get_all_cache_keys(client_account_id)

    async def _repair_inconsistencies(
        self, results: List[ConsistencyCheckResult]
    ) -> List[bool]:
        """Legacy method for backward compatibility"""
        return await self.conflict_resolver.resolve_bulk_inconsistencies(results)


# Factory function for dependency injection
async def create_cache_consistency_checker(
    redis_cache: RedisCache,
    db_session: Optional[AsyncSession] = None,
    config: Optional[ConsistencyConfiguration] = None,
) -> CacheConsistencyChecker:
    """Create CacheConsistencyChecker with dependencies"""
    return CacheConsistencyChecker(redis_cache, db_session, config)


# Export main class and factory function
__all__ = [
    "CacheConsistencyChecker",
    "create_cache_consistency_checker",
]
