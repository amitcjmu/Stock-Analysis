"""
Cache Invalidation Strategies Module

This module implements comprehensive cache invalidation strategies including:
- Time-based expiration with strategic refresh windows
- Event-driven invalidation for real-time updates
- Write-through and write-behind patterns
- Cache versioning and data integrity checks
- Adaptive TTL management
- Bulk operations and policy management

These strategies ensure cache consistency while maintaining high performance
and handling complex data dependencies in the auth performance system.

ðŸ”’ Security: Multi-tenant isolation and secure invalidation
âš¡ Performance: Optimized batch operations and minimal overhead
ðŸŽ¯ Coherence: Cascade invalidation with cycle detection
ðŸ“Š Analytics: Comprehensive invalidation tracking and metrics

Generated by CC (Claude Code)
"""

from typing import Optional

from app.services.caching.redis_cache import RedisCache

# Import base classes and data models
from .base import (
    BaseInvalidationStrategy,
    InvalidationEvent,
    InvalidationPriority,
    InvalidationResult,
    InvalidationTrigger,
)

# Import exception classes
from .exceptions import (
    BulkInvalidationError,
    CascadeInvalidationError,
    InvalidationError,
    InvalidationStrategyError,
    InvalidationTimeoutError,
    InvalidationVersionError,
    WritePatternError,
)

# Import strategy implementations
from .adaptive import AdaptiveInvalidationStrategy
from .bulk_operations import BulkInvalidationStrategy
from .dependency_based import (
    CacheVersioningInvalidationStrategy,
    WritePatternInvalidationStrategy,
)
from .event_based import EventDrivenInvalidationStrategy
from .time_based import TimeBasedInvalidationStrategy

# Import policy management
from .policies import (
    InvalidationPolicy,
    InvalidationPolicyManager,
    InvalidationQuota,
    PolicyAction,
    PolicyScope,
    policy_manager,
    quota_manager,
)


def create_invalidation_strategy(
    event: InvalidationEvent, redis_cache: RedisCache
) -> Optional[BaseInvalidationStrategy]:
    """Create the appropriate invalidation strategy for an event"""

    strategies = [
        TimeBasedInvalidationStrategy(redis_cache),
        EventDrivenInvalidationStrategy(redis_cache),
        WritePatternInvalidationStrategy(redis_cache),
        CacheVersioningInvalidationStrategy(redis_cache),
        BulkInvalidationStrategy(redis_cache),
        AdaptiveInvalidationStrategy(redis_cache),
    ]

    for strategy in strategies:
        if strategy.can_handle(event):
            return strategy

    return None


# Export all public classes and functions
__all__ = [
    # Base classes and data models
    "InvalidationTrigger",
    "InvalidationPriority",
    "InvalidationEvent",
    "InvalidationResult",
    "BaseInvalidationStrategy",
    # Exception classes
    "InvalidationError",
    "InvalidationStrategyError",
    "InvalidationVersionError",
    "InvalidationTimeoutError",
    "CascadeInvalidationError",
    "WritePatternError",
    "BulkInvalidationError",
    # Strategy implementations
    "TimeBasedInvalidationStrategy",
    "EventDrivenInvalidationStrategy",
    "WritePatternInvalidationStrategy",
    "CacheVersioningInvalidationStrategy",
    "BulkInvalidationStrategy",
    "AdaptiveInvalidationStrategy",
    # Policy management
    "PolicyScope",
    "PolicyAction",
    "InvalidationPolicy",
    "InvalidationPolicyManager",
    "InvalidationQuota",
    "policy_manager",
    "quota_manager",
    # Factory function
    "create_invalidation_strategy",
]
