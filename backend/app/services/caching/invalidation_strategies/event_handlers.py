"""
Event handler methods for event-driven cache invalidation.

This module contains the specific handler methods for different types
of invalidation events, extracted from the main EventDrivenInvalidationStrategy
to keep file sizes manageable.

Generated by CC (Claude Code)
"""

import time
from typing import List

from app.constants.cache_keys import CacheKeys
from app.core.logging import get_logger

from .base import InvalidationEvent, InvalidationResult, InvalidationTrigger

logger = get_logger(__name__)


class EventHandlerMixin:
    """Mixin class containing event handler methods"""

    async def _handle_user_session_event(
        self, event: InvalidationEvent
    ) -> InvalidationResult:
        """Handle user login/logout events"""
        start_time = time.time()
        keys_invalidated = 0

        # Invalidate user session and context caches
        cache_keys = [
            CacheKeys.user_context(event.entity_id),
            CacheKeys.user_defaults(event.entity_id),
        ]

        # For logout, also invalidate client and engagement caches
        if event.trigger == InvalidationTrigger.USER_LOGOUT:
            cache_keys.extend(
                [
                    CacheKeys.user_clients(event.entity_id),
                ]
            )

            # If we have client context, invalidate engagement-specific caches
            if event.client_account_id:
                cache_keys.append(
                    CacheKeys.user_engagements(event.entity_id, event.client_account_id)
                )

        # Perform cascade invalidation
        keys_invalidated = await self._cascade_invalidate(cache_keys, event, depth=0)

        execution_time = (time.time() - start_time) * 1000

        return InvalidationResult(
            success=True,
            keys_invalidated=keys_invalidated,
            execution_time_ms=execution_time,
            strategy_used=self.get_strategy_name(),
            metadata={"trigger": event.trigger.value, "user_id": event.entity_id},
        )

    async def _handle_user_context_change(
        self, event: InvalidationEvent
    ) -> InvalidationResult:
        """Handle user context changes (client/engagement switches)"""
        start_time = time.time()

        # Invalidate all user context-related caches
        cache_keys = [
            CacheKeys.user_context(event.entity_id),
            CacheKeys.user_clients(event.entity_id),
        ]

        # If specific client context, invalidate engagement caches
        if event.client_account_id:
            cache_keys.append(
                CacheKeys.user_engagements(event.entity_id, event.client_account_id)
            )

        keys_invalidated = await self._cascade_invalidate(cache_keys, event, depth=0)

        execution_time = (time.time() - start_time) * 1000

        return InvalidationResult(
            success=True,
            keys_invalidated=keys_invalidated,
            execution_time_ms=execution_time,
            strategy_used=self.get_strategy_name(),
            metadata={"trigger": "user_context_change", "user_id": event.entity_id},
        )

    async def _handle_user_permission_change(
        self, event: InvalidationEvent
    ) -> InvalidationResult:
        """Handle user role/permission changes"""
        start_time = time.time()

        # Invalidate all user-related caches as permissions affect everything
        cache_keys = [
            CacheKeys.user_context(event.entity_id),
            CacheKeys.user_clients(event.entity_id),
            CacheKeys.user_defaults(event.entity_id),
        ]

        # Also invalidate admin caches that might be affected
        cache_keys.extend(
            [
                CacheKeys.admin_active_users(),
                CacheKeys.admin_pending_approvals(),
            ]
        )

        keys_invalidated = await self._cascade_invalidate(cache_keys, event, depth=0)

        execution_time = (time.time() - start_time) * 1000

        return InvalidationResult(
            success=True,
            keys_invalidated=keys_invalidated,
            execution_time_ms=execution_time,
            strategy_used=self.get_strategy_name(),
            metadata={"trigger": event.trigger.value, "user_id": event.entity_id},
        )

    async def _handle_client_access_change(
        self, event: InvalidationEvent
    ) -> InvalidationResult:
        """Handle client access changes"""
        start_time = time.time()

        # Invalidate client-related caches
        cache_keys = [
            CacheKeys.client_engagements(event.entity_id),
            CacheKeys.client_users(event.entity_id),
            CacheKeys.client_settings(event.entity_id),
        ]

        # If user context available, invalidate user's client list
        if event.user_id:
            cache_keys.append(CacheKeys.user_clients(event.user_id))

        keys_invalidated = await self._cascade_invalidate(cache_keys, event, depth=0)

        execution_time = (time.time() - start_time) * 1000

        return InvalidationResult(
            success=True,
            keys_invalidated=keys_invalidated,
            execution_time_ms=execution_time,
            strategy_used=self.get_strategy_name(),
            metadata={"trigger": "client_access_change", "client_id": event.entity_id},
        )

    async def _handle_engagement_change(
        self, event: InvalidationEvent
    ) -> InvalidationResult:
        """Handle engagement changes"""
        start_time = time.time()

        cache_keys = []

        # Invalidate client's engagement list
        if event.client_account_id:
            cache_keys.append(CacheKeys.client_engagements(event.client_account_id))

        # Invalidate engagement-specific flows
        if event.client_account_id and event.entity_id:
            cache_keys.append(
                CacheKeys.client_flows(event.client_account_id, event.entity_id)
            )

        keys_invalidated = await self._cascade_invalidate(cache_keys, event, depth=0)

        execution_time = (time.time() - start_time) * 1000

        return InvalidationResult(
            success=True,
            keys_invalidated=keys_invalidated,
            execution_time_ms=execution_time,
            strategy_used=self.get_strategy_name(),
            metadata={"trigger": "engagement_change", "engagement_id": event.entity_id},
        )

    async def _handle_data_modification(
        self, event: InvalidationEvent
    ) -> InvalidationResult:
        """Handle general data modification events"""
        start_time = time.time()

        # Generate cache keys based on entity type
        cache_keys = self._generate_data_modification_keys(event)

        keys_invalidated = await self._cascade_invalidate(cache_keys, event, depth=0)

        execution_time = (time.time() - start_time) * 1000

        return InvalidationResult(
            success=True,
            keys_invalidated=keys_invalidated,
            execution_time_ms=execution_time,
            strategy_used=self.get_strategy_name(),
            metadata={"trigger": "data_modification", "entity_type": event.entity_type},
        )

    async def _handle_security_event(
        self, event: InvalidationEvent
    ) -> InvalidationResult:
        """Handle security events - aggressive invalidation"""
        start_time = time.time()

        # For security events, invalidate broadly
        cache_keys = []

        if event.user_id:
            # Invalidate all user-related caches
            cache_keys.extend(
                [
                    CacheKeys.user_context(event.user_id),
                    CacheKeys.user_clients(event.user_id),
                    CacheKeys.user_defaults(event.user_id),
                ]
            )

        if event.client_account_id:
            # Invalidate client-specific caches
            cache_keys.extend(
                [
                    CacheKeys.client_users(event.client_account_id),
                    CacheKeys.client_settings(event.client_account_id),
                ]
            )

        # Always invalidate admin caches for security events
        cache_keys.extend(
            [
                CacheKeys.admin_active_users(),
                CacheKeys.admin_pending_approvals(),
            ]
        )

        keys_invalidated = await self._cascade_invalidate(cache_keys, event, depth=0)

        execution_time = (time.time() - start_time) * 1000

        return InvalidationResult(
            success=True,
            keys_invalidated=keys_invalidated,
            execution_time_ms=execution_time,
            strategy_used=self.get_strategy_name(),
            metadata={
                "trigger": "security_event",
                "severity": event.metadata.get("severity", "unknown"),
            },
        )

    async def _handle_manual_invalidation(
        self, event: InvalidationEvent
    ) -> InvalidationResult:
        """Handle manual invalidation requests"""
        start_time = time.time()

        # Use patterns or specific keys from metadata
        patterns = event.metadata.get("patterns", [])
        specific_keys = event.metadata.get("keys", [])

        keys_invalidated = 0

        # Handle specific keys
        for cache_key in specific_keys:
            try:
                deleted = await self.redis_cache.delete(cache_key)
                if deleted:
                    keys_invalidated += 1
            except Exception as e:
                logger.error(f"Failed to delete cache key {cache_key}: {e}")

        # Handle patterns (would need pattern matching support in Redis)
        for pattern in patterns:
            try:
                # This would require implementing pattern-based deletion
                pattern_keys = await self._find_keys_by_pattern(pattern)
                for key in pattern_keys:
                    deleted = await self.redis_cache.delete(key)
                    if deleted:
                        keys_invalidated += 1
            except Exception as e:
                logger.error(f"Failed to delete pattern {pattern}: {e}")

        execution_time = (time.time() - start_time) * 1000

        return InvalidationResult(
            success=True,
            keys_invalidated=keys_invalidated,
            execution_time_ms=execution_time,
            strategy_used=self.get_strategy_name(),
            metadata={
                "trigger": "manual_invalidation",
                "patterns": patterns,
                "keys": specific_keys,
            },
        )

    def _generate_data_modification_keys(self, event: InvalidationEvent) -> List[str]:
        """Generate cache keys for data modification events"""
        cache_keys = []

        # Entity-specific cache keys
        if event.entity_type == "user":
            cache_keys.extend(
                [
                    CacheKeys.user_context(event.entity_id),
                    CacheKeys.user_clients(event.entity_id),
                ]
            )

        elif event.entity_type == "client":
            cache_keys.extend(
                [
                    CacheKeys.client_engagements(event.entity_id),
                    CacheKeys.client_users(event.entity_id),
                    CacheKeys.client_settings(event.entity_id),
                ]
            )

        elif event.entity_type == "engagement":
            if event.client_account_id:
                cache_keys.extend(
                    [
                        CacheKeys.client_engagements(event.client_account_id),
                        CacheKeys.client_flows(
                            event.client_account_id, event.entity_id
                        ),
                    ]
                )

        # Add analytics and admin caches that might be affected
        cache_keys.extend(
            [
                CacheKeys.admin_active_users(),
            ]
        )

        return cache_keys

    async def _find_keys_by_pattern(self, pattern: str) -> List[str]:
        """Find cache keys matching a pattern"""
        # This would require Redis SCAN functionality
        # For now, return empty list - would need to implement with RedisCache
        return []


__all__ = [
    "EventHandlerMixin",
]
