"""
Cache invalidation policies and configuration.

This module defines invalidation policies, configuration settings,
and policy enforcement mechanisms for cache invalidation strategies.

Generated by CC (Claude Code)
"""

import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Set

from app.core.logging import get_logger

from .base import InvalidationTrigger, InvalidationPriority

logger = get_logger(__name__)


class PolicyScope(Enum):
    """Scope of invalidation policy application"""

    GLOBAL = "global"  # Apply to all cache operations
    TENANT = "tenant"  # Apply to specific tenant
    USER = "user"  # Apply to specific user
    CLIENT = "client"  # Apply to specific client
    ENGAGEMENT = "engagement"  # Apply to specific engagement
    DATA_TYPE = "data_type"  # Apply to specific data types


class PolicyAction(Enum):
    """Actions that can be taken by invalidation policies"""

    ALLOW = "allow"  # Allow the invalidation
    DENY = "deny"  # Deny the invalidation
    MODIFY = "modify"  # Modify the invalidation parameters
    DELAY = "delay"  # Delay the invalidation
    ESCALATE = "escalate"  # Escalate to higher priority


@dataclass
class InvalidationPolicy:
    """Defines a cache invalidation policy"""

    name: str
    scope: PolicyScope
    triggers: Set[InvalidationTrigger] = field(default_factory=set)
    priorities: Set[InvalidationPriority] = field(default_factory=set)
    entity_types: Set[str] = field(default_factory=set)
    action: PolicyAction = PolicyAction.ALLOW
    conditions: Dict[str, Any] = field(default_factory=dict)
    parameters: Dict[str, Any] = field(default_factory=dict)
    enabled: bool = True

    def matches(
        self,
        trigger: InvalidationTrigger,
        priority: InvalidationPriority,
        entity_type: str,
        metadata: Dict[str, Any],
    ) -> bool:
        """Check if this policy applies to the given invalidation event"""

        if not self.enabled:
            return False

        # Check trigger match
        if self.triggers and trigger not in self.triggers:
            return False

        # Check priority match
        if self.priorities and priority not in self.priorities:
            return False

        # Check entity type match
        if self.entity_types and entity_type not in self.entity_types:
            return False

        # Check custom conditions
        for condition_key, condition_value in self.conditions.items():
            if condition_key not in metadata:
                return False
            if metadata[condition_key] != condition_value:
                return False

        return True


class InvalidationPolicyManager:
    """Manages cache invalidation policies and their enforcement"""

    def __init__(self):
        self.policies: List[InvalidationPolicy] = []
        self._default_policies_loaded = False

    def add_policy(self, policy: InvalidationPolicy) -> None:
        """Add a new invalidation policy"""
        self.policies.append(policy)
        logger.info(f"Added invalidation policy: {policy.name}")

    def remove_policy(self, policy_name: str) -> bool:
        """Remove a policy by name"""
        initial_count = len(self.policies)
        self.policies = [p for p in self.policies if p.name != policy_name]
        removed = len(self.policies) < initial_count

        if removed:
            logger.info(f"Removed invalidation policy: {policy_name}")
        else:
            logger.warning(f"Policy not found for removal: {policy_name}")

        return removed

    def get_applicable_policies(
        self,
        trigger: InvalidationTrigger,
        priority: InvalidationPriority,
        entity_type: str,
        metadata: Dict[str, Any],
    ) -> List[InvalidationPolicy]:
        """Get all policies that apply to the given invalidation event"""

        if not self._default_policies_loaded:
            self._load_default_policies()

        applicable_policies = []

        for policy in self.policies:
            if policy.matches(trigger, priority, entity_type, metadata):
                applicable_policies.append(policy)

        return applicable_policies

    def evaluate_policies(
        self,
        trigger: InvalidationTrigger,
        priority: InvalidationPriority,
        entity_type: str,
        metadata: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Evaluate policies and return the enforcement decision"""

        applicable_policies = self.get_applicable_policies(
            trigger, priority, entity_type, metadata
        )

        if not applicable_policies:
            # No policies apply, allow by default
            return {
                "action": PolicyAction.ALLOW,
                "policies_applied": [],
                "parameters": {},
                "reason": "no_applicable_policies",
            }

        # Apply policies in order (later policies can override earlier ones)
        final_action = PolicyAction.ALLOW
        final_parameters = {}
        applied_policies = []

        for policy in applicable_policies:
            applied_policies.append(policy.name)

            if policy.action == PolicyAction.DENY:
                final_action = PolicyAction.DENY
                break  # Deny overrides everything

            elif policy.action == PolicyAction.ESCALATE:
                final_action = PolicyAction.ESCALATE
                final_parameters.update(policy.parameters)

            elif policy.action == PolicyAction.DELAY:
                final_action = PolicyAction.DELAY
                final_parameters.update(policy.parameters)

            elif policy.action == PolicyAction.MODIFY:
                final_action = PolicyAction.MODIFY
                final_parameters.update(policy.parameters)

        return {
            "action": final_action,
            "policies_applied": applied_policies,
            "parameters": final_parameters,
            "reason": "policy_evaluation",
        }

    def _load_default_policies(self) -> None:
        """Load default invalidation policies"""

        # Security event policy - always allow with high priority
        security_policy = InvalidationPolicy(
            name="security_events_high_priority",
            scope=PolicyScope.GLOBAL,
            triggers={InvalidationTrigger.SECURITY_EVENT},
            action=PolicyAction.ESCALATE,
            parameters={"escalated_priority": InvalidationPriority.CRITICAL},
        )
        self.add_policy(security_policy)

        # Rate limiting policy for manual invalidations
        rate_limit_policy = InvalidationPolicy(
            name="manual_invalidation_rate_limit",
            scope=PolicyScope.GLOBAL,
            triggers={InvalidationTrigger.MANUAL_INVALIDATION},
            action=PolicyAction.DELAY,
            parameters={"delay_seconds": 1, "max_per_minute": 60},
        )
        self.add_policy(rate_limit_policy)

        # Background refresh policy - allow with low priority
        background_policy = InvalidationPolicy(
            name="background_refresh_low_priority",
            scope=PolicyScope.GLOBAL,
            triggers={InvalidationTrigger.BACKGROUND_REFRESH},
            priorities={InvalidationPriority.BACKGROUND, InvalidationPriority.LOW},
            action=PolicyAction.ALLOW,
        )
        self.add_policy(background_policy)

        # Critical user session policy
        user_session_policy = InvalidationPolicy(
            name="user_session_critical",
            scope=PolicyScope.GLOBAL,
            triggers={InvalidationTrigger.USER_LOGIN, InvalidationTrigger.USER_LOGOUT},
            action=PolicyAction.ESCALATE,
            parameters={"escalated_priority": InvalidationPriority.CRITICAL},
        )
        self.add_policy(user_session_policy)

        self._default_policies_loaded = True
        logger.info("Loaded default invalidation policies")


class InvalidationQuota:
    """Manages quotas and rate limiting for cache invalidations"""

    def __init__(self):
        self.quotas: Dict[str, Dict[str, Any]] = {}
        self.usage_tracking: Dict[str, Dict[str, Any]] = {}

    def set_quota(
        self, scope: str, identifier: str, limit: int, window_seconds: int
    ) -> None:
        """Set an invalidation quota for a scope and identifier"""

        quota_key = f"{scope}:{identifier}"
        self.quotas[quota_key] = {
            "limit": limit,
            "window_seconds": window_seconds,
            "scope": scope,
            "identifier": identifier,
        }

        # Initialize usage tracking
        if quota_key not in self.usage_tracking:
            self.usage_tracking[quota_key] = {
                "count": 0,
                "window_start": 0,
                "violations": 0,
            }

        logger.info(f"Set quota for {quota_key}: {limit} per {window_seconds}s")

    def check_quota(self, scope: str, identifier: str) -> Dict[str, Any]:
        """Check if quota allows the operation"""

        quota_key = f"{scope}:{identifier}"

        if quota_key not in self.quotas:
            return {"allowed": True, "reason": "no_quota_defined"}

        quota = self.quotas[quota_key]
        usage = self.usage_tracking[quota_key]

        current_time = int(time.time())
        window_start = usage["window_start"]
        window_seconds = quota["window_seconds"]

        # Check if we need to reset the window
        if current_time - window_start >= window_seconds:
            usage["count"] = 0
            usage["window_start"] = current_time

        # Check if within quota
        if usage["count"] >= quota["limit"]:
            usage["violations"] += 1
            return {
                "allowed": False,
                "reason": "quota_exceeded",
                "current_count": usage["count"],
                "limit": quota["limit"],
                "window_seconds": window_seconds,
                "violations": usage["violations"],
            }

        return {
            "allowed": True,
            "reason": "within_quota",
            "current_count": usage["count"],
            "limit": quota["limit"],
        }

    def record_usage(self, scope: str, identifier: str) -> None:
        """Record usage of an invalidation operation"""

        quota_key = f"{scope}:{identifier}"

        if quota_key in self.usage_tracking:
            self.usage_tracking[quota_key]["count"] += 1


# Global policy manager instance
policy_manager = InvalidationPolicyManager()
quota_manager = InvalidationQuota()


__all__ = [
    "PolicyScope",
    "PolicyAction",
    "InvalidationPolicy",
    "InvalidationPolicyManager",
    "InvalidationQuota",
    "policy_manager",
    "quota_manager",
]
