"""
Event-driven cache invalidation strategies.

This module implements event-driven cache invalidation including:
- Real-time updates when data changes
- User action triggers (login, logout, context changes)
- Bulk invalidation for related data
- Cascading invalidation with dependency tracking

Generated by CC (Claude Code)
"""

import time
from typing import Dict, List, Set

from app.constants.cache_keys import CacheKeys
from app.core.logging import get_logger

from .base import (
    BaseInvalidationStrategy,
    InvalidationEvent,
    InvalidationResult,
    InvalidationTrigger,
)
from .event_handlers import EventHandlerMixin

logger = get_logger(__name__)


class EventDrivenInvalidationStrategy(BaseInvalidationStrategy, EventHandlerMixin):
    """
    Handles event-driven cache invalidation including:
    - Real-time updates when data changes
    - User action triggers (login, logout, context changes)
    - Bulk invalidation for related data
    - Cascading invalidation with dependency tracking
    """

    def __init__(self, redis_cache):
        super().__init__(redis_cache)
        self.cascade_relationships = self._build_cascade_relationships()
        self.max_cascade_depth = 5

    def can_handle(self, event: InvalidationEvent) -> bool:
        """Handle all event-driven invalidation triggers"""
        return event.trigger in [
            InvalidationTrigger.USER_LOGIN,
            InvalidationTrigger.USER_LOGOUT,
            InvalidationTrigger.USER_CONTEXT_CHANGE,
            InvalidationTrigger.USER_ROLE_CHANGE,
            InvalidationTrigger.USER_PERMISSION_CHANGE,
            InvalidationTrigger.CLIENT_ACCESS_CHANGE,
            InvalidationTrigger.ENGAGEMENT_CHANGE,
            InvalidationTrigger.DATA_MODIFICATION,
            InvalidationTrigger.SECURITY_EVENT,
            InvalidationTrigger.MANUAL_INVALIDATION,
        ]

    async def invalidate(self, event: InvalidationEvent) -> InvalidationResult:
        """Execute event-driven invalidation"""
        start_time = time.time()

        try:
            if event.trigger in [
                InvalidationTrigger.USER_LOGIN,
                InvalidationTrigger.USER_LOGOUT,
            ]:
                return await self._handle_user_session_event(event)
            elif event.trigger == InvalidationTrigger.USER_CONTEXT_CHANGE:
                return await self._handle_user_context_change(event)
            elif event.trigger in [
                InvalidationTrigger.USER_ROLE_CHANGE,
                InvalidationTrigger.USER_PERMISSION_CHANGE,
            ]:
                return await self._handle_user_permission_change(event)
            elif event.trigger == InvalidationTrigger.CLIENT_ACCESS_CHANGE:
                return await self._handle_client_access_change(event)
            elif event.trigger == InvalidationTrigger.ENGAGEMENT_CHANGE:
                return await self._handle_engagement_change(event)
            elif event.trigger == InvalidationTrigger.DATA_MODIFICATION:
                return await self._handle_data_modification(event)
            elif event.trigger == InvalidationTrigger.SECURITY_EVENT:
                return await self._handle_security_event(event)
            elif event.trigger == InvalidationTrigger.MANUAL_INVALIDATION:
                return await self._handle_manual_invalidation(event)
            else:
                return InvalidationResult(
                    success=False,
                    keys_invalidated=0,
                    execution_time_ms=(time.time() - start_time) * 1000,
                    strategy_used=self.get_strategy_name(),
                    errors=[f"Unsupported trigger: {event.trigger}"],
                )

        except Exception as e:
            logger.error(f"Event-driven invalidation failed: {e}")
            return InvalidationResult(
                success=False,
                keys_invalidated=0,
                execution_time_ms=(time.time() - start_time) * 1000,
                strategy_used=self.get_strategy_name(),
                errors=[str(e)],
            )

    async def _cascade_invalidate(
        self, initial_keys: List[str], event: InvalidationEvent, depth: int
    ) -> int:
        """Perform cascade invalidation with cycle detection"""
        if depth >= self.max_cascade_depth:
            logger.warning(f"Max cascade depth reached: {depth}")
            return 0

        total_invalidated = 0

        # Delete initial keys
        for cache_key in initial_keys:
            try:
                deleted = await self.redis_cache.delete(cache_key)
                if deleted:
                    total_invalidated += 1
                    logger.debug(f"Invalidated cache key: {cache_key}")
            except Exception as e:
                logger.error(f"Failed to invalidate {cache_key}: {e}")

        # Find cascade relationships and continue invalidation
        cascade_keys = set()
        for cache_key in initial_keys:
            related_keys = self._get_cascade_keys(cache_key, event)
            cascade_keys.update(related_keys)

        # Remove already processed keys to avoid cycles
        cascade_keys -= set(initial_keys)

        if cascade_keys:
            cascade_invalidated = await self._cascade_invalidate(
                list(cascade_keys), event, depth + 1
            )
            total_invalidated += cascade_invalidated

        return total_invalidated

    def _get_cascade_keys(self, cache_key: str, event: InvalidationEvent) -> Set[str]:
        """Get keys that should be invalidated when the given key is invalidated"""
        cascade_keys = set()

        # Use the cascade relationships from CacheKeys
        patterns = CacheKeys.get_cascade_patterns(cache_key)

        # Convert patterns to actual keys where possible
        for pattern in patterns:
            # For now, add the pattern itself - would need pattern expansion
            cascade_keys.add(pattern)

        return cascade_keys

    def _generate_data_modification_keys(self, event: InvalidationEvent) -> List[str]:
        """Generate cache keys for data modification events"""
        cache_keys = []

        # Entity-specific cache keys
        if event.entity_type == "user":
            cache_keys.extend(
                [
                    CacheKeys.user_context(event.entity_id),
                    CacheKeys.user_clients(event.entity_id),
                ]
            )

        elif event.entity_type == "client":
            cache_keys.extend(
                [
                    CacheKeys.client_engagements(event.entity_id),
                    CacheKeys.client_users(event.entity_id),
                    CacheKeys.client_settings(event.entity_id),
                ]
            )

        elif event.entity_type == "engagement":
            if event.client_account_id:
                cache_keys.extend(
                    [
                        CacheKeys.client_engagements(event.client_account_id),
                        CacheKeys.client_flows(
                            event.client_account_id, event.entity_id
                        ),
                    ]
                )

        # Add analytics and admin caches that might be affected
        cache_keys.extend(
            [
                CacheKeys.admin_active_users(),
            ]
        )

        return cache_keys

    async def _find_keys_by_pattern(self, pattern: str) -> List[str]:
        """Find cache keys matching a pattern"""
        # This would require Redis SCAN functionality
        # For now, return empty list - would need to implement with RedisCache
        return []

    def _build_cascade_relationships(self) -> Dict[str, Set[str]]:
        """Build cache key cascade relationships"""
        # Use the relationships from CacheKeys constants
        try:
            from app.constants.cache_keys import CASCADE_RELATIONSHIPS

            return CASCADE_RELATIONSHIPS
        except ImportError:
            # Return empty relationships if not available
            return {}


__all__ = [
    "EventDrivenInvalidationStrategy",
]
