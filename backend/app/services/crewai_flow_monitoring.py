"""
CrewAI Flow Monitoring

Handles all monitoring and metrics operations for CrewAI flows including:
- Error tracking and logging
- Performance monitoring
- Health checks
- Metrics collection

Generated by CC for modularization while maintaining backward compatibility.
"""

import logging
from datetime import datetime
from typing import Any, Dict, List, Optional

from sqlalchemy.ext.asyncio import AsyncSession

logger = logging.getLogger(__name__)


class CrewAIFlowMonitoring:
    """
    Handles monitoring and metrics for CrewAI flows.

    This class provides error tracking, performance monitoring,
    health checks, and metrics collection for CrewAI discovery flows.
    """

    def __init__(self, db: Optional[AsyncSession] = None):
        """
        Initialize the monitoring system.

        Args:
            db: Optional database session
        """
        self.db = db
        self._errors: List[Dict[str, Any]] = []
        self._metrics: Dict[str, Any] = {}
        self._performance_data: Dict[str, Any] = {}

    def add_error(
        self, error_message: str, phase: str = None, details: Dict[str, Any] = None
    ) -> None:
        """
        Add error to the flow service for tracking.

        Args:
            error_message: The error message to track
            phase: Optional phase where error occurred
            details: Optional additional error details
        """
        error_entry = {
            "error": error_message,
            "phase": phase or "unknown",
            "timestamp": datetime.now().isoformat(),
            "details": details or {},
        }

        # Store in internal error list for tracking
        self._errors.append(error_entry)

        logger.error(f"âŒ CrewAI Flow Error in phase {phase}: {error_message}")
        if details:
            logger.error(f"   Details: {details}")

    def get_errors(self, phase: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Get all tracked errors, optionally filtered by phase.

        Args:
            phase: Optional phase to filter errors by

        Returns:
            List of error dictionaries
        """
        if phase:
            return [error for error in self._errors if error["phase"] == phase]
        return self._errors.copy()

    def clear_errors(self, phase: Optional[str] = None) -> None:
        """
        Clear tracked errors, optionally for a specific phase.

        Args:
            phase: Optional phase to clear errors for
        """
        if phase:
            self._errors = [error for error in self._errors if error["phase"] != phase]
        else:
            self._errors.clear()

    def record_metric(
        self, metric_name: str, value: Any, metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """
        Record a metric value.

        Args:
            metric_name: Name of the metric
            value: Metric value
            metadata: Optional metadata about the metric
        """
        metric_entry = {
            "value": value,
            "timestamp": datetime.now().isoformat(),
            "metadata": metadata or {},
        }

        if metric_name not in self._metrics:
            self._metrics[metric_name] = []

        self._metrics[metric_name].append(metric_entry)
        logger.info(f"ðŸ“Š Recorded metric {metric_name}: {value}")

    def get_metrics(self, metric_name: Optional[str] = None) -> Dict[str, Any]:
        """
        Get recorded metrics.

        Args:
            metric_name: Optional specific metric to retrieve

        Returns:
            Dict containing metrics data
        """
        if metric_name:
            return {metric_name: self._metrics.get(metric_name, [])}
        return self._metrics.copy()

    def record_performance_data(
        self,
        operation: str,
        duration: float,
        success: bool = True,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> None:
        """
        Record performance data for an operation.

        Args:
            operation: Name of the operation
            duration: Duration in seconds
            success: Whether operation was successful
            metadata: Optional metadata about the operation
        """
        performance_entry = {
            "duration": duration,
            "success": success,
            "timestamp": datetime.now().isoformat(),
            "metadata": metadata or {},
        }

        if operation not in self._performance_data:
            self._performance_data[operation] = []

        self._performance_data[operation].append(performance_entry)
        logger.info(
            f"â±ï¸ Recorded performance for {operation}: {duration:.2f}s (success: {success})"
        )

    def get_performance_data(self, operation: Optional[str] = None) -> Dict[str, Any]:
        """
        Get performance data.

        Args:
            operation: Optional specific operation to retrieve data for

        Returns:
            Dict containing performance data
        """
        if operation:
            return {operation: self._performance_data.get(operation, [])}
        return self._performance_data.copy()

    def get_performance_summary(
        self, operation: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Get summarized performance statistics.

        Args:
            operation: Optional specific operation to summarize

        Returns:
            Dict containing performance summary
        """

        def summarize_operation_data(data: List[Dict[str, Any]]) -> Dict[str, Any]:
            if not data:
                return {
                    "count": 0,
                    "avg_duration": 0,
                    "min_duration": 0,
                    "max_duration": 0,
                    "success_rate": 0,
                }

            durations = [entry["duration"] for entry in data]
            successes = [entry["success"] for entry in data]

            return {
                "count": len(data),
                "avg_duration": sum(durations) / len(durations),
                "min_duration": min(durations),
                "max_duration": max(durations),
                "success_rate": sum(successes) / len(successes),
            }

        if operation:
            data = self._performance_data.get(operation, [])
            return {operation: summarize_operation_data(data)}

        summary = {}
        for op_name, op_data in self._performance_data.items():
            summary[op_name] = summarize_operation_data(op_data)

        return summary

    async def health_check(self, flow_id: Optional[str] = None) -> Dict[str, Any]:
        """
        Perform health check on the monitoring system and optionally a specific flow.

        Args:
            flow_id: Optional flow ID to check health for

        Returns:
            Dict containing health check results
        """
        try:
            health_status = {
                "status": "healthy",
                "timestamp": datetime.now().isoformat(),
                "monitoring_system": {
                    "errors_tracked": len(self._errors),
                    "metrics_recorded": len(self._metrics),
                    "performance_operations": len(self._performance_data),
                },
            }

            if flow_id:
                # Check for flow-specific health indicators
                flow_errors = [
                    error
                    for error in self._errors
                    if error.get("details", {}).get("flow_id") == flow_id
                ]

                health_status["flow_health"] = {
                    "flow_id": flow_id,
                    "errors_count": len(flow_errors),
                    "last_error": flow_errors[-1] if flow_errors else None,
                }

                # Mark as unhealthy if there are recent errors
                if flow_errors:
                    recent_errors = [
                        error
                        for error in flow_errors
                        if (
                            datetime.now() - datetime.fromisoformat(error["timestamp"])
                        ).total_seconds()
                        < 3600
                    ]
                    if recent_errors:
                        health_status["status"] = "degraded"
                        health_status["reason"] = (
                            f"Recent errors detected for flow {flow_id}"
                        )

            logger.info(f"ðŸ¥ Health check completed: {health_status['status']}")
            return health_status

        except Exception as e:
            logger.error(f"âŒ Health check failed: {e}")
            return {
                "status": "unhealthy",
                "timestamp": datetime.now().isoformat(),
                "error": str(e),
                "message": "Health check failed",
            }

    def get_monitoring_report(self, flow_id: Optional[str] = None) -> Dict[str, Any]:
        """
        Generate comprehensive monitoring report.

        Args:
            flow_id: Optional flow ID to generate report for

        Returns:
            Dict containing comprehensive monitoring report
        """
        try:
            report = {
                "timestamp": datetime.now().isoformat(),
                "system_health": "healthy",
                "error_summary": {
                    "total_errors": len(self._errors),
                    "errors_by_phase": {},
                },
                "metrics_summary": {
                    "total_metrics": len(self._metrics),
                    "metric_names": list(self._metrics.keys()),
                },
                "performance_summary": self.get_performance_summary(),
            }

            # Analyze errors by phase
            for error in self._errors:
                phase = error["phase"]
                if phase not in report["error_summary"]["errors_by_phase"]:
                    report["error_summary"]["errors_by_phase"][phase] = 0
                report["error_summary"]["errors_by_phase"][phase] += 1

            # Filter for specific flow if requested
            if flow_id:
                flow_errors = [
                    error
                    for error in self._errors
                    if error.get("details", {}).get("flow_id") == flow_id
                ]
                report["flow_specific"] = {
                    "flow_id": flow_id,
                    "errors": flow_errors,
                    "error_count": len(flow_errors),
                }

            # Determine overall system health
            if len(self._errors) > 10:
                report["system_health"] = "degraded"
            elif any(
                not all(entry["success"] for entry in data)
                for data in self._performance_data.values()
            ):
                report["system_health"] = "degraded"

            logger.info(f"ðŸ“‹ Generated monitoring report: {report['system_health']}")
            return report

        except Exception as e:
            logger.error(f"âŒ Failed to generate monitoring report: {e}")
            return {
                "timestamp": datetime.now().isoformat(),
                "system_health": "unknown",
                "error": str(e),
                "message": "Failed to generate monitoring report",
            }

    def reset_monitoring_data(self) -> None:
        """Reset all monitoring data."""
        self._errors.clear()
        self._metrics.clear()
        self._performance_data.clear()
        logger.info("ðŸ”„ Monitoring data reset")

    def export_monitoring_data(self) -> Dict[str, Any]:
        """
        Export all monitoring data for external analysis.

        Returns:
            Dict containing all monitoring data
        """
        return {
            "timestamp": datetime.now().isoformat(),
            "errors": self._errors.copy(),
            "metrics": self._metrics.copy(),
            "performance_data": self._performance_data.copy(),
        }
