"""
Cache Invalidation Service for AI Stock Assess Platform

This service provides high-level cache invalidation operations with WebSocket events,
cascade invalidation, and integration with the MasterFlowOrchestrator patterns.
It builds on the CacheCoherenceManager for complex invalidation scenarios.

ðŸ”’ Security: Multi-tenant isolation, audit logging, secure WebSocket events
âš¡ Performance: Batch operations, optimized patterns, minimal DB impact
ðŸŽ¯ Coherence: Cascade invalidation, pattern-based invalidation, event-driven
ðŸ“Š Analytics: Comprehensive invalidation tracking and metrics

Generated by CC (Claude Code)
"""

# import asyncio  # Unused
# import json  # Unused
from datetime import datetime
from typing import Any, Dict, List, Optional

# from uuid import UUID  # Unused
# from sqlalchemy.ext.asyncio import AsyncSession  # Unused
from app.constants.cache_keys import CACHE_VERSION, CacheKeys

# from app.core.database import get_db  # Unused
from app.core.logging import get_logger
from app.services.caching.coherence_manager import (
    CacheCoherenceManager,
    get_cache_coherence_manager,
)
from app.services.caching.coherence_manager import (
    CacheInvalidationService as BaseCacheInvalidationService,
)
from app.services.caching.redis_cache import RedisCache, get_redis_cache

logger = get_logger(__name__)


class WebSocketCacheEvent:
    """
    WebSocket event for cache invalidation notifications.
    """

    def __init__(
        self,
        event_type: str,
        entity_type: str,
        entity_id: str,
        client_account_id: str,
        affected_keys: List[str] = None,
        metadata: Dict[str, Any] = None,
    ):
        self.event_type = event_type
        self.entity_type = entity_type
        self.entity_id = entity_id
        self.client_account_id = client_account_id
        self.affected_keys = affected_keys or []
        self.metadata = metadata or {}
        self.timestamp = datetime.utcnow()

    def to_dict(self) -> Dict[str, Any]:
        """Convert event to dictionary for WebSocket transmission."""
        return {
            "type": "cache_invalidation",
            "data": {
                "event_type": self.event_type,
                "entity_type": self.entity_type,
                "entity_id": self.entity_id,
                "client_account_id": str(self.client_account_id),
                "affected_keys": self.affected_keys,
                "metadata": self.metadata,
                "timestamp": self.timestamp.isoformat(),
            },
        }


class CacheInvalidationService:
    """
    High-level cache invalidation service with WebSocket events and specific
    handlers for common platform operations.

    This service provides:
    - Common invalidation patterns for platform entities
    - WebSocket event broadcasting for real-time cache sync
    - Integration with MasterFlowOrchestrator patterns
    - Batch operations for performance
    - Audit logging and metrics
    """

    def __init__(
        self,
        redis_cache: RedisCache,
        coherence_manager: CacheCoherenceManager,
        websocket_manager: Optional[Any] = None,
    ):
        self.redis = redis_cache
        self.coherence = coherence_manager
        self.websocket_manager = websocket_manager
        self.base_service = BaseCacheInvalidationService(coherence_manager)

        # Statistics for monitoring
        self.stats = {
            "total_invalidations": 0,
            "websocket_events_sent": 0,
            "batch_operations": 0,
            "cascade_operations": 0,
            "errors": 0,
        }

    # ========================================
    # USER CONTEXT INVALIDATION
    # ========================================

    async def on_user_updated(
        self,
        user_id: str,
        client_account_id: str,
        reason: str = "User data updated",
        broadcast_event: bool = True,
    ) -> int:
        """
        Invalidate user context when user roles/permissions change.

        Args:
            user_id: User ID that was updated
            client_account_id: Client account for tenant isolation
            reason: Human-readable reason for invalidation
            broadcast_event: Whether to broadcast WebSocket event

        Returns:
            Number of cache keys invalidated
        """
        try:
            logger.info(f"Invalidating user context for user {user_id}")

            # Use base service for cascade invalidation
            context = await self.base_service.on_user_updated(
                user_id, client_account_id
            )

            # Broadcast WebSocket event if requested
            if broadcast_event and self.websocket_manager:
                event = WebSocketCacheEvent(
                    event_type="user_context_changed",
                    entity_type="user",
                    entity_id=user_id,
                    client_account_id=client_account_id,
                    affected_keys=(
                        list(context.invalidated_keys)
                        if hasattr(context, "invalidated_keys")
                        else []
                    ),
                    metadata={"reason": reason},
                )
                await self._broadcast_websocket_event(event)

            self.stats["total_invalidations"] += 1
            self.stats["cascade_operations"] += 1

            return (
                context.total_invalidated
                if hasattr(context, "total_invalidated")
                else 1
            )

        except Exception as e:
            self.stats["errors"] += 1
            logger.error(f"Failed to invalidate user context: {e}")
            raise

    async def on_user_defaults_updated(
        self,
        user_id: str,
        client_account_id: str,
        default_client_id: Optional[str] = None,
        default_engagement_id: Optional[str] = None,
        reason: str = "User defaults updated",
    ) -> int:
        """
        Invalidate when user's default client/engagement is updated.
        This is critical for admin user management scenarios.
        """
        try:
            logger.info(f"Invalidating user defaults for user {user_id}")

            # Use base service
            await self.base_service.on_user_defaults_updated(
                user_id, client_account_id, default_client_id, default_engagement_id
            )

            # Additional specific invalidations for admin flows
            additional_patterns = [
                f"{CACHE_VERSION}:admin:active_users",
                f"{CACHE_VERSION}:admin:pending_approvals",
                f"{CACHE_VERSION}:user:{user_id}:*",
            ]

            total_invalidated = 0
            for pattern in additional_patterns:
                count = await self.coherence.invalidate_pattern(
                    pattern, client_account_id, "USER_DEFAULTS", user_id, reason
                )
                total_invalidated += count

            # Broadcast event
            if self.websocket_manager:
                event = WebSocketCacheEvent(
                    event_type="user_defaults_changed",
                    entity_type="user",
                    entity_id=user_id,
                    client_account_id=client_account_id,
                    metadata={
                        "reason": reason,
                        "default_client_id": default_client_id,
                        "default_engagement_id": default_engagement_id,
                    },
                )
                await self._broadcast_websocket_event(event)

            self.stats["total_invalidations"] += 1
            return total_invalidated

        except Exception as e:
            self.stats["errors"] += 1
            logger.error(f"Failed to invalidate user defaults: {e}")
            raise

    # ========================================
    # FLOW STATE INVALIDATION
    # ========================================

    async def on_flow_state_changed(
        self,
        flow_id: str,
        client_account_id: str,
        engagement_id: Optional[str] = None,
        flow_type: str = "discovery",
        phase: Optional[str] = None,
        reason: str = "Flow state updated",
    ) -> int:
        """
        Invalidate flow-related caches when flow state changes.
        Integrates with MasterFlowOrchestrator patterns.
        """
        try:
            logger.info(f"Invalidating flow caches for flow {flow_id}")

            # Specific flow cache keys based on the existing cache key patterns
            flow_patterns = [
                CacheKeys.flow_complete(
                    flow_id, client_account_id, engagement_id or ""
                ),
                CacheKeys.flow_metadata(
                    flow_id, client_account_id, engagement_id or ""
                ),
                f"{CACHE_VERSION}:client:{client_account_id}:*:flow:{flow_id}:*",
                f"{CACHE_VERSION}:*:flow:{flow_id}:*",
            ]

            # Phase-specific invalidation
            if phase:
                flow_patterns.append(
                    CacheKeys.flow_phase_data(
                        flow_id, phase, client_account_id, engagement_id or ""
                    )
                )

            total_invalidated = 0
            for pattern in flow_patterns:
                count = await self.coherence.invalidate_pattern(
                    pattern, client_account_id, "FLOW_UPDATE", reason=reason
                )
                total_invalidated += count

            # Also invalidate user's active flows cache
            # This requires finding users associated with this flow
            await self._invalidate_user_active_flows(client_account_id, engagement_id)

            # Broadcast WebSocket event
            if self.websocket_manager:
                event = WebSocketCacheEvent(
                    event_type="flow_state_changed",
                    entity_type="flow",
                    entity_id=flow_id,
                    client_account_id=client_account_id,
                    metadata={
                        "reason": reason,
                        "flow_type": flow_type,
                        "phase": phase,
                        "engagement_id": engagement_id,
                    },
                )
                await self._broadcast_websocket_event(event)

            self.stats["total_invalidations"] += 1
            return total_invalidated

        except Exception as e:
            self.stats["errors"] += 1
            logger.error(f"Failed to invalidate flow caches: {e}")
            raise

    # ========================================
    # FIELD MAPPING INVALIDATION
    # ========================================

    async def on_field_mapping_bulk_operation(
        self,
        import_id: str,
        client_account_id: str,
        operation_type: str = "bulk_approve",
        mapping_ids: List[str] = None,
        reason: str = "Field mapping bulk operation",
    ) -> int:
        """
        Invalidate field mappings after bulk approval/rejection operations.
        This addresses the specific cache issues mentioned in the production system.
        """
        try:
            logger.info(f"Invalidating field mapping caches for import {import_id}")

            # Field mapping specific patterns
            mapping_patterns = [
                CacheKeys.field_mappings(import_id, client_account_id),
                CacheKeys.field_mapping_stats(import_id, client_account_id),
                CacheKeys.field_mapping_suggestions(import_id, client_account_id),
                f"{CACHE_VERSION}:client:{client_account_id}:*:import:{import_id}:*",
                f"{CACHE_VERSION}:*:field_mappings:{import_id}:*",
                f"{CACHE_VERSION}:*:mapping_stats:{import_id}:*",
            ]

            total_invalidated = 0
            for pattern in mapping_patterns:
                count = await self.coherence.invalidate_pattern(
                    pattern, client_account_id, "FIELD_MAPPING_BULK", reason=reason
                )
                total_invalidated += count

            # Broadcast WebSocket event for real-time UI updates
            if self.websocket_manager:
                event = WebSocketCacheEvent(
                    event_type="field_mappings_updated",
                    entity_type="field_mappings",
                    entity_id=import_id,
                    client_account_id=client_account_id,
                    metadata={
                        "reason": reason,
                        "operation_type": operation_type,
                        "mapping_ids": mapping_ids or [],
                        "affected_count": len(mapping_ids) if mapping_ids else 0,
                    },
                )
                await self._broadcast_websocket_event(event)

            self.stats["total_invalidations"] += 1
            self.stats["batch_operations"] += 1

            return total_invalidated

        except Exception as e:
            self.stats["errors"] += 1
            logger.error(f"Failed to invalidate field mapping caches: {e}")
            raise

    # ========================================
    # CLIENT/ENGAGEMENT INVALIDATION
    # ========================================

    async def on_engagement_modified(
        self,
        engagement_id: str,
        client_account_id: str,
        operation: str = "UPDATE",
        reason: str = "Engagement modified",
    ) -> int:
        """
        Invalidate when engagement is created/updated/deleted.
        """
        try:
            logger.info(
                f"Invalidating engagement caches for engagement {engagement_id}"
            )

            # Use base service for cascade invalidation
            context = await self.base_service.on_engagement_modified(
                engagement_id, client_account_id
            )

            # Additional engagement-specific patterns
            engagement_patterns = [
                CacheKeys.client_engagements(client_account_id),
                f"{CACHE_VERSION}:*:engagement:{engagement_id}:*",
                f"{CACHE_VERSION}:client:{client_account_id}:engagement:{engagement_id}:*",
            ]

            total_invalidated = (
                context.total_invalidated
                if hasattr(context, "total_invalidated")
                else 0
            )

            for pattern in engagement_patterns:
                count = await self.coherence.invalidate_pattern(
                    pattern, client_account_id, "ENGAGEMENT_UPDATE", reason=reason
                )
                total_invalidated += count

            # Broadcast event
            if self.websocket_manager:
                event = WebSocketCacheEvent(
                    event_type="engagement_modified",
                    entity_type="engagement",
                    entity_id=engagement_id,
                    client_account_id=client_account_id,
                    metadata={"reason": reason, "operation": operation},
                )
                await self._broadcast_websocket_event(event)

            self.stats["total_invalidations"] += 1
            return total_invalidated

        except Exception as e:
            self.stats["errors"] += 1
            logger.error(f"Failed to invalidate engagement caches: {e}")
            raise

    async def on_client_users_changed(
        self,
        client_account_id: str,
        affected_user_ids: List[str] = None,
        reason: str = "Client user associations changed",
    ) -> int:
        """
        Invalidate when client-user associations change.
        """
        try:
            logger.info(
                f"Invalidating client user caches for client {client_account_id}"
            )

            # Client user patterns
            patterns = [
                CacheKeys.client_users(client_account_id),
                f"{CACHE_VERSION}:client:{client_account_id}:users",
            ]

            # Also invalidate affected users' client lists
            if affected_user_ids:
                for user_id in affected_user_ids:
                    patterns.extend(
                        [
                            CacheKeys.user_clients(user_id),
                            CacheKeys.user_context(user_id),
                        ]
                    )

            total_invalidated = 0
            for pattern in patterns:
                count = await self.coherence.invalidate_pattern(
                    pattern, client_account_id, "CLIENT_USER_CHANGE", reason=reason
                )
                total_invalidated += count

            # Broadcast event
            if self.websocket_manager:
                event = WebSocketCacheEvent(
                    event_type="client_users_changed",
                    entity_type="client",
                    entity_id=client_account_id,
                    client_account_id=client_account_id,
                    metadata={
                        "reason": reason,
                        "affected_user_ids": affected_user_ids or [],
                    },
                )
                await self._broadcast_websocket_event(event)

            self.stats["total_invalidations"] += 1
            return total_invalidated

        except Exception as e:
            self.stats["errors"] += 1
            logger.error(f"Failed to invalidate client user caches: {e}")
            raise

    # ========================================
    # ASSET AND ANALYSIS INVALIDATION
    # ========================================

    async def on_asset_inventory_updated(
        self,
        engagement_id: str,
        client_account_id: str,
        asset_ids: List[str] = None,
        reason: str = "Asset inventory updated",
    ) -> int:
        """
        Invalidate asset inventory and related analysis caches.
        """
        try:
            logger.info(f"Invalidating asset caches for engagement {engagement_id}")

            # Asset inventory patterns
            patterns = [
                CacheKeys.asset_inventory(client_account_id, engagement_id),
                f"{CACHE_VERSION}:client:{client_account_id}:engagement:{engagement_id}:assets:*",
            ]

            # Asset-specific invalidation
            if asset_ids:
                for asset_id in asset_ids:
                    patterns.extend(
                        [
                            CacheKeys.asset_dependencies(
                                asset_id, client_account_id, engagement_id
                            ),
                            CacheKeys.asset_recommendations(
                                asset_id, client_account_id, engagement_id
                            ),
                            f"{CACHE_VERSION}:client:{client_account_id}:*:asset:{asset_id}:*",
                        ]
                    )

            total_invalidated = 0
            for pattern in patterns:
                count = await self.coherence.invalidate_pattern(
                    pattern, client_account_id, "ASSET_UPDATE", reason=reason
                )
                total_invalidated += count

            # Broadcast event
            if self.websocket_manager:
                event = WebSocketCacheEvent(
                    event_type="asset_inventory_updated",
                    entity_type="assets",
                    entity_id=engagement_id,
                    client_account_id=client_account_id,
                    metadata={
                        "reason": reason,
                        "engagement_id": engagement_id,
                        "asset_ids": asset_ids or [],
                    },
                )
                await self._broadcast_websocket_event(event)

            self.stats["total_invalidations"] += 1
            return total_invalidated

        except Exception as e:
            self.stats["errors"] += 1
            logger.error(f"Failed to invalidate asset caches: {e}")
            raise

    # ========================================
    # BATCH AND UTILITY OPERATIONS
    # ========================================

    async def invalidate_by_tags(
        self,
        tags: List[str],
        client_account_id: str,
        reason: str = "Tag-based invalidation",
    ) -> int:
        """
        Invalidate all cache entries with specific tags.
        """
        try:
            count = await self.coherence.invalidate_by_tags(
                tags, client_account_id, reason=reason
            )

            # Broadcast event
            if self.websocket_manager:
                event = WebSocketCacheEvent(
                    event_type="cache_invalidated_by_tags",
                    entity_type="cache",
                    entity_id="",
                    client_account_id=client_account_id,
                    metadata={
                        "reason": reason,
                        "tags": tags,
                        "invalidated_count": count,
                    },
                )
                await self._broadcast_websocket_event(event)

            self.stats["total_invalidations"] += 1
            self.stats["batch_operations"] += 1

            return count

        except Exception as e:
            self.stats["errors"] += 1
            logger.error(f"Failed to invalidate by tags: {e}")
            raise

    async def cleanup_expired_entries(self, batch_size: int = 1000) -> int:
        """
        Clean up expired cache entries.
        """
        try:
            count = await self.coherence.cleanup_expired_entries(batch_size)

            if count > 0:
                logger.info(f"Cleaned up {count} expired cache entries")

                # Broadcast cleanup event to all clients
                if self.websocket_manager:
                    event = WebSocketCacheEvent(
                        event_type="cache_cleanup_completed",
                        entity_type="cache",
                        entity_id="",
                        client_account_id="",  # Global event
                        metadata={
                            "reason": "Scheduled cleanup of expired entries",
                            "entries_cleaned": count,
                        },
                    )
                    await self._broadcast_websocket_event(event)

            return count

        except Exception as e:
            self.stats["errors"] += 1
            logger.error(f"Failed to cleanup expired entries: {e}")
            raise

    # ========================================
    # WEBSOCKET EVENT MANAGEMENT
    # ========================================

    async def _broadcast_websocket_event(self, event: WebSocketCacheEvent):
        """
        Broadcast cache invalidation event via WebSocket.
        """
        if not self.websocket_manager:
            logger.debug("WebSocket manager not available, skipping event broadcast")
            return

        try:
            # Convert event to dictionary
            event_data = event.to_dict()

            # Broadcast to all connected clients for this tenant
            await self.websocket_manager.broadcast_to_tenant(
                event.client_account_id, event_data
            )

            self.stats["websocket_events_sent"] += 1

            logger.debug(
                f"Broadcasted cache invalidation event: {event.event_type} "
                f"for {event.entity_type}:{event.entity_id}"
            )

        except Exception as e:
            logger.error(f"Failed to broadcast WebSocket event: {e}")
            # Don't re-raise - WebSocket failures shouldn't break cache invalidation

    # ========================================
    # HELPER METHODS
    # ========================================

    async def _invalidate_user_active_flows(
        self, client_account_id: str, engagement_id: Optional[str] = None
    ):
        """
        Invalidate user active flows caches.
        This is a helper for flow-related invalidations.
        """
        try:
            # Pattern to match user active flows
            if engagement_id:
                pattern = f"{CACHE_VERSION}:user:*:client:{client_account_id}:engagement:{engagement_id}:active_flows"
            else:
                pattern = (
                    f"{CACHE_VERSION}:user:*:client:{client_account_id}:*:active_flows"
                )

            await self.coherence.invalidate_pattern(
                pattern,
                client_account_id,
                "FLOW_RELATED",
                reason="Flow state changed, invalidating user active flows",
            )

        except Exception as e:
            logger.debug(f"Failed to invalidate user active flows: {e}")

    def get_stats(self) -> Dict[str, Any]:
        """Get invalidation service statistics."""
        coherence_metrics = (
            self.coherence.get_coherence_metrics() if self.coherence else {}
        )

        return {
            **self.stats,
            "redis_enabled": self.redis and self.redis.enabled,
            "websocket_enabled": self.websocket_manager is not None,
            "coherence_metrics": coherence_metrics,
        }


# ========================================
# DEPENDENCY INJECTION AND FACTORY
# ========================================


async def get_cache_invalidation_service(
    redis_cache: RedisCache = None,
    coherence_manager: CacheCoherenceManager = None,
    websocket_manager: Any = None,
) -> CacheInvalidationService:
    """
    Factory function to create CacheInvalidationService with dependencies.
    """
    if redis_cache is None:
        redis_cache = get_redis_cache()

    if coherence_manager is None:
        coherence_manager = await get_cache_coherence_manager(redis_cache)

    # WebSocket manager will be injected by the application
    # For now, it's optional and can be None

    return CacheInvalidationService(redis_cache, coherence_manager, websocket_manager)


__all__ = [
    "CacheInvalidationService",
    "WebSocketCacheEvent",
    "get_cache_invalidation_service",
]
