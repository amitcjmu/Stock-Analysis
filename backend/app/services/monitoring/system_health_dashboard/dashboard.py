"""
Main SystemHealthDashboard class

This module contains the core SystemHealthDashboard class with all its
methods preserved for backward compatibility. Due to the tight coupling
and complexity of the original implementation, the core class is kept
largely intact to prevent breaking changes.

Generated by CC (Claude Code)
"""

import asyncio
import time
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from typing import Any, Dict, List

from app.core.logging import get_logger
from app.services.monitoring.auth_performance_monitor import (
    get_auth_performance_monitor,
)
from app.services.monitoring.cache_performance_monitor import (
    get_cache_performance_monitor,
)
from app.services.monitoring.performance_metrics_collector import get_metrics_collector

from .base import HealthScore, HealthStatus
from .collectors import SystemStatsCollector
from .score_calculators import HealthScoreCalculator
from .alert_managers import SystemAlertManager

logger = get_logger(__name__)


class SystemHealthDashboard:
    """
    System Health Dashboard

    Provides comprehensive real-time monitoring and visualization of system
    health across all performance components.
    """

    def __init__(self, update_interval: int = 30):
        self.update_interval = update_interval  # seconds

        # Component integrations
        self.metrics_collector = get_metrics_collector()
        self.auth_monitor = get_auth_performance_monitor()
        self.cache_monitor = get_cache_performance_monitor()

        # Internal components
        self.system_stats_collector = SystemStatsCollector()

        # Performance targets and thresholds
        self.performance_targets = {
            "login_target_ms": 500,
            "context_switch_target_ms": 200,
            "cache_target_ms": 10,
        }

        self.alert_thresholds = {
            "auth_success_rate_threshold": 95,
            "cache_hit_rate_threshold": 80,
            "cpu_usage_threshold": 85,
            "memory_usage_threshold": 90,
            "disk_usage_threshold": 90,
        }

        # Initialize extracted components
        self.score_calculator = HealthScoreCalculator(self.performance_targets)
        self.alert_manager = SystemAlertManager(self.alert_thresholds)

        # Dashboard state
        self.last_update_time = 0
        self.dashboard_data = {}
        self.is_updating = False

        # Background processing
        self.executor = ThreadPoolExecutor(
            max_workers=2, thread_name_prefix="health_dashboard"
        )
        self._start_background_updates()

        logger.info(
            f"SystemHealthDashboard initialized with {update_interval}s update interval"
        )

    def _start_background_updates(self) -> None:
        """Start background dashboard updates"""

        async def background_updater():
            while True:
                try:
                    await self._update_dashboard_data()
                    await asyncio.sleep(self.update_interval)
                except Exception as e:
                    logger.error(f"Background dashboard update failed: {e}")
                    await asyncio.sleep(5)  # Short retry delay

        # Schedule as a task in the current event loop
        try:
            loop = asyncio.get_running_loop()
            loop.create_task(background_updater())
        except RuntimeError:
            # No running event loop, create one in a thread
            def run_async_updater():
                asyncio.run(background_updater())
            
            self.executor.submit(run_async_updater)

    async def _update_dashboard_data(self) -> None:
        """Update dashboard data from all monitoring components"""
        if self.is_updating:
            return

        self.is_updating = True
        start_time = time.time()

        try:
            # Collect data from all monitors
            auth_stats = await self.auth_monitor.get_performance_summary()
            cache_stats = await self.cache_monitor.get_performance_summary()
            system_stats = self.system_stats_collector.collect_system_stats()

            # Calculate health scores
            health_scores = self.score_calculator.calculate_all_health_scores(
                auth_stats, cache_stats, system_stats
            )

            # Update dashboard data
            self.dashboard_data = {
                "timestamp": datetime.utcnow().isoformat(),
                "update_duration_ms": (time.time() - start_time) * 1000,
                "health_scores": health_scores,
                "performance_summary": self._create_performance_summary(
                    auth_stats, cache_stats, system_stats
                ),
                "auth_health": self._create_auth_health_section(auth_stats),
                "cache_health": self._create_cache_health_section(cache_stats),
                "system_health": self._create_system_health_section(system_stats),
                "user_experience": self._create_user_experience_section(
                    auth_stats, cache_stats
                ),
                "alerts": list(self.alert_manager.get_active_alerts().values()),
            }

            # Process alerts
            self.alert_manager.process_alerts(auth_stats, cache_stats, system_stats)

            self.last_update_time = time.time()
            logger.debug(
                f"Dashboard updated in {self.dashboard_data['update_duration_ms']:.2f}ms"
            )

        except Exception as e:
            logger.error(f"Dashboard update failed: {e}")
        finally:
            self.is_updating = False

    def _create_performance_summary(
        self,
        auth_stats: Dict[str, Any],
        cache_stats: Dict[str, Any],
        system_stats: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Create high-level performance summary"""
        return {
            "overall_status": "healthy",  # This would be calculated based on health scores
            "key_metrics": {
                "auth_success_rate": auth_stats.get("overall_summary", {}).get(
                    "overall_success_rate", 0
                ),
                "cache_hit_rate": cache_stats.get("overall_summary", {}).get(
                    "overall_hit_rate", 0
                ),
                "cpu_usage": system_stats.get("cpu_usage_percent", 0),
                "memory_usage": system_stats.get("memory_usage_percent", 0),
            },
            "trends": {
                "auth_trend": "stable",
                "cache_trend": "stable",
                "system_trend": "stable",
            },
        }

    def _create_auth_health_section(self, auth_stats: Dict[str, Any]) -> Dict[str, Any]:
        """Create authentication health section"""
        overall_summary = auth_stats.get("overall_summary", {})
        return {
            "status": "healthy",
            "success_rate": overall_summary.get("overall_success_rate", 0),
            "error_rate": overall_summary.get("overall_error_rate", 0),
            "operations": auth_stats.get("operations", {}),
        }

    def _create_cache_health_section(
        self, cache_stats: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Create cache health section"""
        overall_summary = cache_stats.get("overall_summary", {})
        return {
            "status": "healthy",
            "hit_rate": overall_summary.get("overall_hit_rate", 0),
            "response_time": overall_summary.get("average_response_time_ms", 0),
            "operations": cache_stats.get("operations", {}),
        }

    def _create_system_health_section(
        self, system_stats: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Create system health section"""
        return {
            "status": "healthy",
            "cpu_usage": system_stats.get("cpu_usage_percent", 0),
            "memory_usage": system_stats.get("memory_usage_percent", 0),
            "disk_usage": system_stats.get("disk_usage_percent", 0),
        }

    def _create_user_experience_section(
        self, auth_stats: Dict[str, Any], cache_stats: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Create user experience section"""
        ux_score = self.score_calculator.calculate_user_experience_score(
            auth_stats, cache_stats
        )

        return {
            "overall_score": ux_score,
            "status": (
                "excellent"
                if ux_score >= 90
                else "good" if ux_score >= 75 else "needs_improvement"
            ),
            "key_factors": {
                "login_speed": "good",
                "cache_responsiveness": "excellent",
                "context_switching": "good",
            },
            "bottlenecks": self._identify_user_experience_bottlenecks(
                auth_stats, cache_stats
            ),
        }

    def _identify_user_experience_bottlenecks(
        self, auth_stats: Dict[str, Any], cache_stats: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """Identify user experience bottlenecks"""
        bottlenecks = []

        # Check login performance
        auth_ops = auth_stats.get("operations", {})
        login_p95 = auth_ops.get("login", {}).get("p95_duration_ms", 0)
        if login_p95 > 1000:  # Over 1 second is concerning
            bottlenecks.append(
                {
                    "component": "authentication",
                    "issue": "slow_login",
                    "impact": "high",
                    "value": login_p95,
                    "recommendation": "Optimize authentication flow or database queries",
                }
            )

        # Check cache performance
        cache_avg = cache_stats.get("overall_summary", {}).get(
            "average_response_time_ms", 0
        )
        if cache_avg > 50:  # Over 50ms is slow for cache
            bottlenecks.append(
                {
                    "component": "cache",
                    "issue": "slow_response",
                    "impact": "medium",
                    "value": cache_avg,
                    "recommendation": "Review cache configuration and network latency",
                }
            )

        return bottlenecks

    async def get_dashboard_data(self) -> Dict[str, Any]:
        """Get current dashboard data"""
        if not self.dashboard_data:
            await self._update_dashboard_data()
        return self.dashboard_data

    async def get_health_scores(self) -> Dict[str, HealthScore]:
        """Get current health scores"""
        dashboard_data = await self.get_dashboard_data()
        return dashboard_data.get("health_scores", {})

    async def get_system_status(self) -> Dict[str, Any]:
        """Get high-level system status"""
        health_scores = await self.get_health_scores()
        overall_score = health_scores.get(
            "overall", HealthScore(0.0, HealthStatus.CRITICAL)
        )

        return {
            "status": overall_score.status.value,
            "score": overall_score.score,
            "last_update": self.last_update_time,
            "active_alerts": len(self.alert_manager.get_active_alerts()),
            "components": {
                component: score.status.value
                for component, score in health_scores.items()
                if component != "overall"
            },
        }

    def get_performance_targets(self) -> Dict[str, Any]:
        """Get performance targets configuration"""
        return self.performance_targets.copy()

    def update_performance_targets(self, targets: Dict[str, Any]) -> None:
        """Update performance targets"""
        self.performance_targets.update(targets)
        self.score_calculator.performance_targets.update(targets)
        logger.info(f"Performance targets updated: {targets}")

    def get_alert_summary(self) -> Dict[str, Any]:
        """Get alert summary"""
        return self.alert_manager.get_alert_summary()

    def clear_alert(self, alert_id: str) -> bool:
        """Clear a specific alert"""
        return self.alert_manager.clear_alert(alert_id)
