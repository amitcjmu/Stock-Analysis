"""
Main SystemHealthDashboard class

This module contains the core SystemHealthDashboard class with all its
methods preserved for backward compatibility. Due to the tight coupling
and complexity of the original implementation, the core class is kept
largely intact to prevent breaking changes.

Generated by CC (Claude Code)
"""

import asyncio
import json
import time
from collections import deque
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from typing import Any, Dict, List

from app.core.logging import get_logger
from app.services.monitoring.auth_performance_monitor import (
    get_auth_performance_monitor,
)
from app.services.monitoring.cache_performance_monitor import (
    get_cache_performance_monitor,
)
from app.services.monitoring.performance_metrics_collector import get_metrics_collector

from .base import AlertSeverity, HealthScore, HealthStatus, SystemAlert
from .collectors import SystemStatsCollector

logger = get_logger(__name__)


class SystemHealthDashboard:
    """
    System Health Dashboard

    Provides comprehensive real-time monitoring and visualization of system
    health across all performance components.
    """

    def __init__(self, update_interval: int = 30):
        self.update_interval = update_interval  # seconds

        # Component integrations
        self.metrics_collector = get_metrics_collector()
        self.auth_monitor = get_auth_performance_monitor()
        self.cache_monitor = get_cache_performance_monitor()

        # Dashboard state
        self.dashboard_data: Dict[str, Any] = {}
        self.active_alerts: Dict[str, SystemAlert] = {}
        self.alert_history: deque[SystemAlert] = deque(maxlen=1000)

        # Performance targets (from design document)
        self.performance_targets = {
            "login_target_ms": 500,  # Target: 200-500ms
            "auth_flow_target_ms": 600,  # Target: 300-600ms
            "context_switch_target_ms": 300,  # Target: 100-300ms
            "cache_hit_rate_target": 85.0,  # Target: >80%
            "error_rate_target": 2.0,  # Target: <5%
            "cpu_usage_target": 70.0,  # Target: <80%
            "memory_usage_target": 80.0,  # Target: <85%
        }

        # Health score weights
        self.health_score_weights = {
            "auth_performance": 0.35,
            "cache_performance": 0.25,
            "system_resources": 0.20,
            "error_rates": 0.20,
        }

        # Background dashboard updates
        self._dashboard_executor = ThreadPoolExecutor(
            max_workers=2, thread_name_prefix="dashboard"
        )
        self._last_update = time.time()
        self._update_lock = asyncio.Lock()

        logger.info(
            "SystemHealthDashboard initialized with update_interval=%ds",
            update_interval,
        )

        # Start background updates
        self._start_background_updates()

    def _start_background_updates(self) -> None:
        """Start background dashboard updates"""

        def background_updater():
            while True:
                try:
                    if time.time() - self._last_update > self.update_interval:
                        asyncio.create_task(self._update_dashboard_data())
                        self._last_update = time.time()

                    time.sleep(10)  # Check every 10 seconds
                except Exception as e:
                    logger.error("Error in background dashboard updates: %s", e)
                    time.sleep(30)  # Wait longer on error

        self._dashboard_executor.submit(background_updater)

    async def _update_dashboard_data(self) -> None:
        """Update dashboard data from all monitoring components"""
        async with self._update_lock:
            try:
                logger.debug("Updating dashboard data...")

                # Collect data from all components
                auth_stats = self.auth_monitor.get_comprehensive_stats()
                cache_stats = self.cache_monitor.get_comprehensive_stats()
                system_stats = await SystemStatsCollector.collect_system_stats()

                # Calculate health scores
                health_scores = self._calculate_health_scores(
                    auth_stats, cache_stats, system_stats
                )

                # Create dashboard sections
                dashboard_data = {
                    "timestamp": datetime.utcnow().isoformat(),
                    "health_scores": health_scores,
                    "performance_summary": self._create_performance_summary(
                        auth_stats, cache_stats, system_stats, health_scores
                    ),
                    "auth_health": self._create_auth_health_section(auth_stats),
                    "cache_health": self._create_cache_health_section(cache_stats),
                    "system_health": self._create_system_health_section(system_stats),
                    "user_experience": self._create_user_experience_section(
                        auth_stats, cache_stats, system_stats
                    ),
                    "alerts": list(self.active_alerts.values()),
                }

                # Process alerts
                self._process_alerts(auth_stats, cache_stats, system_stats)

                # Generate recommendations
                dashboard_data["recommendations"] = self._generate_recommendations(
                    health_scores, auth_stats, cache_stats, system_stats
                )

                self.dashboard_data = dashboard_data

                logger.debug("Dashboard data updated successfully")

            except Exception as e:
                logger.error("Error updating dashboard data: %s", e)

    def _calculate_health_scores(
        self,
        auth_stats: Dict[str, Any],
        cache_stats: Dict[str, Any],
        system_stats: Dict[str, Any],
    ) -> Dict[str, HealthScore]:
        """Calculate health scores for all components"""
        health_scores = {}

        # Auth performance score
        health_scores["auth_performance"] = self._calculate_auth_health_score(
            auth_stats
        )

        # Cache performance score
        health_scores["cache_performance"] = self._calculate_cache_health_score(
            cache_stats
        )

        # System resources score
        health_scores["system_resources"] = self._calculate_system_health_score(
            system_stats
        )

        # Overall health score
        health_scores["overall"] = self._calculate_overall_health(health_scores)

        return health_scores

    def _calculate_auth_health_score(self, auth_stats: Dict[str, Any]) -> HealthScore:
        """Calculate authentication performance health score"""
        try:
            factors = {}
            overall_summary = auth_stats.get("overall_summary", {})
            operations = auth_stats.get("operations", {})

            # Success rate factor (40% weight)
            success_rate = overall_summary.get("overall_success_rate", 0)
            success_factor = min(success_rate / 95.0 * 100, 100)  # Target: 95%+
            factors["success_rate"] = success_factor

            # Login performance factor (30% weight)
            login_stats = operations.get("login", {})
            login_p95_ms = login_stats.get("p95_duration_ms", 0)
            if login_p95_ms > 0:
                login_factor = max(
                    0,
                    100
                    - (
                        (login_p95_ms - self.performance_targets["login_target_ms"])
                        / 10
                    ),
                )
            else:
                login_factor = 50  # Neutral score when no data
            factors["login_performance"] = login_factor

            # Context switching factor (20% weight)
            context_stats = operations.get("context_switch", {})
            context_p95_ms = context_stats.get("p95_duration_ms", 0)
            if context_p95_ms > 0:
                context_factor = max(
                    0,
                    100
                    - (
                        (
                            context_p95_ms
                            - self.performance_targets["context_switch_target_ms"]
                        )
                        / 5
                    ),
                )
            else:
                context_factor = 50
            factors["context_switching"] = context_factor

            # Error rate factor (10% weight)
            error_rate = overall_summary.get("overall_error_rate", 0)
            error_factor = max(
                0,
                100
                - (error_rate / self.performance_targets["error_rate_target"] * 100),
            )
            factors["error_rate"] = error_factor

            # Calculate weighted score
            score = (
                success_factor * 0.4
                + login_factor * 0.3
                + context_factor * 0.2
                + error_factor * 0.1
            )

            # Generate recommendations
            recommendations = []
            if success_rate < 95:
                recommendations.append(
                    f"Success rate is {success_rate:.1f}% - investigate error patterns"
                )
            if login_p95_ms > self.performance_targets["login_target_ms"]:
                recommendations.append(
                    f"Login P95 is {login_p95_ms:.0f}ms - optimize authentication flow"
                )
            if context_p95_ms > self.performance_targets["context_switch_target_ms"]:
                recommendations.append(
                    f"Context switching P95 is {context_p95_ms:.0f}ms - optimize context caching"
                )

            return HealthScore(
                component="auth_performance",
                score=score,
                status=HealthScore.calculate_status(score),
                factors=factors,
                recommendations=recommendations,
            )

        except Exception as e:
            logger.error("Error calculating auth health score: %s", e)
            return HealthScore(
                component="auth_performance",
                score=0,
                status=HealthStatus.UNKNOWN,
                factors={},
                recommendations=["Error calculating authentication health score"],
            )

    def _calculate_cache_health_score(self, cache_stats: Dict[str, Any]) -> HealthScore:
        """Calculate cache performance health score"""
        try:
            factors = {}
            overall_summary = cache_stats.get("overall_summary", {})

            # Hit rate factor (50% weight)
            hit_rate = overall_summary.get("overall_hit_rate", 0)
            hit_rate_factor = min(
                hit_rate / self.performance_targets["cache_hit_rate_target"] * 100, 100
            )
            factors["hit_rate"] = hit_rate_factor

            # Response time factor (30% weight)
            avg_response_time = overall_summary.get("average_response_time_ms", 0)
            response_time_factor = max(
                0, 100 - (avg_response_time / 50 * 100)
            )  # Target: <50ms
            factors["response_time"] = response_time_factor

            # Memory utilization factor (20% weight)
            cache_layers = cache_stats.get("cache_layers", {})
            redis_stats = cache_layers.get("redis", {})
            memory_usage = redis_stats.get("memory_usage_mb", 0)
            memory_limit = redis_stats.get("memory_limit_mb", 1000)
            memory_utilization = (
                (memory_usage / memory_limit * 100) if memory_limit > 0 else 0
            )
            memory_factor = max(
                0, 100 - ((memory_utilization - 70) / 30 * 100)
            )  # Target: <70%
            factors["memory_utilization"] = memory_factor

            # Calculate weighted score
            score = (
                hit_rate_factor * 0.5 + response_time_factor * 0.3 + memory_factor * 0.2
            )

            # Generate recommendations
            recommendations = []
            if hit_rate < self.performance_targets["cache_hit_rate_target"]:
                recommendations.append(
                    f"Cache hit rate is {hit_rate:.1f}% - review cache key strategies"
                )
            if avg_response_time > 50:
                recommendations.append(
                    f"Cache response time is {avg_response_time:.1f}ms - optimize cache operations"
                )
            if memory_utilization > 80:
                recommendations.append(
                    f"Cache memory usage is {memory_utilization:.1f}% - consider cache eviction policies"
                )

            return HealthScore(
                component="cache_performance",
                score=score,
                status=HealthScore.calculate_status(score),
                factors=factors,
                recommendations=recommendations,
            )

        except Exception as e:
            logger.error("Error calculating cache health score: %s", e)
            return HealthScore(
                component="cache_performance",
                score=0,
                status=HealthStatus.UNKNOWN,
                factors={},
                recommendations=["Error calculating cache health score"],
            )

    def _calculate_system_health_score(
        self, system_stats: Dict[str, Any]
    ) -> HealthScore:
        """Calculate system resources health score"""
        try:
            factors = {}

            # CPU usage factor (40% weight)
            cpu_usage = system_stats.get("cpu", {}).get("usage_percent", 0)
            cpu_factor = max(
                0,
                100
                - (
                    (cpu_usage - self.performance_targets["cpu_usage_target"])
                    / 30
                    * 100
                ),
            )
            factors["cpu_usage"] = cpu_factor

            # Memory usage factor (40% weight)
            memory_usage = system_stats.get("memory", {}).get("usage_percent", 0)
            memory_factor = max(
                0,
                100
                - (
                    (memory_usage - self.performance_targets["memory_usage_target"])
                    / 20
                    * 100
                ),
            )
            factors["memory_usage"] = memory_factor

            # Process count factor (20% weight)
            process_count = system_stats.get("processes", {}).get("count", 0)
            process_factor = max(
                0, 100 - ((process_count - 200) / 500 * 100)
            )  # Target: <200 processes
            factors["process_count"] = process_factor

            # Calculate weighted score
            score = cpu_factor * 0.4 + memory_factor * 0.4 + process_factor * 0.2

            # Generate recommendations
            recommendations = []
            if cpu_usage > self.performance_targets["cpu_usage_target"]:
                recommendations.append(
                    f"CPU usage is {cpu_usage:.1f}% - monitor for high-load processes"
                )
            if memory_usage > self.performance_targets["memory_usage_target"]:
                recommendations.append(
                    f"Memory usage is {memory_usage:.1f}% - check for memory leaks"
                )
            if process_count > 500:
                recommendations.append(
                    f"Process count is {process_count} - review process management"
                )

            return HealthScore(
                component="system_resources",
                score=score,
                status=HealthScore.calculate_status(score),
                factors=factors,
                recommendations=recommendations,
            )

        except Exception as e:
            logger.error("Error calculating system health score: %s", e)
            return HealthScore(
                component="system_resources",
                score=0,
                status=HealthStatus.UNKNOWN,
                factors={},
                recommendations=["Error calculating system health score"],
            )

    def _calculate_overall_health(
        self, health_scores: Dict[str, HealthScore]
    ) -> HealthScore:
        """Calculate overall system health score"""
        try:
            factors = {}
            total_score = 0
            total_weight = 0

            for component, weight in self.health_score_weights.items():
                if component in health_scores:
                    score = health_scores[component].score
                    factors[component] = score
                    total_score += score * weight
                    total_weight += weight

            overall_score = total_score / total_weight if total_weight > 0 else 0

            # Collect all recommendations
            recommendations = []
            for component_score in health_scores.values():
                if component_score.component != "overall":
                    recommendations.extend(component_score.recommendations)

            return HealthScore(
                component="overall",
                score=overall_score,
                status=HealthScore.calculate_status(overall_score),
                factors=factors,
                recommendations=recommendations[:5],  # Top 5 recommendations
            )

        except Exception as e:
            logger.error("Error calculating overall health score: %s", e)
            return HealthScore(
                component="overall",
                score=0,
                status=HealthStatus.UNKNOWN,
                factors={},
                recommendations=["Error calculating overall health score"],
            )

    def _create_performance_summary(
        self,
        auth_stats: Dict[str, Any],
        cache_stats: Dict[str, Any],
        system_stats: Dict[str, Any],
        health_scores: Dict[str, HealthScore],
    ) -> Dict[str, Any]:
        """Create performance summary section"""
        overall_health = health_scores.get("overall")

        return {
            "overall_health_score": overall_health.score if overall_health else 0,
            "overall_status": (
                overall_health.status.value if overall_health else "unknown"
            ),
            "key_metrics": {
                "auth_success_rate": auth_stats.get("overall_summary", {}).get(
                    "overall_success_rate", 0
                ),
                "cache_hit_rate": cache_stats.get("overall_summary", {}).get(
                    "overall_hit_rate", 0
                ),
                "cpu_usage": system_stats.get("cpu", {}).get("usage_percent", 0),
                "memory_usage": system_stats.get("memory", {}).get("usage_percent", 0),
            },
            "performance_targets": self.performance_targets,
            "last_updated": datetime.utcnow().isoformat(),
        }

    def _create_auth_health_section(self, auth_stats: Dict[str, Any]) -> Dict[str, Any]:
        """Create authentication health section"""
        overall_summary = auth_stats.get("overall_summary", {})
        operations = auth_stats.get("operations", {})

        return {
            "success_rate": overall_summary.get("overall_success_rate", 0),
            "error_rate": overall_summary.get("overall_error_rate", 0),
            "active_operations": overall_summary.get("active_operations", 0),
            "login_performance": operations.get("login", {}),
            "context_switching": operations.get("context_switch", {}),
        }

    def _create_cache_health_section(
        self, cache_stats: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Create cache health section"""
        overall_summary = cache_stats.get("overall_summary", {})
        cache_layers = cache_stats.get("cache_layers", {})

        return {
            "hit_rate": overall_summary.get("overall_hit_rate", 0),
            "response_time_ms": overall_summary.get("average_response_time_ms", 0),
            "active_operations": overall_summary.get("active_operations", 0),
            "redis_stats": cache_layers.get("redis", {}),
            "memory_stats": cache_layers.get("memory", {}),
        }

    def _create_system_health_section(
        self, system_stats: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Create system health section"""
        return {
            "cpu": system_stats.get("cpu", {}),
            "memory": system_stats.get("memory", {}),
            "disk_io": system_stats.get("disk_io", {}),
            "network_io": system_stats.get("network_io", {}),
            "processes": system_stats.get("processes", {}),
        }

    def _create_user_experience_section(
        self,
        auth_stats: Dict[str, Any],
        cache_stats: Dict[str, Any],
        system_stats: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Create user experience section"""
        ux_score = self._calculate_user_experience_score(
            auth_stats, cache_stats, system_stats
        )
        bottlenecks = self._identify_user_experience_bottlenecks(
            auth_stats, cache_stats, system_stats
        )

        return {
            "experience_score": ux_score,
            "bottlenecks": bottlenecks,
            "key_user_metrics": {
                "login_time_p95": auth_stats.get("operations", {})
                .get("login", {})
                .get("p95_duration_ms", 0),
                "cache_response_p95": cache_stats.get("overall_summary", {}).get(
                    "p95_response_time_ms", 0
                ),
                "system_responsiveness": 100
                - system_stats.get("cpu", {}).get("usage_percent", 0),
            },
        }

    def _calculate_user_experience_score(
        self,
        auth_stats: Dict[str, Any],
        cache_stats: Dict[str, Any],
        system_stats: Dict[str, Any],
    ) -> float:
        """Calculate user experience score based on performance metrics"""
        # Simplified UX scoring based on key user-facing metrics
        login_time = (
            auth_stats.get("operations", {}).get("login", {}).get("p95_duration_ms", 0)
        )
        cache_time = cache_stats.get("overall_summary", {}).get(
            "average_response_time_ms", 0
        )
        cpu_usage = system_stats.get("cpu", {}).get("usage_percent", 0)

        login_score = max(0, 100 - (login_time / 500 * 100))  # Target: <500ms
        cache_score = max(0, 100 - (cache_time / 50 * 100))  # Target: <50ms
        system_score = max(0, 100 - cpu_usage)  # Lower CPU = better UX

        return login_score * 0.5 + cache_score * 0.3 + system_score * 0.2

    def _identify_user_experience_bottlenecks(
        self,
        auth_stats: Dict[str, Any],
        cache_stats: Dict[str, Any],
        system_stats: Dict[str, Any],
    ) -> List[str]:
        """Identify bottlenecks affecting user experience"""
        bottlenecks = []

        # Check authentication bottlenecks
        login_time = (
            auth_stats.get("operations", {}).get("login", {}).get("p95_duration_ms", 0)
        )
        if login_time > 500:
            bottlenecks.append(f"Slow login performance: {login_time:.0f}ms P95")

        # Check cache bottlenecks
        cache_hit_rate = cache_stats.get("overall_summary", {}).get(
            "overall_hit_rate", 0
        )
        if cache_hit_rate < 80:
            bottlenecks.append(f"Low cache hit rate: {cache_hit_rate:.1f}%")

        # Check system bottlenecks
        cpu_usage = system_stats.get("cpu", {}).get("usage_percent", 0)
        if cpu_usage > 80:
            bottlenecks.append(f"High CPU usage: {cpu_usage:.1f}%")

        memory_usage = system_stats.get("memory", {}).get("usage_percent", 0)
        if memory_usage > 85:
            bottlenecks.append(f"High memory usage: {memory_usage:.1f}%")

        return bottlenecks

    def _process_alerts(
        self,
        auth_stats: Dict[str, Any],
        cache_stats: Dict[str, Any],
        system_stats: Dict[str, Any],
    ) -> None:
        """Process and manage system alerts"""
        current_time = datetime.utcnow()

        # Check authentication alerts
        auth_success_rate = auth_stats.get("overall_summary", {}).get(
            "overall_success_rate", 100
        )
        if auth_success_rate < 95:
            alert_id = "auth_success_rate_low"
            if alert_id not in self.active_alerts:
                alert = SystemAlert(
                    id=alert_id,
                    severity=(
                        AlertSeverity.CRITICAL
                        if auth_success_rate < 90
                        else AlertSeverity.WARNING
                    ),
                    component="authentication",
                    metric="success_rate",
                    current_value=auth_success_rate,
                    threshold=95.0,
                    message=f"Authentication success rate is {auth_success_rate:.1f}%",
                    timestamp=current_time,
                )
                self.active_alerts[alert_id] = alert
                self.alert_history.append(alert)
        else:
            # Remove alert if condition is resolved
            if "auth_success_rate_low" in self.active_alerts:
                del self.active_alerts["auth_success_rate_low"]

        # Check cache alerts
        cache_hit_rate = cache_stats.get("overall_summary", {}).get(
            "overall_hit_rate", 100
        )
        if cache_hit_rate < self.performance_targets["cache_hit_rate_target"]:
            alert_id = "cache_hit_rate_low"
            if alert_id not in self.active_alerts:
                alert = SystemAlert(
                    id=alert_id,
                    severity=AlertSeverity.WARNING,
                    component="cache",
                    metric="hit_rate",
                    current_value=cache_hit_rate,
                    threshold=self.performance_targets["cache_hit_rate_target"],
                    message=f"Cache hit rate is {cache_hit_rate:.1f}%",
                    timestamp=current_time,
                )
                self.active_alerts[alert_id] = alert
                self.alert_history.append(alert)
        else:
            if "cache_hit_rate_low" in self.active_alerts:
                del self.active_alerts["cache_hit_rate_low"]

        # Check system resource alerts
        cpu_usage = system_stats.get("cpu", {}).get("usage_percent", 0)
        if cpu_usage > self.performance_targets["cpu_usage_target"]:
            alert_id = "cpu_usage_high"
            if alert_id not in self.active_alerts:
                alert = SystemAlert(
                    id=alert_id,
                    severity=(
                        AlertSeverity.CRITICAL
                        if cpu_usage > 90
                        else AlertSeverity.WARNING
                    ),
                    component="system",
                    metric="cpu_usage",
                    current_value=cpu_usage,
                    threshold=self.performance_targets["cpu_usage_target"],
                    message=f"CPU usage is {cpu_usage:.1f}%",
                    timestamp=current_time,
                )
                self.active_alerts[alert_id] = alert
                self.alert_history.append(alert)
        else:
            if "cpu_usage_high" in self.active_alerts:
                del self.active_alerts["cpu_usage_high"]

    def _generate_recommendations(
        self,
        health_scores: Dict[str, HealthScore],
        auth_stats: Dict[str, Any],
        cache_stats: Dict[str, Any],
        system_stats: Dict[str, Any],
    ) -> List[str]:
        """Generate performance optimization recommendations"""
        recommendations = []

        # Collect recommendations from health scores
        for score in health_scores.values():
            recommendations.extend(score.recommendations)

        # Add specific recommendations based on metrics
        auth_success_rate = auth_stats.get("overall_summary", {}).get(
            "overall_success_rate", 100
        )
        if auth_success_rate < 98:
            recommendations.append(
                "Investigate authentication failure patterns and optimize error handling"
            )

        cache_hit_rate = cache_stats.get("overall_summary", {}).get(
            "overall_hit_rate", 100
        )
        if cache_hit_rate < 90:
            recommendations.append(
                "Review cache key strategies and implement preemptive cache warming"
            )

        cpu_usage = system_stats.get("cpu", {}).get("usage_percent", 0)
        if cpu_usage > 75:
            recommendations.append(
                "Monitor CPU-intensive operations and consider load balancing"
            )

        # Remove duplicates and limit to top recommendations
        unique_recommendations = list(dict.fromkeys(recommendations))
        return unique_recommendations[:8]

    async def get_dashboard_data(self) -> Dict[str, Any]:
        """Get current dashboard data"""
        # Update if data is stale
        if time.time() - self._last_update > self.update_interval:
            await self._update_dashboard_data()

        return self.dashboard_data.copy()

    async def get_real_time_metrics(self) -> Dict[str, Any]:
        """Get real-time metrics snapshot"""
        auth_stats = self.auth_monitor.get_comprehensive_stats(
            window_seconds=300
        )  # Last 5 minutes
        cache_stats = self.cache_monitor.get_comprehensive_stats(window_seconds=300)
        system_stats = await SystemStatsCollector.collect_system_stats()

        return {
            "timestamp": datetime.utcnow().isoformat(),
            "auth_performance": {
                "active_operations": auth_stats.get("overall_summary", {}).get(
                    "active_operations", 0
                ),
                "recent_login_p95_ms": auth_stats.get("operations", {})
                .get("login", {})
                .get("p95_duration_ms", 0),
                "recent_success_rate": auth_stats.get("overall_summary", {}).get(
                    "overall_success_rate", 0
                ),
            },
            "cache_performance": {
                "current_hit_rate": cache_stats.get("overall_summary", {}).get(
                    "overall_hit_rate", 0
                ),
                "redis_response_ms": cache_stats.get("cache_layers", {})
                .get("redis", {})
                .get("average_response_time_ms", 0),
                "active_operations": cache_stats.get("overall_summary", {}).get(
                    "active_operations", 0
                ),
            },
            "system_resources": {
                "cpu_usage": system_stats.get("cpu", {}).get("usage_percent", 0),
                "memory_usage": system_stats.get("memory", {}).get("usage_percent", 0),
            },
        }

    async def export_dashboard_json(self) -> str:
        """Export dashboard data as JSON"""
        dashboard_data = await self.get_dashboard_data()
        return json.dumps(dashboard_data, indent=2, default=str)

    def get_dashboard_health(self) -> Dict[str, Any]:
        """Get dashboard system health"""
        return {
            "status": "healthy",
            "last_update": datetime.fromtimestamp(self._last_update).isoformat(),
            "update_interval_seconds": self.update_interval,
            "active_alerts": len(self.active_alerts),
            "components_monitored": [
                "auth_performance",
                "cache_performance",
                "system_resources",
            ],
            "data_freshness_seconds": time.time() - self._last_update,
        }
