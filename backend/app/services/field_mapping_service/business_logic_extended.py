"""
Extended business logic methods for field mapping operations.

Generated by CC (Claude Code)
"""

from typing import Any, Dict, List, Optional
from uuid import UUID


async def get_field_mappings(
    analyzer,
    repository,
    service_base,
    data_import_id: Optional[UUID] = None,
    master_flow_id: Optional[UUID] = None,
    asset_type: Optional[str] = None,
) -> Dict[str, List[str]]:
    """
    Get all field mappings for the current context.

    Args:
        analyzer: Field mapping analyzer
        repository: Database repository
        service_base: Base service for error handling
        data_import_id: Optional data import ID filter
        master_flow_id: Optional master flow ID filter
        asset_type: Optional asset type filter

    Returns:
        Dictionary of canonical fields to their variations
    """
    try:
        # Load learned mappings if not cached
        if analyzer.learned_mappings_cache is None:
            learned_cache, negative_cache = await repository.load_learned_mappings(
                data_import_id, master_flow_id
            )
            analyzer.learned_mappings_cache = learned_cache
            analyzer.negative_mappings_cache = negative_cache

        return analyzer.get_field_mappings(asset_type)

    except Exception as e:
        await service_base.record_failure(
            operation="get_field_mappings",
            error=e,
            context_data={"asset_type": asset_type},
        )
        from .base import BASE_MAPPINGS

        return dict(BASE_MAPPINGS)  # Fallback to base mappings


async def validate_mapping(
    repository,
    analyzer,
    service_base,
    source_field: str,
    target_field: str,
    data_import_id: Optional[UUID] = None,
    master_flow_id: Optional[UUID] = None,
    sample_values: Optional[List[Any]] = None,
) -> Dict[str, Any]:
    """
    Validate a field mapping with optional content analysis.

    Args:
        repository: Database repository
        analyzer: Field mapping analyzer
        service_base: Base service for error handling
        source_field: Source field name
        target_field: Target field name
        data_import_id: Optional data import ID for context
        master_flow_id: Optional master flow ID for context
        sample_values: Optional sample values for validation

    Returns:
        Validation result with confidence and issues
    """
    try:

        def _normalize_field_name(field_name: str) -> str:
            """Normalize field name for comparison."""
            return field_name.lower().strip().replace(" ", "_").replace("-", "_")

        normalized_source = _normalize_field_name(source_field)
        normalized_target = _normalize_field_name(target_field)

        # Check if this is a known negative mapping
        if (normalized_source, normalized_target) in analyzer.negative_mappings_cache:
            return {
                "valid": False,
                "confidence": 0.0,
                "issues": ["This mapping was previously rejected"],
            }

        # Check base mappings
        from .base import BASE_MAPPINGS

        if normalized_target in BASE_MAPPINGS:
            variations = [
                _normalize_field_name(v) for v in BASE_MAPPINGS[normalized_target]
            ]
            if normalized_source in variations:
                return {
                    "valid": True,
                    "confidence": 1.0,
                    "source": "base_mapping",
                    "issues": [],
                }

        # Check learned mappings
        existing = await repository.get_existing_mapping(
            normalized_source, normalized_target, data_import_id
        )
        if existing and existing.confidence_score > 0:
            return {
                "valid": True,
                "confidence": existing.confidence_score,
                "source": "learned_mapping",
                "issues": [],
            }

        # Perform content validation if sample values provided
        if sample_values:
            from .validators import FieldMappingValidator

            content_issues = FieldMappingValidator.validate_content(
                target_field, sample_values
            )
            if content_issues:
                return {"valid": False, "confidence": 0.5, "issues": content_issues}

        # No existing mapping found
        return {
            "valid": False,
            "confidence": 0.0,
            "issues": ["No existing mapping found"],
            "suggestion": "Consider learning this mapping if valid",
        }

    except Exception as e:
        await service_base.record_failure(
            operation="validate_mapping",
            error=e,
            context_data={
                "source_field": source_field,
                "target_field": target_field,
            },
        )
        return {"valid": False, "confidence": 0.0, "error": str(e)}
