"""
Database repository for field mapping operations.

Generated by CC (Claude Code)
"""

import logging
from datetime import datetime
from typing import Any, Dict, List, Optional, Set
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, func
from sqlalchemy.exc import IntegrityError

from app.core.context import RequestContext
from app.models.data_import.mapping import ImportFieldMapping as FieldMapping

from ..base import MappingRule

logger = logging.getLogger(__name__)


class FieldMappingRepository:
    """Repository for field mapping database operations."""

    def __init__(self, session: AsyncSession, context: RequestContext):
        """
        Initialize repository.

        Args:
            session: Database session
            context: Request context with tenant information
        """
        self.session = session
        self.context = context

    async def get_mapping_count(self) -> int:
        """Get count of mappings for tenant."""
        query = select(func.count(FieldMapping.id)).where(
            FieldMapping.client_account_id == self.context.client_account_id
        )
        result = await self.session.execute(query)
        return result.scalar() or 0

    async def load_learned_mappings(
        self,
        data_import_id: Optional[UUID] = None,
        master_flow_id: Optional[UUID] = None,
    ) -> tuple[Dict[str, List[MappingRule]], Set[tuple]]:
        """
        Load learned mappings from database.

        Returns:
            Tuple of (learned_mappings_cache, negative_mappings_cache)
        """
        try:
            # Build query for approved mappings
            conditions = [
                FieldMapping.client_account_id == self.context.client_account_id,
                FieldMapping.status == "approved",
                FieldMapping.confidence_score > 0,
            ]

            if data_import_id:
                conditions.append(FieldMapping.data_import_id == data_import_id)
            elif master_flow_id:
                conditions.append(FieldMapping.master_flow_id == master_flow_id)

            query = select(FieldMapping).where(and_(*conditions))
            result = await self.session.execute(query)
            mappings = result.scalars().all()

            # Build learned mappings cache
            learned_mappings_cache = {}
            for mapping in mappings:
                target = mapping.target_field
                if target not in learned_mappings_cache:
                    learned_mappings_cache[target] = []

                rule = MappingRule(
                    source_field=mapping.source_field,
                    target_field=mapping.target_field,
                    confidence=mapping.confidence_score,
                    source=mapping.suggested_by or "learned",
                    context=(
                        mapping.transformation_rules.get("context")
                        if mapping.transformation_rules
                        else None
                    ),
                    created_at=mapping.created_at,
                )
                learned_mappings_cache[target].append(rule)

            # Load rejected mappings
            negative_conditions = [
                FieldMapping.client_account_id == self.context.client_account_id,
                FieldMapping.status == "rejected",
            ]

            if data_import_id:
                negative_conditions.append(
                    FieldMapping.data_import_id == data_import_id
                )
            elif master_flow_id:
                negative_conditions.append(
                    FieldMapping.master_flow_id == master_flow_id
                )

            negative_query = select(FieldMapping).where(and_(*negative_conditions))
            negative_result = await self.session.execute(negative_query)
            negative_mappings = negative_result.scalars().all()

            negative_mappings_cache = set()
            for mapping in negative_mappings:
                negative_mappings_cache.add(
                    (mapping.source_field, mapping.target_field)
                )

            logger.debug(
                f"Loaded {len(mappings)} learned mappings and "
                f"{len(negative_mappings_cache)} negative mappings"
            )

            return learned_mappings_cache, negative_mappings_cache

        except Exception as e:
            logger.error(f"Failed to load learned mappings: {e}")
            return {}, set()

    async def get_existing_mapping(
        self,
        source_field: str,
        target_field: str,
        data_import_id: Optional[UUID] = None,
    ) -> Optional[FieldMapping]:
        """Get existing mapping from database."""
        conditions = [
            FieldMapping.client_account_id == self.context.client_account_id,
            FieldMapping.source_field == source_field,
            FieldMapping.target_field == target_field,
            FieldMapping.status.in_(["approved", "suggested"]),
        ]

        if data_import_id:
            conditions.append(FieldMapping.data_import_id == data_import_id)

        query = select(FieldMapping).where(and_(*conditions))
        result = await self.session.execute(query)
        return result.scalar_one_or_none()

    async def create_mapping(
        self,
        source_field: str,
        target_field: str,
        data_import_id: UUID,
        master_flow_id: Optional[UUID],
        confidence: float,
        source: str,
        context: Optional[str] = None,
    ) -> FieldMapping:
        """Create new field mapping."""
        mapping = FieldMapping(
            client_account_id=self.context.client_account_id,
            engagement_id=self.context.engagement_id,
            data_import_id=data_import_id,
            master_flow_id=master_flow_id,
            source_field=source_field,
            target_field=target_field,
            confidence_score=confidence,
            status="approved",
            suggested_by=source,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
        )

        if context:
            mapping.transformation_rules = {"context": context}

        self.session.add(mapping)
        return mapping

    async def create_negative_mapping(
        self,
        source_field: str,
        target_field: str,
        data_import_id: UUID,
        master_flow_id: Optional[UUID],
        reason: Optional[str] = None,
    ) -> FieldMapping:
        """Create negative mapping (rejected)."""
        mapping = FieldMapping(
            client_account_id=self.context.client_account_id,
            engagement_id=self.context.engagement_id,
            data_import_id=data_import_id,
            master_flow_id=master_flow_id,
            source_field=source_field,
            target_field=target_field,
            confidence_score=0.0,
            status="rejected",
            suggested_by="user",
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
        )

        if reason:
            mapping.transformation_rules = {"rejection_reason": reason}

        self.session.add(mapping)
        return mapping

    async def update_mapping(
        self,
        mapping: FieldMapping,
        confidence: float,
        source: str,
        context: Optional[str] = None,
    ) -> None:
        """Update existing mapping."""
        mapping.confidence_score = confidence
        mapping.updated_at = datetime.utcnow()
        mapping.suggested_by = source

        if context:
            mapping.transformation_rules = mapping.transformation_rules or {}
            mapping.transformation_rules["context"] = context
