"""
CrewAI Flow Service - Backward Compatibility Shim

This service bridges CrewAI flows with the V2 Discovery Flow architecture.
Uses flow_id as single source of truth instead of session_id.

Modularized by CC to improve maintainability while preserving backward compatibility.
"""

import logging
from typing import TYPE_CHECKING, Any, Dict, List, Optional

from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db

# Modular components - Generated by CC
from app.services.crewai_flow_executor import CrewAIFlowExecutor
from app.services.crewai_flow_lifecycle import CrewAIFlowLifecycleManager
from app.services.crewai_flow_monitoring import CrewAIFlowMonitoring
from app.services.crewai_flow_state_manager import CrewAIFlowStateManager
from app.services.crewai_flow_utils import CrewAIFlowUtils

# from app.models.discovery_asset import DiscoveryAsset  # Model removed - using Asset model instead
# V2 Discovery Flow Models
# V2 Discovery Flow Services
from app.services.discovery_flow_service import DiscoveryFlowService

# CrewAI Flow Integration (Conditional)
if TYPE_CHECKING:
    from app.services.crewai_flows.unified_discovery_flow import UnifiedDiscoveryFlow
else:
    try:
        from app.services.crewai_flows.unified_discovery_flow import (
            UnifiedDiscoveryFlow,
        )

        CREWAI_FLOWS_AVAILABLE = True
    except ImportError:
        CREWAI_FLOWS_AVAILABLE = False
        UnifiedDiscoveryFlow = None

logger = logging.getLogger(__name__)


class CrewAIFlowService:
    """
    V2 CrewAI Flow Service - Bridges CrewAI flows with Discovery Flow architecture.

    Key Changes:
    - Uses flow_id instead of session_id
    - Integrates with V2 Discovery Flow models
    - Provides graceful fallback when CrewAI flows unavailable
    - Multi-tenant isolation through context-aware repositories
    - Modularized by CC for improved maintainability

    This class now serves as a facade that delegates to specialized modules:
    - CrewAIFlowStateManager: State and status management
    - CrewAIFlowExecutor: Flow execution logic
    - CrewAIFlowLifecycleManager: Lifecycle operations (pause/resume/cleanup)
    - CrewAIFlowMonitoring: Error tracking and metrics
    - CrewAIFlowUtils: Helper functions and utilities
    """

    def __init__(self, db: Optional[AsyncSession] = None):
        self.db = db
        self._discovery_flow_service: Optional[DiscoveryFlowService] = None
        self._llm = None

        # Initialize modular components - Generated by CC
        self._state_manager = CrewAIFlowStateManager(db)
        self._executor = CrewAIFlowExecutor(db)
        self._lifecycle_manager = CrewAIFlowLifecycleManager(db)
        self._monitoring = CrewAIFlowMonitoring(db)
        self._utils = CrewAIFlowUtils(db)

        # Inject this service instance into lifecycle manager for resume operations
        # This maintains the existing API while using modular components
        self._lifecycle_manager._crewai_service = self

    async def _get_discovery_flow_service(
        self, context: Dict[str, Any]
    ) -> DiscoveryFlowService:
        """Get or create discovery flow service with context."""
        if not self._discovery_flow_service:
            # Create a new database session if one wasn't provided
            from app.core.database import AsyncSessionLocal

            if not self.db:
                logger.info(
                    "ðŸ” Creating new database session for V2 Discovery Flow service"
                )
                self.db = AsyncSessionLocal()

            # Create RequestContext from the context dict
            from app.core.context import RequestContext

            request_context = RequestContext(
                client_account_id=context.get("client_account_id"),
                engagement_id=context.get("engagement_id"),
                user_id=context.get("approved_by") or context.get("user_id"),
            )

            self._discovery_flow_service = DiscoveryFlowService(
                self.db, request_context
            )

        return self._discovery_flow_service

    def get_llm(self):
        """Get the LLM instance for CrewAI agents."""
        # Delegate to utils module - Generated by CC
        return self._utils.get_llm()

    def get_agents(self) -> Dict[str, Any]:
        """
        Get all CrewAI agents for the discovery flow.

        Note: UnifiedDiscoveryFlow uses crews managed by UnifiedFlowCrewManager,
        not individual agents. This method returns None for all agents to match
        the flow_initialization.py pattern.
        """
        # Delegate to utils module - Generated by CC
        return self._utils.get_agents()

    async def initialize_flow(
        self,
        flow_id: str,
        context: Dict[str, Any],
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Initialize a new CrewAI flow using V2 Discovery Flow architecture.

        Args:
            flow_id: Discovery Flow ID (replaces session_id)
            context: Request context with client/engagement info
            metadata: Optional flow metadata
        """
        # Delegate to lifecycle manager - Generated by CC
        return await self._lifecycle_manager.initialize_flow(flow_id, context, metadata)

    async def get_flow_status(
        self, flow_id: str, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Get comprehensive flow status using V2 architecture.

        Args:
            flow_id: Discovery Flow ID
            context: Request context
        """
        # Delegate to state manager - Generated by CC
        return await self._state_manager.get_flow_status(flow_id, context)

    async def advance_flow_phase(
        self, flow_id: str, next_phase: str, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Advance flow to next phase using V2 architecture.

        Args:
            flow_id: Discovery Flow ID
            next_phase: Target phase name
            context: Request context
        """
        # Delegate to state manager - Generated by CC
        return await self._state_manager.advance_flow_phase(
            flow_id, next_phase, context
        )

    async def get_active_flows(self, context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Get all active flows for the current context.

        Args:
            context: Request context with client/engagement info
        """
        # Delegate to state manager - Generated by CC
        return await self._state_manager.get_active_flows(context)

    async def cleanup_flow(
        self, flow_id: str, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Clean up a flow and all associated data.

        Args:
            flow_id: Discovery Flow ID
            context: Request context
        """
        # Delegate to lifecycle manager - Generated by CC
        return await self._lifecycle_manager.cleanup_flow(flow_id, context)

    async def pause_flow(
        self, flow_id: str, reason: str = "user_requested"
    ) -> Dict[str, Any]:
        """
        Pause a running CrewAI discovery flow at the current node.
        This preserves the flow state and allows resumption from the same point.

        Args:
            flow_id: Discovery Flow ID
            reason: Reason for pausing the flow
        """
        # Delegate to lifecycle manager - Generated by CC
        return await self._lifecycle_manager.pause_flow(flow_id, reason)

    async def resume_flow(
        self, flow_id: str, resume_context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Resume a paused CrewAI discovery flow from the last saved state.
        This continues execution from the exact node where it was paused.

        Args:
            flow_id: Discovery Flow ID
            resume_context: Optional context for resumption (user input, etc.)

        Returns:
            Dict containing resume status and result information

        Raises:
            ValueError: If flow not found
            InvalidFlowStateError: If flow is in a terminal state (deleted, cancelled, completed, failed)
            CrewAIExecutionError: If CrewAI flow initialization or execution fails

        Note:
            Only flows with resumable statuses can be resumed. Terminal statuses
            ['deleted', 'cancelled', 'completed', 'failed'] will raise InvalidFlowStateError.
        """
        # Delegate to lifecycle manager - Generated by CC
        return await self._lifecycle_manager.resume_flow(flow_id, resume_context)

    async def resume_flow_at_phase(
        self, flow_id: str, phase: str, resume_context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Resume a CrewAI discovery flow at a specific phase with optional human input.
        This is for human-in-the-loop scenarios where user provides input to continue.

        Args:
            flow_id: Discovery Flow ID
            phase: Target phase to resume at
            resume_context: Context including human input and phase data
        """
        # Delegate to lifecycle manager - Generated by CC
        return await self._lifecycle_manager.resume_flow_at_phase(
            flow_id, phase, resume_context
        )

    def add_error(
        self, error_message: str, phase: str = None, details: Dict[str, Any] = None
    ):
        """Add error to the flow service for tracking"""
        # Delegate to monitoring module - Generated by CC
        self._monitoring.add_error(error_message, phase, details)

    # ========================================
    # EXECUTION METHODS
    # ========================================

    async def execute_data_import_validation(
        self,
        flow_id: str,
        raw_data: List[Dict[str, Any]],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Execute data import validation phase.
        This method validates imported data and prepares it for field mapping.
        """
        # Delegate to executor module - Generated by CC
        return await self._executor.execute_data_import_validation(
            flow_id, raw_data, client_account_id, engagement_id, user_id, **kwargs
        )

    async def generate_field_mapping_suggestions(
        self,
        flow_id: str,
        validation_result: Dict[str, Any],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Generate field mapping suggestions based on validation results.
        This method analyzes field patterns and suggests mappings to standard schema.
        """
        # Delegate to executor module - Generated by CC
        return await self._executor.generate_field_mapping_suggestions(
            flow_id,
            validation_result,
            client_account_id,
            engagement_id,
            user_id,
            **kwargs,
        )

    async def apply_field_mappings(
        self,
        flow_id: str,
        approved_mappings: Dict[str, str],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Apply approved field mappings to transform data.
        This method applies user-approved field mappings and prepares data for cleansing.
        """
        # Delegate to executor module - Generated by CC
        return await self._executor.apply_field_mappings(
            flow_id,
            approved_mappings,
            client_account_id,
            engagement_id,
            user_id,
            **kwargs,
        )

    async def execute_data_cleansing(
        self,
        flow_id: str,
        field_mappings: Dict[str, str],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Execute data cleansing phase.
        This method cleanses and standardizes data using the applied field mappings.
        """
        # Delegate to executor module - Generated by CC
        return await self._executor.execute_data_cleansing(
            flow_id, field_mappings, client_account_id, engagement_id, user_id, **kwargs
        )

    async def create_discovery_assets(
        self,
        flow_id: str,
        cleaned_data: List[Dict[str, Any]],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Create discovery assets from cleaned data.
        This method creates asset records in the database from cleansed data.
        """
        # Delegate to executor module - Generated by CC
        return await self._executor.create_discovery_assets(
            flow_id, cleaned_data, client_account_id, engagement_id, user_id, **kwargs
        )

    async def execute_analysis_phases(
        self,
        flow_id: str,
        assets: List[Dict[str, Any]],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Execute analysis phases (asset inventory, dependency analysis, tech debt analysis).
        This method runs the final analysis phases on the created assets.
        """
        # Delegate to executor module - Generated by CC
        return await self._executor.execute_analysis_phases(
            flow_id, assets, client_account_id, engagement_id, user_id, **kwargs
        )

    async def execute_flow_phase(
        self,
        flow_id: str,
        phase_name: str,
        phase_input: Dict[str, Any],
        client_account_id: str = None,
        engagement_id: str = None,
        user_id: str = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Generic method to execute any flow phase.
        This method routes to the appropriate phase-specific method.
        """
        # Delegate to executor module - Generated by CC
        return await self._executor.execute_flow_phase(
            flow_id,
            phase_name,
            phase_input,
            client_account_id,
            engagement_id,
            user_id,
            **kwargs,
        )


# Factory function for dependency injection
async def get_crewai_flow_service(
    db: AsyncSession = None, context: Dict[str, Any] = None
) -> CrewAIFlowService:
    """
    Factory function to create CrewAI Flow Service with proper dependencies.
    """
    if not db:
        # Get database session from dependency injection
        async with get_db() as session:
            return CrewAIFlowService(db=session)

    return CrewAIFlowService(db=db)
