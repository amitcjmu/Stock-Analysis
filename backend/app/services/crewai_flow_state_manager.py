"""
CrewAI Flow State Manager

Handles all state management operations for CrewAI flows including:
- Flow state tracking and updates
- Status management
- Progress monitoring
- Data persistence operations

Generated by CC for modularization while maintaining backward compatibility.
"""

import logging
from typing import Any, Dict, List, Optional

from sqlalchemy.ext.asyncio import AsyncSession

from app.services.discovery_flow_service import DiscoveryFlowService

logger = logging.getLogger(__name__)


class CrewAIFlowStateManager:
    """
    Manages state operations for CrewAI flows.

    This class handles all state-related operations including status tracking,
    progress monitoring, and data persistence for CrewAI discovery flows.
    """

    def __init__(self, db: Optional[AsyncSession] = None):
        """
        Initialize the state manager.

        Args:
            db: Optional database session
        """
        self.db = db
        self._discovery_flow_service: Optional[DiscoveryFlowService] = None

    async def _get_discovery_flow_service(
        self, context: Dict[str, Any]
    ) -> DiscoveryFlowService:
        """Get or create discovery flow service with context."""
        if not self._discovery_flow_service:
            # Create a new database session if one wasn't provided
            from app.core.database import AsyncSessionLocal

            if not self.db:
                logger.info(
                    "ğŸ” Creating new database session for V2 Discovery Flow service"
                )
                self.db = AsyncSessionLocal()

            # Create RequestContext from the context dict
            from app.core.context import RequestContext

            request_context = RequestContext(
                client_account_id=context.get("client_account_id"),
                engagement_id=context.get("engagement_id"),
                user_id=context.get("approved_by") or context.get("user_id"),
            )

            self._discovery_flow_service = DiscoveryFlowService(
                self.db, request_context
            )

        return self._discovery_flow_service

    async def get_flow_status(
        self, flow_id: str, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Get comprehensive flow status using V2 architecture.

        Args:
            flow_id: Discovery Flow ID
            context: Request context

        Returns:
            Dict containing comprehensive flow status information
        """
        try:
            logger.info(f"ğŸ“Š Getting flow status: {flow_id}")

            # Get V2 services
            discovery_service = await self._get_discovery_flow_service(context)

            # Get flow from V2 architecture
            flow = await discovery_service.get_flow_by_id(flow_id)
            if not flow:
                return {
                    "status": "not_found",
                    "flow_id": flow_id,
                    "message": "Flow not found in V2 architecture",
                }

            # Get detailed flow summary
            flow_summary = await discovery_service.get_flow_summary(flow_id)

            # Import here to avoid circular dependencies
            try:
                from app.services.crewai_flows.unified_discovery_flow import (
                    UnifiedDiscoveryFlow,
                )

                CREWAI_FLOWS_AVAILABLE = True
                # Use the import to avoid F401
                _ = UnifiedDiscoveryFlow
            except ImportError:
                CREWAI_FLOWS_AVAILABLE = False

            # Get CrewAI flow status if available
            crewai_status = {}
            if CREWAI_FLOWS_AVAILABLE:
                try:
                    # Attempt to get CrewAI flow state
                    crewai_status = {
                        "crewai_available": True,
                        "flow_active": True,  # Placeholder
                    }
                except Exception as e:
                    logger.warning(f"CrewAI status check failed: {e}")
                    crewai_status = {"crewai_available": False, "error": str(e)}

            return {
                "status": "success",
                "flow_id": flow_id,
                "flow_status": flow.status,
                "current_phase": flow.current_phase,
                "progress_percentage": flow.progress_percentage,
                "summary": flow_summary,
                "crewai_status": crewai_status,
                "created_at": flow.created_at.isoformat() if flow.created_at else None,
                "updated_at": flow.updated_at.isoformat() if flow.updated_at else None,
            }

        except Exception as e:
            logger.error(f"âŒ Failed to get flow status {flow_id}: {e}")
            return {
                "status": "error",
                "flow_id": flow_id,
                "error": str(e),
                "message": "Failed to get flow status",
            }

    async def advance_flow_phase(
        self, flow_id: str, next_phase: str, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Advance flow to next phase using V2 architecture.

        Args:
            flow_id: Discovery Flow ID
            next_phase: Target phase name
            context: Request context

        Returns:
            Dict containing phase advancement result
        """
        try:
            logger.info(f"â­ï¸ Advancing flow phase: {flow_id} -> {next_phase}")

            # Get V2 services
            discovery_service = await self._get_discovery_flow_service(context)

            # Advance phase through discovery service
            await discovery_service.update_phase(flow_id, next_phase)
            result = await discovery_service.get_flow_by_id(flow_id)

            logger.info(f"âœ… Flow phase advanced: {flow_id} -> {next_phase}")

            return {
                "status": "success",
                "flow_id": flow_id,
                "next_phase": next_phase,
                "result": {
                    "current_phase": result.current_phase,
                    "progress_percentage": result.progress_percentage,
                    "status": result.status,
                },
            }

        except Exception as e:
            logger.error(f"âŒ Failed to advance flow phase {flow_id}: {e}")
            return {
                "status": "error",
                "flow_id": flow_id,
                "error": str(e),
                "message": "Failed to advance flow phase",
            }

    async def get_active_flows(self, context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Get all active flows for the current context.

        Args:
            context: Request context with client/engagement info

        Returns:
            List of active flow dictionaries
        """
        try:
            logger.info("ğŸ“‹ Getting active flows")

            # Get V2 services
            discovery_service = await self._get_discovery_flow_service(context)

            # Get active flows
            active_flows = await discovery_service.get_active_flows()

            # Convert to response format
            flows_data = []
            for flow in active_flows:
                flows_data.append(
                    {
                        "flow_id": flow.flow_id,
                        "status": flow.status,
                        "current_phase": flow.current_phase,
                        "progress_percentage": flow.progress_percentage,
                        "created_at": (
                            flow.created_at.isoformat() if flow.created_at else None
                        ),
                        "updated_at": (
                            flow.updated_at.isoformat() if flow.updated_at else None
                        ),
                    }
                )

            logger.info(f"âœ… Found {len(flows_data)} active flows")

            return flows_data

        except Exception as e:
            logger.error(f"âŒ Failed to get active flows: {e}")
            return []

    async def update_flow_data(
        self, flow_id: str, data: Dict[str, Any], context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Update flow data in the database.

        Args:
            flow_id: Discovery Flow ID
            data: Data to update
            context: Request context

        Returns:
            Dict containing update result
        """
        try:
            logger.info(f"ğŸ“ Updating flow data: {flow_id}")

            # Get V2 services
            discovery_service = await self._get_discovery_flow_service(context)

            # Update flow data through discovery service
            await discovery_service.update_flow_data(flow_id, data)

            logger.info(f"âœ… Flow data updated: {flow_id}")

            return {
                "status": "success",
                "flow_id": flow_id,
                "updated_fields": list(data.keys()),
            }

        except Exception as e:
            logger.error(f"âŒ Failed to update flow data {flow_id}: {e}")
            return {
                "status": "error",
                "flow_id": flow_id,
                "error": str(e),
                "message": "Failed to update flow data",
            }

    async def validate_flow_state(
        self, flow_id: str, target_state: str, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Validate if a flow can transition to the target state.

        Args:
            flow_id: Discovery Flow ID
            target_state: Target state to validate
            context: Request context

        Returns:
            Dict containing validation result
        """
        try:
            logger.info(
                f"ğŸ” Validating flow state transition: {flow_id} -> {target_state}"
            )

            # Get V2 services
            discovery_service = await self._get_discovery_flow_service(context)

            # Get current flow state
            flow = await discovery_service.get_flow_by_id(flow_id)
            if not flow:
                return {
                    "valid": False,
                    "flow_id": flow_id,
                    "error": "Flow not found",
                }

            # Define terminal statuses that cannot be transitioned from
            terminal_statuses = ["deleted", "cancelled", "completed", "failed"]

            # Check if current state allows transition
            if flow.status in terminal_statuses:
                return {
                    "valid": False,
                    "flow_id": flow_id,
                    "current_state": flow.status,
                    "target_state": target_state,
                    "reason": f"Cannot transition from terminal state: {flow.status}",
                }

            logger.info(f"âœ… Flow state transition valid: {flow_id} -> {target_state}")

            return {
                "valid": True,
                "flow_id": flow_id,
                "current_state": flow.status,
                "target_state": target_state,
            }

        except Exception as e:
            logger.error(f"âŒ Failed to validate flow state {flow_id}: {e}")
            return {
                "valid": False,
                "flow_id": flow_id,
                "error": str(e),
                "message": "Failed to validate flow state",
            }
