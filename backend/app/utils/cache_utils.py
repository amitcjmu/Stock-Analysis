"""
Cache Utilities for AI Force Migration Platform

This module provides reusable utilities for cache operations including:
- ETag generation and validation
- Cache key manipulation
- Performance helpers

Generated by CC (Claude Code)
"""

import hashlib
import json
from typing import Any, Optional, Tuple

from fastapi import Request, Response, status
from fastapi.responses import JSONResponse


def generate_etag(data: Any) -> str:
    """
    Generate a stable ETag for response data.

    Args:
        data: The data to generate an ETag for

    Returns:
        A 32-character ETag string
    """
    try:
        # Create deterministic string representation
        if isinstance(data, dict) or isinstance(data, list):
            data_string = json.dumps(data, sort_keys=True, default=str)
        else:
            data_string = str(data)

        # Generate hash
        return hashlib.sha256(data_string.encode()).hexdigest()[:32]
    except Exception:
        # Fallback to current timestamp hash
        import time

        return hashlib.sha256(str(time.time()).encode()).hexdigest()[:32]


def check_etag_match(request: Request, current_etag: str) -> bool:
    """
    Check if the request's If-None-Match header matches the current ETag.

    Args:
        request: The FastAPI request object
        current_etag: The current ETag to compare against

    Returns:
        True if ETags match (client has current version)
    """
    if_none_match = request.headers.get("If-None-Match")
    if not if_none_match:
        return False

    # Remove quotes from header value
    if_none_match = if_none_match.strip('"')

    return if_none_match == current_etag


def create_etag_response(
    data: Any,
    cache_control: str = "private, max-age=300",
    extra_headers: Optional[dict] = None,
) -> JSONResponse:
    """
    Create a JSON response with ETag headers.

    Args:
        data: The response data
        cache_control: Cache-Control header value
        extra_headers: Additional headers to include

    Returns:
        JSONResponse with ETag headers
    """
    etag = generate_etag(data)

    headers = {
        "ETag": f'"{etag}"',
        "Cache-Control": cache_control,
        "Vary": "Accept-Encoding",
    }

    if extra_headers:
        headers.update(extra_headers)

    response = JSONResponse(content=data, headers=headers)
    return response


def handle_conditional_request(
    request: Request,
    data: Any,
    cache_control: str = "private, max-age=300",
    extra_headers: Optional[dict] = None,
) -> Tuple[JSONResponse, bool]:
    """
    Handle conditional request with ETag support.

    Args:
        request: The FastAPI request object
        data: The response data
        cache_control: Cache-Control header value
        extra_headers: Additional headers to include

    Returns:
        Tuple of (response, was_not_modified)
    """
    etag = generate_etag(data)

    # Check for conditional request
    if check_etag_match(request, etag):
        # Return 304 Not Modified
        response = Response(status_code=status.HTTP_304_NOT_MODIFIED)
        response.headers["ETag"] = f'"{etag}"'
        response.headers["Cache-Control"] = cache_control
        return response, True

    # Return full response with ETag
    response = create_etag_response(data, cache_control, extra_headers)
    return response, False


def parse_cache_control_header(header_value: str) -> dict:
    """
    Parse Cache-Control header into directive dictionary.

    Args:
        header_value: The Cache-Control header value

    Returns:
        Dictionary of cache directives
    """
    directives = {}

    if not header_value:
        return directives

    for directive in header_value.split(","):
        directive = directive.strip()
        if "=" in directive:
            key, value = directive.split("=", 1)
            try:
                # Try to parse as integer for max-age, etc.
                directives[key.strip()] = int(value.strip())
            except ValueError:
                directives[key.strip()] = value.strip()
        else:
            directives[directive] = True

    return directives


def should_cache_response(response: Response) -> bool:
    """
    Determine if a response should be cached based on headers and status.

    Args:
        response: The response object

    Returns:
        True if response should be cached
    """
    # Only cache successful responses
    if response.status_code != 200:
        return False

    # Check Cache-Control header
    cache_control = response.headers.get("Cache-Control", "")
    directives = parse_cache_control_header(cache_control)

    # Don't cache if explicitly told not to
    if directives.get("no-store") or directives.get("no-cache"):
        return False

    # Don't cache if private and we're a shared cache
    # (This would need configuration to determine cache type)

    return True


__all__ = [
    "generate_etag",
    "check_etag_match",
    "create_etag_response",
    "handle_conditional_request",
    "parse_cache_control_header",
    "should_cache_response",
]
