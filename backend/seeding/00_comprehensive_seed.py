#!/usr/bin/env python3
"""
Comprehensive Data Seeding Script - Generated by CC

This script creates realistic test data across all models with proper relationships,
including multi-tenant scenarios and vector embeddings for agent patterns.

Usage:
    python seeding/00_comprehensive_seed.py [--cleanup] [--tenants=2]
"""

import argparse
import asyncio
import random
import sys
import uuid
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import List

# Add the parent directory to sys.path
sys.path.append(str(Path(__file__).parent.parent))

from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db_session
from app.core.demo_constants import TEST_TENANT_1, TEST_TENANT_2


# Multi-tenant test data configuration
TENANT_CONFIG = {
    TEST_TENANT_1: {
        "name": "TechCorp Solutions",
        "domain": "techcorp.com",
        "industry": "Technology",
        "size": "Enterprise",
        "users": {
            "admin": uuid.UUID("11111111-0001-0000-0000-000000000001"),
            "manager": uuid.UUID("11111111-0002-0000-0000-000000000002"),
            "analyst": uuid.UUID("11111111-0003-0000-0000-000000000003"),
        },
        "engagement_id": uuid.UUID("11111111-eeee-0000-0000-000000000001"),
    },
    TEST_TENANT_2: {
        "name": "Global Retail Inc",
        "domain": "globalretail.com",
        "industry": "Retail",
        "size": "Large",
        "users": {
            "admin": uuid.UUID("22222222-0001-0000-0000-000000000001"),
            "manager": uuid.UUID("22222222-0002-0000-0000-000000000002"),
            "analyst": uuid.UUID("22222222-0003-0000-0000-000000000003"),
        },
        "engagement_id": uuid.UUID("22222222-eeee-0000-0000-000000000002"),
    },
}

# Sample data patterns for realistic content
AGENT_PATTERNS = [
    {
        "type": "field_mapping_suggestion",
        "patterns": [
            "Server hostname maps to asset_name with 95% confidence",
            "Application ID should map to business_app_id",
            "IP address field contains both IPv4 and IPv6 formats",
            "Department code needs transformation from numeric to text",
        ],
    },
    {
        "type": "risk_pattern",
        "patterns": [
            "Detected 15 servers running unsupported OS versions",
            "Found exposed database ports on public-facing servers",
            "Multiple applications sharing the same service account",
            "Critical systems without documented DR procedures",
        ],
    },
    {
        "type": "optimization_opportunity",
        "patterns": [
            "Consolidate 8 duplicate applications across departments",
            "Migrate 20 underutilized servers to cloud",
            "Implement auto-scaling for variable workload applications",
            "Replace manual processes with automated workflows",
        ],
    },
    {
        "type": "anomaly_detection",
        "patterns": [
            "Unusual spike in data import failures on weekends",
            "Asset count mismatch between CMDB and discovery",
            "Unexpected network dependencies for isolated systems",
            "Abnormal resource utilization patterns detected",
        ],
    },
]

# Sample LLM prompts and responses
LLM_INTERACTIONS = [
    {
        "feature": "field_mapping",
        "prompt": "Map the source field 'srv_hostname' to target schema",
        "response": "Based on analysis, 'srv_hostname' should map to 'asset_name' field",
        "tokens": {"input": 25, "output": 35},
    },
    {
        "feature": "asset_analysis",
        "prompt": "Analyze dependencies for application APP-001",
        "response": "Application APP-001 has 5 direct dependencies and 12 transitive dependencies",
        "tokens": {"input": 30, "output": 45},
    },
    {
        "feature": "risk_assessment",
        "prompt": "Identify security risks in the current infrastructure",
        "response": "Found 3 critical risks: exposed ports, outdated SSL certificates, weak passwords",
        "tokens": {"input": 35, "output": 55},
    },
]


def generate_dummy_embedding() -> List[float]:
    """Generate a normalized dummy embedding vector"""
    vector = [random.gauss(0, 0.5) for _ in range(1536)]
    magnitude = sum(x * x for x in vector) ** 0.5
    if magnitude > 0:
        vector = [x / magnitude for x in vector]
    return vector


async def cleanup_existing_data(session: AsyncSession):
    """Clean up existing test data before seeding"""
    print("üßπ Cleaning up existing test data...")

    # Tables to clean in reverse dependency order
    tables_to_clean = [
        "agent_discovered_patterns",
        "agent_performance_daily",
        "agent_task_history",
        "llm_usage_logs",
        "asset_dependencies",
        "assets",
        "import_field_mappings",
        "custom_target_fields",
        "raw_import_records",
        "data_imports",
        "crewai_flow_state_extensions",
        "assessment_flow_states",
        "assessment_flows",
        "discovery_flows",
        "collection_flows",
        "flow_deletion_audit",
        "platform_credentials",
        "assessments",
        "sixr_analyses",
        "feedback",
        "tags",
        "user_profiles",
        "users",
        "engagements",
        "client_accounts",
    ]

    for table in tables_to_clean:
        try:
            await session.execute(
                text(
                    f"DELETE FROM migration.{table} WHERE client_account_id IN :tenant_ids"
                ),
                {"tenant_ids": tuple(str(tid) for tid in TENANT_CONFIG.keys())},
            )
            print(f"  ‚úì Cleaned {table}")
        except Exception:
            # Some tables might not have client_account_id
            try:
                if table in ["users", "engagements", "client_accounts"]:
                    await session.execute(
                        text(f"DELETE FROM migration.{table} WHERE id IN :ids"),
                        {
                            "ids": tuple(
                                str(config["users"]["admin"])
                                for config in TENANT_CONFIG.values()
                            )
                        },
                    )
                    print(f"  ‚úì Cleaned {table}")
            except Exception as e2:
                print(f"  ‚ö†Ô∏è  Skipped {table}: {str(e2)}")

    await session.commit()
    print("‚úÖ Cleanup completed\n")


async def seed_core_entities(session: AsyncSession):
    """Seed core entities: client accounts, users, engagements"""
    print("üå± Seeding core entities...")

    for tenant_id, config in TENANT_CONFIG.items():
        # Create client account
        await session.execute(
            text(
                """
                INSERT INTO migration.client_accounts (
                    id, company_name, company_domain, industry,
                    company_size, primary_contact_name, primary_contact_email,
                    is_active, created_at, updated_at
                ) VALUES (
                    :id, :name, :domain, :industry,
                    :size, :contact_name, :contact_email,
                    true, NOW(), NOW()
                )
                ON CONFLICT (id) DO NOTHING
            """
            ),
            {
                "id": str(tenant_id),
                "name": config["name"],
                "domain": config["domain"],
                "industry": config["industry"],
                "size": config["size"],
                "contact_name": f"{config['name']} Admin",
                "contact_email": f"admin@{config['domain']}",
            },
        )

        # Create engagement
        await session.execute(
            text(
                """
                INSERT INTO migration.engagements (
                    id, client_account_id, name, engagement_type,
                    start_date, status, created_at, updated_at
                ) VALUES (
                    :id, :client_id, :name, 'MIGRATION_ASSESSMENT',
                    :start_date, 'ACTIVE', NOW(), NOW()
                )
                ON CONFLICT (id) DO NOTHING
            """
            ),
            {
                "id": str(config["engagement_id"]),
                "client_id": str(tenant_id),
                "name": f"{config['name']} Cloud Migration 2025",
                "start_date": datetime.now(timezone.utc) - timedelta(days=30),
            },
        )

        # Create users for this tenant
        for role, user_id in config["users"].items():
            await session.execute(
                text(
                    """
                    INSERT INTO migration.users (
                        id, email, username, full_name,
                        is_active, is_verified, hashed_password,
                        default_client_account_id, default_engagement_id,
                        created_at, updated_at
                    ) VALUES (
                        :id, :email, :username, :full_name,
                        true, true, :password,
                        :client_id, :engagement_id,
                        NOW(), NOW()
                    )
                    ON CONFLICT (id) DO NOTHING
                """
                ),
                {
                    "id": str(user_id),
                    "email": f"{role}@{config['domain']}",
                    "username": f"{config['domain'].split('.')[0]}_{role}",
                    "full_name": f"{config['name']} {role.title()}",
                    "password": "$2b$12$dummy.hashed.password.for.testing",
                    "client_id": str(tenant_id),
                    "engagement_id": str(config["engagement_id"]),
                },
            )

            # Create user profile
            await session.execute(
                text(
                    """
                    INSERT INTO migration.user_profiles (
                        id, user_id, client_account_id, role,
                        is_active, created_at, updated_at
                    ) VALUES (
                        :id, :user_id, :client_id, :role,
                        true, NOW(), NOW()
                    )
                    ON CONFLICT (id) DO NOTHING
                """
                ),
                {
                    "id": str(uuid.uuid4()),
                    "user_id": str(user_id),
                    "client_id": str(tenant_id),
                    "role": role.upper(),
                },
            )

    await session.commit()
    print("‚úÖ Core entities seeded\n")


async def seed_discovery_flows(session: AsyncSession):
    """Seed discovery flows with various states"""
    print("üå± Seeding discovery flows...")

    flow_states = [
        "initialization",
        "data_import",
        "field_mapping",
        "asset_analysis",
        "complete",
        "failed",
    ]

    for tenant_id, config in TENANT_CONFIG.items():
        for i, state in enumerate(flow_states[:4]):  # Create 4 flows per tenant
            flow_id = uuid.uuid4()
            progress = min(i * 25 + random.randint(0, 20), 100)

            await session.execute(
                text(
                    """
                    INSERT INTO migration.discovery_flows (
                        id, client_account_id, engagement_id, flow_name,
                        flow_type, status, current_phase, progress_percentage,
                        created_by, created_at, updated_at
                    ) VALUES (
                        :id, :client_id, :engagement_id, :name,
                        'STANDARD', :status, :phase, :progress,
                        :created_by, NOW(), NOW()
                    )
                """
                ),
                {
                    "id": str(flow_id),
                    "client_id": str(tenant_id),
                    "engagement_id": str(config["engagement_id"]),
                    "name": f"{state.title()} Discovery Flow",
                    "status": "completed" if state == "complete" else "in_progress",
                    "phase": f"{state}_phase",
                    "progress": progress,
                    "created_by": str(config["users"]["analyst"]),
                },
            )

            # Create flow state extension
            await session.execute(
                text(
                    """
                    INSERT INTO migration.crewai_flow_state_extensions (
                        id, flow_id, flow_type, client_account_id, engagement_id,
                        master_flow_id, parent_flow_id, state_data,
                        created_at, updated_at
                    ) VALUES (
                        :id, :flow_id, 'discovery', :client_id, :engagement_id,
                        :master_id, NULL, :state_data,
                        NOW(), NOW()
                    )
                """
                ),
                {
                    "id": str(uuid.uuid4()),
                    "flow_id": str(flow_id),
                    "client_id": str(tenant_id),
                    "engagement_id": str(config["engagement_id"]),
                    "master_id": str(uuid.uuid4()),
                    "state_data": {
                        "phase": state,
                        "progress": progress,
                        "metrics": {
                            "assets_discovered": random.randint(50, 200),
                            "fields_mapped": random.randint(20, 100),
                        },
                    },
                },
            )

    await session.commit()
    print("‚úÖ Discovery flows seeded\n")


async def seed_agent_data(session: AsyncSession):
    """Seed agent-related data: tasks, patterns, performance"""
    print("üå± Seeding agent data...")

    agents = [
        "discovery_agent",
        "field_mapper_agent",
        "asset_analyzer_agent",
        "risk_assessor_agent",
    ]
    task_statuses = ["completed", "failed", "in_progress"]

    for tenant_id, config in TENANT_CONFIG.items():
        # Seed agent task history
        for _ in range(20):  # 20 tasks per tenant
            agent = random.choice(agents)
            status = random.choice(task_statuses)
            duration = random.randint(1000, 60000)  # 1s to 60s

            await session.execute(
                text(
                    """
                    INSERT INTO migration.agent_task_history (
                        id, client_account_id, engagement_id,
                        agent_name, task_type, task_description,
                        status, duration_ms, input_data, output_data,
                        error_message, created_at, completed_at
                    ) VALUES (
                        :id, :client_id, :engagement_id,
                        :agent, :task_type, :description,
                        :status, :duration, :input, :output,
                        :error, NOW() - INTERVAL '1 hour', NOW()
                    )
                """
                ),
                {
                    "id": str(uuid.uuid4()),
                    "client_id": str(tenant_id),
                    "engagement_id": str(config["engagement_id"]),
                    "agent": agent,
                    "task_type": f"{agent.split('_')[0]}_task",
                    "description": f"Process {random.choice(['assets', 'fields', 'data', 'risks'])}",
                    "status": status,
                    "duration": duration,
                    "input": {"items": random.randint(10, 100)},
                    "output": {"processed": random.randint(5, 95)}
                    if status == "completed"
                    else {},
                    "error": "Task timeout" if status == "failed" else None,
                },
            )

        # Seed agent discovered patterns with embeddings
        for pattern_type_data in AGENT_PATTERNS:
            for pattern_text in pattern_type_data["patterns"][
                :2
            ]:  # 2 patterns per type
                pattern_id = uuid.uuid4()

                await session.execute(
                    text(
                        """
                        INSERT INTO migration.agent_discovered_patterns (
                            id, client_account_id, engagement_id,
                            pattern_id, pattern_type, pattern_name,
                            pattern_description, discovered_by_agent,
                            confidence_score, evidence_count, times_referenced,
                            pattern_data, embedding, insight_type,
                            created_at, updated_at
                        ) VALUES (
                            :id, :client_id, :engagement_id,
                            :pattern_id, :pattern_type, :name,
                            :description, :agent,
                            :confidence, :evidence, :references,
                            :data, :embedding, :insight_type,
                            NOW(), NOW()
                        )
                    """
                    ),
                    {
                        "id": str(pattern_id),
                        "client_id": str(tenant_id),
                        "engagement_id": str(config["engagement_id"]),
                        "pattern_id": f"PAT-{pattern_id.hex[:8]}",
                        "pattern_type": pattern_type_data["type"],
                        "name": pattern_text[:50],
                        "description": pattern_text,
                        "agent": random.choice(agents),
                        "confidence": round(random.uniform(0.7, 0.95), 2),
                        "evidence": random.randint(5, 50),
                        "references": random.randint(0, 20),
                        "data": {
                            "source": "automated_discovery",
                            "context": {"phase": "analysis"},
                        },
                        "embedding": generate_dummy_embedding(),
                        "insight_type": pattern_type_data["type"],
                    },
                )

        # Seed agent performance daily
        for agent in agents:
            for days_ago in range(7):  # Last 7 days
                await session.execute(
                    text(
                        """
                        INSERT INTO migration.agent_performance_daily (
                            id, client_account_id, engagement_id,
                            agent_name, performance_date, total_tasks,
                            successful_tasks, failed_tasks, avg_duration_ms,
                            total_tokens_used, avg_confidence_score,
                            created_at, updated_at
                        ) VALUES (
                            :id, :client_id, :engagement_id,
                            :agent, :date, :total,
                            :success, :failed, :avg_duration,
                            :tokens, :confidence,
                            NOW(), NOW()
                        )
                    """
                    ),
                    {
                        "id": str(uuid.uuid4()),
                        "client_id": str(tenant_id),
                        "engagement_id": str(config["engagement_id"]),
                        "agent": agent,
                        "date": (datetime.now().date() - timedelta(days=days_ago)),
                        "total": random.randint(50, 200),
                        "success": random.randint(40, 180),
                        "failed": random.randint(0, 20),
                        "avg_duration": random.randint(2000, 10000),
                        "tokens": random.randint(5000, 50000),
                        "confidence": round(random.uniform(0.75, 0.92), 2),
                    },
                )

    await session.commit()
    print("‚úÖ Agent data seeded\n")


async def seed_llm_usage(session: AsyncSession):
    """Seed LLM usage logs"""
    print("üå± Seeding LLM usage logs...")

    models = ["gpt-4", "gpt-3.5-turbo", "claude-2", "llama-2-70b"]

    for tenant_id, config in TENANT_CONFIG.items():
        for interaction in LLM_INTERACTIONS * 3:  # Create multiple entries
            await session.execute(
                text(
                    """
                    INSERT INTO migration.llm_usage_logs (
                        id, client_account_id, engagement_id,
                        user_id, model_name, endpoint, feature_context,
                        prompt_tokens, completion_tokens, total_tokens,
                        input_cost, output_cost, total_cost,
                        prompt_text, completion_text, success,
                        created_at
                    ) VALUES (
                        :id, :client_id, :engagement_id,
                        :user_id, :model, :endpoint, :feature,
                        :prompt_tokens, :completion_tokens, :total_tokens,
                        :input_cost, :output_cost, :total_cost,
                        :prompt, :response, true,
                        NOW() - INTERVAL :hours_ago
                    )
                """
                ),
                {
                    "id": str(uuid.uuid4()),
                    "client_id": str(tenant_id),
                    "engagement_id": str(config["engagement_id"]),
                    "user_id": str(random.choice(list(config["users"].values()))),
                    "model": random.choice(models),
                    "endpoint": "/api/v1/agent/process",
                    "feature": interaction["feature"],
                    "prompt_tokens": interaction["tokens"]["input"],
                    "completion_tokens": interaction["tokens"]["output"],
                    "total_tokens": sum(interaction["tokens"].values()),
                    "input_cost": interaction["tokens"]["input"] * 0.00003,
                    "output_cost": interaction["tokens"]["output"] * 0.00006,
                    "total_cost": (
                        interaction["tokens"]["input"] * 0.00003
                        + interaction["tokens"]["output"] * 0.00006
                    ),
                    "prompt": interaction["prompt"],
                    "response": interaction["response"],
                    "hours_ago": f"{random.randint(1, 168)} hours",
                },
            )

    await session.commit()
    print("‚úÖ LLM usage logs seeded\n")


async def seed_assets_and_dependencies(session: AsyncSession):
    """Seed assets and their dependencies"""
    print("üå± Seeding assets and dependencies...")

    asset_types = ["SERVER", "APPLICATION", "DATABASE", "NETWORK_DEVICE"]
    environments = ["PRODUCTION", "STAGING", "DEVELOPMENT", "QA"]

    for tenant_id, config in TENANT_CONFIG.items():
        assets = []

        # Create assets
        for i in range(50):  # 50 assets per tenant
            asset_id = uuid.uuid4()
            asset_type = random.choice(asset_types)

            await session.execute(
                text(
                    """
                    INSERT INTO migration.assets (
                        id, client_account_id, engagement_id,
                        asset_name, asset_type, environment,
                        business_criticality, technical_details,
                        discovery_source, created_at, updated_at
                    ) VALUES (
                        :id, :client_id, :engagement_id,
                        :name, :type, :env,
                        :criticality, :details,
                        'AUTOMATED_DISCOVERY', NOW(), NOW()
                    )
                """
                ),
                {
                    "id": str(asset_id),
                    "client_id": str(tenant_id),
                    "engagement_id": str(config["engagement_id"]),
                    "name": f"{asset_type}-{i:03d}",
                    "type": asset_type,
                    "env": random.choice(environments),
                    "criticality": random.choice(["CRITICAL", "HIGH", "MEDIUM", "LOW"]),
                    "details": {
                        "os": "Linux" if asset_type == "SERVER" else None,
                        "version": f"v{random.randint(1, 10)}.{random.randint(0, 9)}",
                        "location": random.choice(
                            ["datacenter-1", "cloud-aws", "cloud-azure"]
                        ),
                    },
                },
            )
            assets.append(asset_id)

        # Create dependencies between assets
        for i, asset_id in enumerate(assets[:20]):  # Create dependencies for first 20
            if i > 0:  # Can't depend on nothing
                num_deps = random.randint(1, 3)
                for _ in range(num_deps):
                    depends_on = random.choice(assets[:i])  # Depend on earlier assets

                    await session.execute(
                        text(
                            """
                            INSERT INTO migration.asset_dependencies (
                                id, asset_id, depends_on_asset_id,
                                dependency_type, description,
                                created_at, updated_at
                            ) VALUES (
                                :id, :asset_id, :depends_on,
                                :type, :description,
                                NOW(), NOW()
                            )
                            ON CONFLICT DO NOTHING
                        """
                        ),
                        {
                            "id": str(uuid.uuid4()),
                            "asset_id": str(asset_id),
                            "depends_on": str(depends_on),
                            "type": random.choice(
                                ["RUNTIME", "DATABASE", "API", "NETWORK"]
                            ),
                            "description": "Auto-discovered dependency",
                        },
                    )

    await session.commit()
    print("‚úÖ Assets and dependencies seeded\n")


async def seed_comprehensive_data(cleanup: bool = False, num_tenants: int = 2):
    """Main seeding function"""
    print("üöÄ Starting comprehensive data seeding...\n")

    # Only use the configured test tenants
    if num_tenants > 2:
        print("‚ö†Ô∏è  Only 2 test tenants are configured. Using both.")
        num_tenants = 2

    async with get_db_session() as session:
        try:
            if cleanup:
                await cleanup_existing_data(session)

            # Seed data in dependency order
            await seed_core_entities(session)
            await seed_discovery_flows(session)
            await seed_agent_data(session)
            await seed_llm_usage(session)
            await seed_assets_and_dependencies(session)

            # Final statistics
            print("\nüìä Seeding Statistics:")
            for table in [
                "client_accounts",
                "users",
                "discovery_flows",
                "assets",
                "agent_discovered_patterns",
            ]:
                result = await session.execute(
                    text(f"SELECT COUNT(*) FROM migration.{table}")
                )
                count = result.scalar()
                print(f"  - {table}: {count} records")

            print("\n‚úÖ Comprehensive data seeding completed successfully!")

        except Exception as e:
            print(f"\n‚ùå Error during seeding: {e}")
            await session.rollback()
            raise


async def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="Seed comprehensive test data for multi-tenant scenarios"
    )
    parser.add_argument(
        "--cleanup",
        action="store_true",
        help="Clean existing test data before seeding",
    )
    parser.add_argument(
        "--tenants",
        type=int,
        default=2,
        help="Number of tenants to create (max 2)",
    )

    args = parser.parse_args()

    try:
        await seed_comprehensive_data(
            cleanup=args.cleanup,
            num_tenants=args.tenants,
        )
    except KeyboardInterrupt:
        print("\n‚ùå Seeding interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Seeding failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
