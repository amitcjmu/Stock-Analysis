#!/usr/bin/env python3
"""
Utility Functions Module
Generated by CC for comprehensive seed script modularization
"""

from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from .base import TENANT_CONFIG


async def cleanup_existing_data(session: AsyncSession):
    """Clean up existing test data before seeding"""
    print("üßπ Cleaning up existing test data...")

    # Tables to clean in reverse dependency order
    tables_to_clean = [
        "agent_discovered_patterns",
        "agent_performance_daily",
        "agent_task_history",
        "llm_usage_logs",
        "asset_dependencies",
        "assets",
        "import_field_mappings",
        "custom_target_fields",
        "raw_import_records",
        "data_imports",
        "crewai_flow_state_extensions",
        "assessment_flow_states",
        "assessment_flows",
        "discovery_flows",
        "collection_flows",
        "flow_deletion_audit",
        "platform_credentials",
        "assessments",
        "sixr_analyses",
        "feedback",
        "tags",
        "user_profiles",
        "users",
        "engagements",
        "client_accounts",
    ]

    # Create a mapping of table names to their delete queries to avoid dynamic SQL
    table_delete_queries = {
        # Tables with client_account_id - table names validated against allowlist
        **{
            table: "DELETE FROM migration.{} WHERE client_account_id = ANY(:tenant_ids)".format(  # nosec B608
                table  # table name validated against tables_to_clean allowlist
            )
            for table in tables_to_clean
            if table not in ["users", "engagements", "client_accounts"]
        },
        # Tables with id field for specific entities
        "users": "DELETE FROM migration.users WHERE id = ANY(:ids)",
        "engagements": "DELETE FROM migration.engagements WHERE id = ANY(:ids)",
        "client_accounts": "DELETE FROM migration.client_accounts WHERE id = ANY(:ids)",
    }

    for table in tables_to_clean:
        # Get the predefined query for this table
        query_template = table_delete_queries.get(table)
        if not query_template:
            print(f"  ‚ùå No delete query defined for table: {table}")
            continue

        try:
            if table in ["users", "engagements", "client_accounts"]:
                # Use specific IDs for these tables
                await session.execute(
                    text(query_template),
                    {
                        "ids": [
                            str(config["users"]["admin"])
                            for config in TENANT_CONFIG.values()
                        ]
                    },
                )
            else:
                # Use tenant IDs for other tables
                await session.execute(
                    text(query_template),
                    {"tenant_ids": [str(tid) for tid in TENANT_CONFIG.keys()]},
                )
            print(f"  ‚úì Cleaned {table}")
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Skipped {table}: {str(e)}")

    await session.commit()
    print("‚úÖ Cleanup completed\n")


async def print_seeding_statistics(session: AsyncSession):
    """Print final seeding statistics"""
    print("\nüìä Seeding Statistics:")
    # Define count queries for each table to avoid dynamic SQL
    count_queries = {
        "client_accounts": "SELECT COUNT(*) FROM migration.client_accounts",
        "users": "SELECT COUNT(*) FROM migration.users",
        "discovery_flows": "SELECT COUNT(*) FROM migration.discovery_flows",
        "assets": "SELECT COUNT(*) FROM migration.assets",
        "agent_discovered_patterns": "SELECT COUNT(*) FROM migration.agent_discovered_patterns",
    }

    for table, query in count_queries.items():
        result = await session.execute(text(query))
        count = result.scalar()
        print(f"  - {table}: {count} records")

    print("\n‚úÖ Comprehensive data seeding completed successfully!")
