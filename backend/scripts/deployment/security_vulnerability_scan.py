#!/usr/bin/env python3
"""
Security Vulnerability Scanner for Master Flow Orchestrator
Phase 6: Day 9 - Security Vulnerability Scan (MFO-097)

This script performs comprehensive security vulnerability scanning of the
Master Flow Orchestrator deployment to identify potential security issues.
"""

import os
import sys
import asyncio
import logging
import json
import subprocess
import aiohttp
import ssl
import socket
from datetime import datetime
from typing import Dict, Any, List, Optional, Tuple
from pathlib import Path
import re
import hashlib

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('security_scan.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class SecurityVulnerabilityScanner:
    """Performs comprehensive security vulnerability scanning"""
    
    def __init__(self):
        self.scan_id = f"security_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.base_path = Path(__file__).parent.parent.parent
        self.results_path = self.base_path / "security_reports"
        self.results_path.mkdir(parents=True, exist_ok=True)
        
        # Security scan configuration
        self.config = {
            "backend_url": os.getenv("BACKEND_URL", "http://localhost:8001"),
            "frontend_url": os.getenv("FRONTEND_URL", "http://localhost:3001"),
            "timeout": 30,
            "max_concurrent_scans": 10,
            "vulnerability_threshold": "medium",  # low, medium, high, critical
        }
        
        # Vulnerability categories
        self.vulnerability_categories = [
            "authentication",
            "authorization",
            "injection",
            "xss",
            "csrf",
            "information_disclosure",
            "insecure_configuration",
            "dependency_vulnerabilities",
            "ssl_tls",
            "headers_security",
            "input_validation",
            "session_management"
        ]
        
        # Scan results
        self.scan_results = {
            "scan_id": self.scan_id,
            "start_time": datetime.now().isoformat(),
            "configuration": self.config,
            "vulnerabilities": [],
            "summary": {
                "total_vulnerabilities": 0,
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "info": 0
            },
            "scans_performed": {
                "api_security": False,
                "authentication": False,
                "authorization": False,
                "input_validation": False,
                "sql_injection": False,
                "xss": False,
                "csrf": False,
                "dependency_scan": False,
                "ssl_tls": False,
                "headers": False,
                "configuration": False
            },
            "recommendations": [],
            "compliance": {
                "owasp_top_10": [],
                "nist": [],
                "iso27001": []
            }
        }
        
        logger.info(f"üîí Starting security vulnerability scan: {self.scan_id}")
    
    async def run_security_scan(self) -> bool:
        """
        Run comprehensive security vulnerability scan
        Task: MFO-097
        """
        try:
            logger.info("=" * 80)
            logger.info("üîí SECURITY VULNERABILITY SCAN - MASTER FLOW ORCHESTRATOR")
            logger.info("=" * 80)
            
            # Phase 1: Pre-scan validation
            if not await self._pre_scan_validation():
                return False
            
            # Phase 2: API Security Testing
            await self._scan_api_security()
            
            # Phase 3: Authentication & Authorization Testing
            await self._scan_authentication_authorization()
            
            # Phase 4: Input Validation Testing
            await self._scan_input_validation()
            
            # Phase 5: Injection Attack Testing
            await self._scan_injection_attacks()
            
            # Phase 6: XSS & CSRF Testing
            await self._scan_xss_csrf()
            
            # Phase 7: Dependency Vulnerability Scan
            await self._scan_dependencies()
            
            # Phase 8: SSL/TLS Configuration
            await self._scan_ssl_tls()
            
            # Phase 9: Security Headers
            await self._scan_security_headers()
            
            # Phase 10: Configuration Security
            await self._scan_configuration_security()
            
            # Phase 11: Generate security report
            await self._generate_security_report()
            
            # Determine pass/fail based on critical/high vulnerabilities
            critical_high_count = self.scan_results["summary"]["critical"] + self.scan_results["summary"]["high"]
            
            if critical_high_count == 0:
                logger.info("‚úÖ Security vulnerability scan PASSED!")
                return True
            else:
                logger.error(f"‚ùå Security vulnerability scan FAILED - {critical_high_count} critical/high vulnerabilities found")
                return False
            
        except Exception as e:
            logger.error(f"‚ùå Security scan failed: {e}")
            await self._handle_scan_failure(e)
            return False
    
    async def _pre_scan_validation(self) -> bool:
        """Validate system availability before scanning"""
        logger.info("üìã Phase 1: Pre-scan validation")
        
        try:
            # Check system availability
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{self.config['backend_url']}/health",
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status != 200:
                        logger.error(f"‚ùå Backend not available: {response.status}")
                        return False
            
            # Check frontend availability
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{self.config['frontend_url']}",
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status >= 500:
                        logger.error(f"‚ùå Frontend not available: {response.status}")
                        return False
            
            logger.info("‚úÖ Pre-scan validation completed")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Pre-scan validation failed: {e}")
            return False
    
    async def _scan_api_security(self) -> None:
        """Scan API security vulnerabilities"""
        logger.info("üîç Phase 2: API Security Testing")
        
        try:
            self.scan_results["scans_performed"]["api_security"] = True
            
            # Test endpoints without authentication
            endpoints_to_test = [
                "/api/v1/flows",
                "/api/v1/master-flows/active",
                "/api/v1/flows/analytics",
                "/api/v1/admin/users"
            ]
            
            async with aiohttp.ClientSession() as session:
                for endpoint in endpoints_to_test:
                    await self._test_endpoint_security(session, endpoint)
            
            # Test rate limiting
            await self._test_rate_limiting()
            
            # Test HTTP methods
            await self._test_http_methods()
            
            logger.info("‚úÖ API security testing completed")
            
        except Exception as e:
            logger.error(f"‚ùå API security testing failed: {e}")
            self._add_vulnerability(
                "API Security Testing Error",
                "high",
                f"Failed to complete API security testing: {e}",
                "api_security"
            )
    
    async def _test_endpoint_security(self, session: aiohttp.ClientSession, endpoint: str) -> None:
        """Test endpoint security"""
        try:
            url = f"{self.config['backend_url']}{endpoint}"
            
            # Test without authentication
            async with session.get(url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                if response.status == 200:
                    self._add_vulnerability(
                        f"Unauthenticated Access to {endpoint}",
                        "high",
                        f"Endpoint {endpoint} is accessible without authentication",
                        "authentication",
                        {"endpoint": endpoint, "status": response.status}
                    )
                elif response.status == 401 or response.status == 403:
                    # This is expected and good
                    pass
                else:
                    self._add_vulnerability(
                        f"Unexpected Response from {endpoint}",
                        "medium",
                        f"Endpoint {endpoint} returned unexpected status {response.status}",
                        "api_security",
                        {"endpoint": endpoint, "status": response.status}
                    )
            
        except Exception as e:
            logger.debug(f"Endpoint test error for {endpoint}: {e}")
    
    async def _test_rate_limiting(self) -> None:
        """Test rate limiting implementation"""
        try:
            logger.info("üîç Testing rate limiting...")
            
            async with aiohttp.ClientSession() as session:
                url = f"{self.config['backend_url']}/api/v1/health"
                
                # Send rapid requests
                requests_sent = 0
                rate_limited = False
                
                for i in range(100):  # Send 100 requests rapidly
                    try:
                        async with session.get(url, timeout=aiohttp.ClientTimeout(total=1)) as response:
                            requests_sent += 1
                            if response.status == 429:  # Too Many Requests
                                rate_limited = True
                                break
                    except:
                        pass
                
                if not rate_limited and requests_sent >= 50:
                    self._add_vulnerability(
                        "No Rate Limiting Detected",
                        "medium",
                        f"Sent {requests_sent} requests without rate limiting",
                        "api_security"
                    )
                
        except Exception as e:
            logger.debug(f"Rate limiting test error: {e}")
    
    async def _test_http_methods(self) -> None:
        """Test HTTP methods security"""
        try:
            logger.info("üîç Testing HTTP methods...")
            
            dangerous_methods = ["TRACE", "OPTIONS", "DELETE", "PUT", "PATCH"]
            
            async with aiohttp.ClientSession() as session:
                for method in dangerous_methods:
                    try:
                        async with session.request(
                            method,
                            f"{self.config['backend_url']}/api/v1/flows",
                            timeout=aiohttp.ClientTimeout(total=5)
                        ) as response:
                            if response.status == 200:
                                self._add_vulnerability(
                                    f"HTTP {method} Method Allowed",
                                    "medium",
                                    f"HTTP {method} method is allowed when it should be restricted",
                                    "api_security",
                                    {"method": method}
                                )
                    except:
                        pass
                        
        except Exception as e:
            logger.debug(f"HTTP methods test error: {e}")
    
    async def _scan_authentication_authorization(self) -> None:
        """Scan authentication and authorization vulnerabilities"""
        logger.info("üîç Phase 3: Authentication & Authorization Testing")
        
        try:
            self.scan_results["scans_performed"]["authentication"] = True
            self.scan_results["scans_performed"]["authorization"] = True
            
            # Test weak password policies
            await self._test_password_policies()
            
            # Test JWT token security
            await self._test_jwt_security()
            
            # Test session management
            await self._test_session_management()
            
            # Test privilege escalation
            await self._test_privilege_escalation()
            
            logger.info("‚úÖ Authentication & authorization testing completed")
            
        except Exception as e:
            logger.error(f"‚ùå Authentication testing failed: {e}")
    
    async def _test_password_policies(self) -> None:
        """Test password policy enforcement"""
        try:
            logger.info("üîç Testing password policies...")
            
            weak_passwords = [
                "password",
                "123456",
                "admin",
                "test",
                "12345678",
                "password123"
            ]
            
            # This would need to be implemented based on your auth system
            # For now, we'll check if there are any obvious weak password checks
            
            async with aiohttp.ClientSession() as session:
                for password in weak_passwords:
                    try:
                        data = {
                            "username": "test@example.com",
                            "password": password
                        }
                        
                        async with session.post(
                            f"{self.config['backend_url']}/api/v1/auth/login",
                            json=data,
                            timeout=aiohttp.ClientTimeout(total=5)
                        ) as response:
                            # If login succeeds with weak password, it's a vulnerability
                            if response.status == 200:
                                self._add_vulnerability(
                                    "Weak Password Accepted",
                                    "high",
                                    f"System accepts weak password: {password}",
                                    "authentication"
                                )
                    except:
                        pass
                        
        except Exception as e:
            logger.debug(f"Password policy test error: {e}")
    
    async def _test_jwt_security(self) -> None:
        """Test JWT token security"""
        try:
            logger.info("üîç Testing JWT security...")
            
            # Test for JWT with no signature
            malformed_tokens = [
                "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.",
                "invalid.jwt.token",
                "Bearer fake_token"
            ]
            
            async with aiohttp.ClientSession() as session:
                for token in malformed_tokens:
                    try:
                        headers = {"Authorization": f"Bearer {token}"}
                        async with session.get(
                            f"{self.config['backend_url']}/api/v1/flows",
                            headers=headers,
                            timeout=aiohttp.ClientTimeout(total=5)
                        ) as response:
                            if response.status == 200:
                                self._add_vulnerability(
                                    "JWT Token Validation Bypass",
                                    "critical",
                                    f"Invalid JWT token was accepted: {token[:20]}...",
                                    "authentication"
                                )
                    except:
                        pass
                        
        except Exception as e:
            logger.debug(f"JWT security test error: {e}")
    
    async def _test_session_management(self) -> None:
        """Test session management security"""
        try:
            logger.info("üîç Testing session management...")
            
            # Test session fixation
            # Test session timeout
            # Test secure cookie flags
            
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{self.config['backend_url']}/api/v1/health",
                    timeout=aiohttp.ClientTimeout(total=5)
                ) as response:
                    # Check cookie security
                    cookies = response.cookies
                    for cookie in cookies:
                        if not cookie.get('secure'):
                            self._add_vulnerability(
                                "Insecure Cookie",
                                "medium",
                                f"Cookie {cookie.key} does not have Secure flag",
                                "session_management"
                            )
                        if not cookie.get('httponly'):
                            self._add_vulnerability(
                                "HttpOnly Cookie Missing",
                                "medium",
                                f"Cookie {cookie.key} does not have HttpOnly flag",
                                "session_management"
                            )
                            
        except Exception as e:
            logger.debug(f"Session management test error: {e}")
    
    async def _test_privilege_escalation(self) -> None:
        """Test for privilege escalation vulnerabilities"""
        try:
            logger.info("üîç Testing privilege escalation...")
            
            # Test admin endpoints with regular user credentials
            admin_endpoints = [
                "/api/v1/admin/users",
                "/api/v1/admin/system",
                "/api/v1/admin/config"
            ]
            
            # This would need actual user credentials to test properly
            # For now, we'll test if admin endpoints are accessible without auth
            
            async with aiohttp.ClientSession() as session:
                for endpoint in admin_endpoints:
                    try:
                        async with session.get(
                            f"{self.config['backend_url']}{endpoint}",
                            timeout=aiohttp.ClientTimeout(total=5)
                        ) as response:
                            if response.status == 200:
                                self._add_vulnerability(
                                    f"Admin Endpoint Accessible Without Auth",
                                    "critical",
                                    f"Admin endpoint {endpoint} is accessible without authentication",
                                    "authorization"
                                )
                    except:
                        pass
                        
        except Exception as e:
            logger.debug(f"Privilege escalation test error: {e}")
    
    async def _scan_input_validation(self) -> None:
        """Scan input validation vulnerabilities"""
        logger.info("üîç Phase 4: Input Validation Testing")
        
        try:
            self.scan_results["scans_performed"]["input_validation"] = True
            
            # Test various malicious inputs
            malicious_inputs = [
                "<script>alert('xss')</script>",
                "'; DROP TABLE flows; --",
                "../../../etc/passwd",
                "{{7*7}}",
                "${7*7}",
                "<%=7*7%>",
                "javascript:alert(1)",
                "\x00\x0a\x0d",
                "' OR '1'='1",
                "admin'/*",
                "' UNION SELECT NULL--"
            ]
            
            # Test flow creation with malicious inputs
            await self._test_flow_creation_input_validation(malicious_inputs)
            
            # Test API parameters
            await self._test_api_parameter_validation(malicious_inputs)
            
            logger.info("‚úÖ Input validation testing completed")
            
        except Exception as e:
            logger.error(f"‚ùå Input validation testing failed: {e}")
    
    async def _test_flow_creation_input_validation(self, malicious_inputs: List[str]) -> None:
        """Test flow creation input validation"""
        try:
            async with aiohttp.ClientSession() as session:
                headers = {
                    "Content-Type": "application/json",
                    "X-Client-Account-ID": "1",
                    "X-Engagement-ID": "1"
                }
                
                for malicious_input in malicious_inputs:
                    try:
                        data = {
                            "flow_type": "discovery",
                            "flow_name": malicious_input,
                            "configuration": {"test": malicious_input}
                        }
                        
                        async with session.post(
                            f"{self.config['backend_url']}/api/v1/flows",
                            json=data,
                            headers=headers,
                            timeout=aiohttp.ClientTimeout(total=10)
                        ) as response:
                            if response.status == 200:
                                # Check if malicious input was stored/processed
                                result = await response.json()
                                if malicious_input in str(result):
                                    self._add_vulnerability(
                                        "Input Validation Bypass in Flow Creation",
                                        "high",
                                        f"Malicious input was accepted and stored: {malicious_input[:50]}",
                                        "input_validation"
                                    )
                    except:
                        pass
                        
        except Exception as e:
            logger.debug(f"Flow creation input validation test error: {e}")
    
    async def _test_api_parameter_validation(self, malicious_inputs: List[str]) -> None:
        """Test API parameter validation"""
        try:
            async with aiohttp.ClientSession() as session:
                for malicious_input in malicious_inputs:
                    try:
                        # Test query parameters
                        params = {"limit": malicious_input, "offset": malicious_input}
                        async with session.get(
                            f"{self.config['backend_url']}/api/v1/master-flows/active",
                            params=params,
                            timeout=aiohttp.ClientTimeout(total=5)
                        ) as response:
                            if response.status == 500:
                                self._add_vulnerability(
                                    "Parameter Validation Error",
                                    "medium",
                                    f"Malicious parameter caused server error: {malicious_input[:30]}",
                                    "input_validation"
                                )
                    except:
                        pass
                        
        except Exception as e:
            logger.debug(f"API parameter validation test error: {e}")
    
    async def _scan_injection_attacks(self) -> None:
        """Scan for injection attack vulnerabilities"""
        logger.info("üîç Phase 5: Injection Attack Testing")
        
        try:
            self.scan_results["scans_performed"]["sql_injection"] = True
            
            # SQL injection payloads
            sql_payloads = [
                "' OR '1'='1",
                "'; DROP TABLE users; --",
                "' UNION SELECT * FROM users--",
                "admin'--",
                "admin'/*",
                "' OR 1=1--",
                "' AND password='password",
                "1' ORDER BY 1--+",
                "1' GROUP BY 1,2,3,4,5--+",
                "' HAVING 1=1--"
            ]
            
            # Test SQL injection in various endpoints
            await self._test_sql_injection(sql_payloads)
            
            # NoSQL injection payloads
            nosql_payloads = [
                "{'$ne': null}",
                "{'$regex': '.*'}",
                "{'$where': 'function() { return true; }'}",
                "{'$gt': ''}",
                "'; return ''"
            ]
            
            # Test NoSQL injection
            await self._test_nosql_injection(nosql_payloads)
            
            logger.info("‚úÖ Injection attack testing completed")
            
        except Exception as e:
            logger.error(f"‚ùå Injection attack testing failed: {e}")
    
    async def _test_sql_injection(self, payloads: List[str]) -> None:
        """Test SQL injection vulnerabilities"""
        try:
            async with aiohttp.ClientSession() as session:
                headers = {
                    "Content-Type": "application/json",
                    "X-Client-Account-ID": "1",
                    "X-Engagement-ID": "1"
                }
                
                for payload in payloads:
                    try:
                        # Test in flow search/filter
                        params = {"search": payload, "filter": payload}
                        async with session.get(
                            f"{self.config['backend_url']}/api/v1/master-flows/active",
                            params=params,
                            headers=headers,
                            timeout=aiohttp.ClientTimeout(total=10)
                        ) as response:
                            response_text = await response.text()
                            
                            # Look for SQL error indicators
                            sql_errors = [
                                "sql syntax",
                                "mysql_fetch",
                                "postgresql",
                                "sqlite",
                                "database error",
                                "syntax error",
                                "unclosed quotation"
                            ]
                            
                            for error in sql_errors:
                                if error.lower() in response_text.lower():
                                    self._add_vulnerability(
                                        "SQL Injection Vulnerability",
                                        "critical",
                                        f"SQL injection payload triggered database error: {payload[:50]}",
                                        "injection",
                                        {"payload": payload, "error": error}
                                    )
                                    break
                    except:
                        pass
                        
        except Exception as e:
            logger.debug(f"SQL injection test error: {e}")
    
    async def _test_nosql_injection(self, payloads: List[str]) -> None:
        """Test NoSQL injection vulnerabilities"""
        try:
            async with aiohttp.ClientSession() as session:
                headers = {"Content-Type": "application/json"}
                
                for payload in payloads:
                    try:
                        # Test in JSON payload
                        data = {"query": payload, "filter": payload}
                        async with session.post(
                            f"{self.config['backend_url']}/api/v1/flows",
                            json=data,
                            headers=headers,
                            timeout=aiohttp.ClientTimeout(total=5)
                        ) as response:
                            if response.status == 500:
                                response_text = await response.text()
                                if "mongo" in response_text.lower() or "nosql" in response_text.lower():
                                    self._add_vulnerability(
                                        "NoSQL Injection Vulnerability",
                                        "high",
                                        f"NoSQL injection payload caused error: {payload[:50]}",
                                        "injection"
                                    )
                    except:
                        pass
                        
        except Exception as e:
            logger.debug(f"NoSQL injection test error: {e}")
    
    async def _scan_xss_csrf(self) -> None:
        """Scan for XSS and CSRF vulnerabilities"""
        logger.info("üîç Phase 6: XSS & CSRF Testing")
        
        try:
            self.scan_results["scans_performed"]["xss"] = True
            self.scan_results["scans_performed"]["csrf"] = True
            
            # XSS payloads
            xss_payloads = [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')",
                "<svg onload=alert('XSS')>",
                "'-alert('XSS')-'",
                "\"><script>alert('XSS')</script>",
                "<iframe src=javascript:alert('XSS')></iframe>"
            ]
            
            # Test XSS in various inputs
            await self._test_xss_vulnerabilities(xss_payloads)
            
            # Test CSRF protection
            await self._test_csrf_protection()
            
            logger.info("‚úÖ XSS & CSRF testing completed")
            
        except Exception as e:
            logger.error(f"‚ùå XSS & CSRF testing failed: {e}")
    
    async def _test_xss_vulnerabilities(self, payloads: List[str]) -> None:
        """Test XSS vulnerabilities"""
        try:
            async with aiohttp.ClientSession() as session:
                headers = {
                    "Content-Type": "application/json",
                    "X-Client-Account-ID": "1",
                    "X-Engagement-ID": "1"
                }
                
                for payload in payloads:
                    try:
                        # Test XSS in flow creation
                        data = {
                            "flow_type": "discovery",
                            "flow_name": payload,
                            "configuration": {"description": payload}
                        }
                        
                        async with session.post(
                            f"{self.config['backend_url']}/api/v1/flows",
                            json=data,
                            headers=headers,
                            timeout=aiohttp.ClientTimeout(total=5)
                        ) as response:
                            if response.status == 200:
                                result = await response.json()
                                if payload in str(result) and "<script>" in payload:
                                    self._add_vulnerability(
                                        "Stored XSS Vulnerability",
                                        "high",
                                        f"XSS payload was stored without sanitization: {payload[:50]}",
                                        "xss"
                                    )
                    except:
                        pass
                        
        except Exception as e:
            logger.debug(f"XSS test error: {e}")
    
    async def _test_csrf_protection(self) -> None:
        """Test CSRF protection"""
        try:
            async with aiohttp.ClientSession() as session:
                # Test POST request without CSRF token
                data = {"flow_type": "discovery", "flow_name": "CSRF Test"}
                
                async with session.post(
                    f"{self.config['backend_url']}/api/v1/flows",
                    json=data,
                    timeout=aiohttp.ClientTimeout(total=5)
                ) as response:
                    # If request succeeds without CSRF protection, it might be vulnerable
                    if response.status == 200:
                        # Check if CSRF token validation is implemented
                        response_text = await response.text()
                        if "csrf" not in response_text.lower():
                            self._add_vulnerability(
                                "Missing CSRF Protection",
                                "medium",
                                "POST requests may not be protected against CSRF attacks",
                                "csrf"
                            )
                            
        except Exception as e:
            logger.debug(f"CSRF test error: {e}")
    
    async def _scan_dependencies(self) -> None:
        """Scan for dependency vulnerabilities"""
        logger.info("üîç Phase 7: Dependency Vulnerability Scan")
        
        try:
            self.scan_results["scans_performed"]["dependency_scan"] = True
            
            # Run safety check for Python dependencies
            await self._run_safety_check()
            
            # Run npm audit for Node.js dependencies
            await self._run_npm_audit()
            
            # Check for known vulnerable dependencies
            await self._check_known_vulnerabilities()
            
            logger.info("‚úÖ Dependency vulnerability scan completed")
            
        except Exception as e:
            logger.error(f"‚ùå Dependency scan failed: {e}")
    
    async def _run_safety_check(self) -> None:
        """Run safety check for Python dependencies"""
        try:
            logger.info("üîç Running Python safety check...")
            
            result = subprocess.run(
                ["docker-compose", "-f", "docker-compose.staging.yml", 
                 "exec", "-T", "backend", "pip", "install", "safety"],
                timeout=120,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                # Run safety check
                safety_result = subprocess.run(
                    ["docker-compose", "-f", "docker-compose.staging.yml", 
                     "exec", "-T", "backend", "safety", "check", "--json"],
                    timeout=60,
                    capture_output=True,
                    text=True
                )
                
                if safety_result.returncode != 0 and safety_result.stdout:
                    try:
                        vulnerabilities = json.loads(safety_result.stdout)
                        for vuln in vulnerabilities:
                            self._add_vulnerability(
                                f"Dependency Vulnerability: {vuln.get('package', 'unknown')}",
                                "medium",
                                f"Vulnerable package {vuln.get('package')} version {vuln.get('installed_version')}: {vuln.get('vulnerability', 'Unknown vulnerability')}",
                                "dependency_vulnerabilities",
                                vuln
                            )
                    except json.JSONDecodeError:
                        pass
                        
        except Exception as e:
            logger.debug(f"Safety check error: {e}")
    
    async def _run_npm_audit(self) -> None:
        """Run npm audit for Node.js dependencies"""
        try:
            logger.info("üîç Running npm audit...")
            
            result = subprocess.run(
                ["npm", "audit", "--json"],
                cwd=self.base_path,
                timeout=120,
                capture_output=True,
                text=True
            )
            
            if result.stdout:
                try:
                    audit_result = json.loads(result.stdout)
                    vulnerabilities = audit_result.get("vulnerabilities", {})
                    
                    for package, vuln_info in vulnerabilities.items():
                        severity = vuln_info.get("severity", "medium")
                        self._add_vulnerability(
                            f"NPM Dependency Vulnerability: {package}",
                            severity,
                            f"Vulnerable NPM package {package}: {vuln_info.get('title', 'Unknown vulnerability')}",
                            "dependency_vulnerabilities",
                            vuln_info
                        )
                except json.JSONDecodeError:
                    pass
                    
        except Exception as e:
            logger.debug(f"NPM audit error: {e}")
    
    async def _check_known_vulnerabilities(self) -> None:
        """Check for known vulnerable dependencies"""
        try:
            # Check requirements.txt for known vulnerable versions
            requirements_file = self.base_path / "backend" / "requirements.txt"
            if requirements_file.exists():
                with open(requirements_file, 'r') as f:
                    requirements = f.read()
                
                # Known vulnerable patterns
                vulnerable_patterns = [
                    ("django<3.2", "Django version may have security vulnerabilities"),
                    ("flask<2.0", "Flask version may have security vulnerabilities"),
                    ("requests<2.20", "Requests version may have security vulnerabilities"),
                    ("sqlalchemy<1.4", "SQLAlchemy version may have security vulnerabilities")
                ]
                
                for pattern, description in vulnerable_patterns:
                    if pattern.split('<')[0] in requirements:
                        self._add_vulnerability(
                            f"Potentially Vulnerable Dependency",
                            "low",
                            description,
                            "dependency_vulnerabilities"
                        )
                        
        except Exception as e:
            logger.debug(f"Known vulnerabilities check error: {e}")
    
    async def _scan_ssl_tls(self) -> None:
        """Scan SSL/TLS configuration"""
        logger.info("üîç Phase 8: SSL/TLS Configuration Scan")
        
        try:
            self.scan_results["scans_performed"]["ssl_tls"] = True
            
            # Parse URL to get host and port
            from urllib.parse import urlparse
            parsed_url = urlparse(self.config["backend_url"])
            
            if parsed_url.scheme == "https":
                await self._test_ssl_configuration(parsed_url.hostname, parsed_url.port or 443)
            else:
                self._add_vulnerability(
                    "HTTP Instead of HTTPS",
                    "medium",
                    "Application is running on HTTP instead of HTTPS",
                    "ssl_tls"
                )
            
            logger.info("‚úÖ SSL/TLS configuration scan completed")
            
        except Exception as e:
            logger.error(f"‚ùå SSL/TLS scan failed: {e}")
    
    async def _test_ssl_configuration(self, hostname: str, port: int) -> None:
        """Test SSL/TLS configuration"""
        try:
            # Create SSL context
            context = ssl.create_default_context()
            
            # Test SSL connection
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    # Get certificate info
                    cert = ssock.getpeercert()
                    
                    # Check certificate validity
                    if cert:
                        # Check if certificate is expired
                        not_after = cert.get('notAfter')
                        if not_after:
                            import ssl
                            cert_date = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')
                            if cert_date < datetime.now():
                                self._add_vulnerability(
                                    "Expired SSL Certificate",
                                    "high",
                                    f"SSL certificate expired on {not_after}",
                                    "ssl_tls"
                                )
                    
                    # Check SSL version
                    ssl_version = ssock.version()
                    if ssl_version in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        self._add_vulnerability(
                            "Weak SSL/TLS Version",
                            "medium",
                            f"Using weak SSL/TLS version: {ssl_version}",
                            "ssl_tls"
                        )
                        
        except Exception as e:
            logger.debug(f"SSL configuration test error: {e}")
    
    async def _scan_security_headers(self) -> None:
        """Scan security headers"""
        logger.info("üîç Phase 9: Security Headers Scan")
        
        try:
            self.scan_results["scans_performed"]["headers"] = True
            
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{self.config['backend_url']}/health",
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    await self._check_security_headers(response.headers)
            
            logger.info("‚úÖ Security headers scan completed")
            
        except Exception as e:
            logger.error(f"‚ùå Security headers scan failed: {e}")
    
    async def _check_security_headers(self, headers: Dict[str, str]) -> None:
        """Check for security headers"""
        required_headers = {
            "X-Content-Type-Options": "nosniff",
            "X-Frame-Options": ["DENY", "SAMEORIGIN"],
            "X-XSS-Protection": "1; mode=block",
            "Strict-Transport-Security": "max-age=",
            "Content-Security-Policy": "",
            "Referrer-Policy": ["no-referrer", "same-origin", "strict-origin"]
        }
        
        for header, expected_value in required_headers.items():
            if header not in headers:
                self._add_vulnerability(
                    f"Missing Security Header: {header}",
                    "medium",
                    f"Security header {header} is missing",
                    "headers_security"
                )
            elif expected_value and isinstance(expected_value, str):
                if expected_value not in headers[header]:
                    self._add_vulnerability(
                        f"Weak Security Header: {header}",
                        "low",
                        f"Security header {header} has value '{headers[header]}' but should contain '{expected_value}'",
                        "headers_security"
                    )
            elif expected_value and isinstance(expected_value, list):
                if not any(val in headers[header] for val in expected_value):
                    self._add_vulnerability(
                        f"Weak Security Header: {header}",
                        "low",
                        f"Security header {header} has value '{headers[header]}' but should be one of {expected_value}",
                        "headers_security"
                    )
    
    async def _scan_configuration_security(self) -> None:
        """Scan configuration security"""
        logger.info("üîç Phase 10: Configuration Security Scan")
        
        try:
            self.scan_results["scans_performed"]["configuration"] = True
            
            # Check for debug mode
            await self._check_debug_mode()
            
            # Check for default credentials
            await self._check_default_credentials()
            
            # Check for information disclosure
            await self._check_information_disclosure()
            
            logger.info("‚úÖ Configuration security scan completed")
            
        except Exception as e:
            logger.error(f"‚ùå Configuration security scan failed: {e}")
    
    async def _check_debug_mode(self) -> None:
        """Check if debug mode is enabled"""
        try:
            async with aiohttp.ClientSession() as session:
                # Check for debug information in error responses
                async with session.get(
                    f"{self.config['backend_url']}/api/v1/nonexistent",
                    timeout=aiohttp.ClientTimeout(total=5)
                ) as response:
                    response_text = await response.text()
                    
                    debug_indicators = [
                        "traceback",
                        "stack trace",
                        "debug",
                        "development",
                        "internal server error",
                        "exception",
                        "error details"
                    ]
                    
                    for indicator in debug_indicators:
                        if indicator.lower() in response_text.lower():
                            self._add_vulnerability(
                                "Debug Mode Enabled",
                                "medium",
                                "Application appears to be running in debug mode, exposing sensitive information",
                                "insecure_configuration"
                            )
                            break
                            
        except Exception as e:
            logger.debug(f"Debug mode check error: {e}")
    
    async def _check_default_credentials(self) -> None:
        """Check for default credentials"""
        try:
            default_creds = [
                ("admin", "admin"),
                ("admin", "password"),
                ("root", "root"),
                ("test", "test"),
                ("demo", "demo"),
                ("user", "password")
            ]
            
            async with aiohttp.ClientSession() as session:
                for username, password in default_creds:
                    try:
                        data = {"username": username, "password": password}
                        async with session.post(
                            f"{self.config['backend_url']}/api/v1/auth/login",
                            json=data,
                            timeout=aiohttp.ClientTimeout(total=5)
                        ) as response:
                            if response.status == 200:
                                self._add_vulnerability(
                                    "Default Credentials",
                                    "critical",
                                    f"Default credentials work: {username}/{password}",
                                    "insecure_configuration"
                                )
                    except:
                        pass
                        
        except Exception as e:
            logger.debug(f"Default credentials check error: {e}")
    
    async def _check_information_disclosure(self) -> None:
        """Check for information disclosure"""
        try:
            # Check server headers for version information
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{self.config['backend_url']}/health",
                    timeout=aiohttp.ClientTimeout(total=5)
                ) as response:
                    server_header = response.headers.get('Server', '')
                    if any(tech in server_header.lower() for tech in ['apache', 'nginx', 'python', 'flask', 'django']):
                        version_pattern = re.search(r'(\d+\.\d+)', server_header)
                        if version_pattern:
                            self._add_vulnerability(
                                "Server Version Disclosure",
                                "low",
                                f"Server header reveals version information: {server_header}",
                                "information_disclosure"
                            )
                            
        except Exception as e:
            logger.debug(f"Information disclosure check error: {e}")
    
    def _add_vulnerability(
        self,
        title: str,
        severity: str,
        description: str,
        category: str,
        additional_info: Optional[Dict[str, Any]] = None
    ) -> None:
        """Add a vulnerability to the results"""
        vulnerability = {
            "id": f"VULN-{len(self.scan_results['vulnerabilities']) + 1:04d}",
            "title": title,
            "severity": severity.lower(),
            "description": description,
            "category": category,
            "timestamp": datetime.now().isoformat(),
            "additional_info": additional_info or {}
        }
        
        self.scan_results["vulnerabilities"].append(vulnerability)
        self.scan_results["summary"]["total_vulnerabilities"] += 1
        self.scan_results["summary"][severity.lower()] += 1
        
        logger.warning(f"üö® {severity.upper()}: {title}")
    
    async def _generate_security_report(self) -> None:
        """Generate comprehensive security report"""
        self.scan_results["end_time"] = datetime.now().isoformat()
        
        # Calculate scan duration
        start_time = datetime.fromisoformat(self.scan_results["start_time"])
        end_time = datetime.fromisoformat(self.scan_results["end_time"])
        duration = (end_time - start_time).total_seconds()
        
        self.scan_results["duration_seconds"] = duration
        
        # Generate recommendations
        self._generate_recommendations()
        
        # OWASP Top 10 compliance check
        self._check_owasp_compliance()
        
        # Save detailed report
        report_file = self.results_path / f"security_scan_report_{self.scan_id}.json"
        with open(report_file, 'w') as f:
            json.dump(self.scan_results, f, indent=2)
        
        # Generate executive summary
        summary_file = self.results_path / f"security_summary_{self.scan_id}.txt"
        with open(summary_file, 'w') as f:
            self._write_executive_summary(f)
        
        # Log summary
        logger.info("\n" + "=" * 80)
        logger.info("üîí SECURITY VULNERABILITY SCAN RESULTS")
        logger.info("=" * 80)
        logger.info(f"Scan ID: {self.scan_id}")
        logger.info(f"Duration: {duration:.2f} seconds")
        logger.info(f"Total Vulnerabilities: {self.scan_results['summary']['total_vulnerabilities']}")
        logger.info(f"Critical: {self.scan_results['summary']['critical']}")
        logger.info(f"High: {self.scan_results['summary']['high']}")
        logger.info(f"Medium: {self.scan_results['summary']['medium']}")
        logger.info(f"Low: {self.scan_results['summary']['low']}")
        logger.info(f"Info: {self.scan_results['summary']['info']}")
        logger.info(f"Detailed report: {report_file}")
        logger.info(f"Executive summary: {summary_file}")
        
        # Security assessment
        critical_high = self.scan_results['summary']['critical'] + self.scan_results['summary']['high']
        
        if critical_high == 0:
            logger.info("\nüéâ SECURITY SCAN PASSED!")
            logger.info("‚úÖ No critical or high severity vulnerabilities found")
            logger.info("‚úÖ Ready for data integrity validation (MFO-098)")
        else:
            logger.error(f"\n‚ùå SECURITY SCAN FAILED!")
            logger.error(f"üö® {critical_high} critical/high severity vulnerabilities found")
            logger.error("üîß Security issues must be resolved before production")
        
        logger.info("=" * 80)
    
    def _generate_recommendations(self) -> None:
        """Generate security recommendations"""
        recommendations = []
        
        # Category-based recommendations
        vuln_categories = {}
        for vuln in self.scan_results["vulnerabilities"]:
            category = vuln["category"]
            if category not in vuln_categories:
                vuln_categories[category] = 0
            vuln_categories[category] += 1
        
        category_recommendations = {
            "authentication": "Implement strong authentication mechanisms, use multi-factor authentication, and enforce strong password policies",
            "authorization": "Implement proper access controls, use role-based permissions, and regularly audit user privileges",
            "injection": "Use parameterized queries, validate and sanitize all inputs, and implement proper error handling",
            "xss": "Implement Content Security Policy, sanitize user inputs, and use output encoding",
            "csrf": "Implement CSRF tokens, use SameSite cookies, and validate referrer headers",
            "ssl_tls": "Use TLS 1.2 or higher, implement proper certificate validation, and use strong cipher suites",
            "headers_security": "Implement all recommended security headers to protect against common attacks",
            "dependency_vulnerabilities": "Regularly update dependencies, use dependency scanning tools, and monitor security advisories",
            "insecure_configuration": "Disable debug mode in production, change default credentials, and follow security hardening guidelines",
            "information_disclosure": "Minimize information exposure in error messages and headers"
        }
        
        for category, count in vuln_categories.items():
            if category in category_recommendations:
                recommendations.append({
                    "category": category,
                    "priority": "high" if count > 2 else "medium",
                    "recommendation": category_recommendations[category],
                    "affected_items": count
                })
        
        self.scan_results["recommendations"] = recommendations
    
    def _check_owasp_compliance(self) -> None:
        """Check OWASP Top 10 compliance"""
        owasp_categories = {
            "A01:2021 ‚Äì Broken Access Control": ["authentication", "authorization"],
            "A02:2021 ‚Äì Cryptographic Failures": ["ssl_tls", "insecure_configuration"],
            "A03:2021 ‚Äì Injection": ["injection", "sql_injection"],
            "A04:2021 ‚Äì Insecure Design": ["insecure_configuration"],
            "A05:2021 ‚Äì Security Misconfiguration": ["insecure_configuration", "headers_security"],
            "A06:2021 ‚Äì Vulnerable and Outdated Components": ["dependency_vulnerabilities"],
            "A07:2021 ‚Äì Identification and Authentication Failures": ["authentication", "session_management"],
            "A08:2021 ‚Äì Software and Data Integrity Failures": ["dependency_vulnerabilities"],
            "A09:2021 ‚Äì Security Logging and Monitoring Failures": ["information_disclosure"],
            "A10:2021 ‚Äì Server-Side Request Forgery": ["input_validation"]
        }
        
        owasp_compliance = []
        
        for owasp_item, categories in owasp_categories.items():
            violations = []
            for vuln in self.scan_results["vulnerabilities"]:
                if vuln["category"] in categories:
                    violations.append(vuln["id"])
            
            owasp_compliance.append({
                "item": owasp_item,
                "compliant": len(violations) == 0,
                "violations": violations,
                "violation_count": len(violations)
            })
        
        self.scan_results["compliance"]["owasp_top_10"] = owasp_compliance
    
    def _write_executive_summary(self, file_handle) -> None:
        """Write executive summary"""
        file_handle.write("SECURITY VULNERABILITY SCAN - EXECUTIVE SUMMARY\n")
        file_handle.write("=" * 50 + "\n\n")
        
        file_handle.write(f"Scan ID: {self.scan_id}\n")
        file_handle.write(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        file_handle.write(f"Target: {self.config['backend_url']}\n\n")
        
        file_handle.write("VULNERABILITY SUMMARY:\n")
        file_handle.write(f"  Total Vulnerabilities: {self.scan_results['summary']['total_vulnerabilities']}\n")
        file_handle.write(f"  Critical: {self.scan_results['summary']['critical']}\n")
        file_handle.write(f"  High: {self.scan_results['summary']['high']}\n")
        file_handle.write(f"  Medium: {self.scan_results['summary']['medium']}\n")
        file_handle.write(f"  Low: {self.scan_results['summary']['low']}\n\n")
        
        if self.scan_results["vulnerabilities"]:
            file_handle.write("TOP VULNERABILITIES:\n")
            sorted_vulns = sorted(
                self.scan_results["vulnerabilities"],
                key=lambda x: {"critical": 4, "high": 3, "medium": 2, "low": 1, "info": 0}.get(x["severity"], 0),
                reverse=True
            )
            
            for vuln in sorted_vulns[:10]:  # Top 10
                file_handle.write(f"  [{vuln['severity'].upper()}] {vuln['title']}\n")
                file_handle.write(f"    {vuln['description'][:100]}...\n\n")
        
        file_handle.write("RECOMMENDATIONS:\n")
        for rec in self.scan_results["recommendations"][:5]:  # Top 5
            file_handle.write(f"  [{rec['priority'].upper()}] {rec['recommendation']}\n\n")
    
    async def _handle_scan_failure(self, error: Exception) -> None:
        """Handle scan failure"""
        self.scan_results["execution_error"] = str(error)
        self.scan_results["end_time"] = datetime.now().isoformat()
        
        # Save failure report
        failure_report_file = self.results_path / f"security_scan_failure_{self.scan_id}.json"
        with open(failure_report_file, 'w') as f:
            json.dump(self.scan_results, f, indent=2)
        
        logger.error("=" * 80)
        logger.error("‚ùå SECURITY VULNERABILITY SCAN FAILED")
        logger.error("=" * 80)
        logger.error(f"Error: {error}")
        logger.error(f"Failure report saved: {failure_report_file}")
        logger.error("=" * 80)


async def main():
    """Main security scanning function"""
    scanner = SecurityVulnerabilityScanner()
    
    try:
        success = await scanner.run_security_scan()
        
        if success:
            logger.info("‚úÖ Security vulnerability scan completed successfully!")
            sys.exit(0)
        else:
            logger.error("‚ùå Security vulnerability scan failed!")
            sys.exit(1)
            
    except KeyboardInterrupt:
        logger.info("‚èπÔ∏è  Security scan interrupted by user")
        sys.exit(1)
    except Exception as e:
        logger.error(f"‚ùå Security scan failed with unexpected error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())