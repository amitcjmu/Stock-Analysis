#!/usr/bin/env python3
"""
Fix Orphaned Revision Script - Generated by CC

This script fixes the specific issue where the database references revision '95c80fef1289'
which doesn't exist in our current migration files. It resets the alembic_version table
to the earliest known good revision and lets Alembic migrate forward.

Usage:
    python scripts/fix_orphaned_revision.py [--target-revision=001_comprehensive_initial_schema]
"""

import argparse
import asyncio
import logging
import sys
from pathlib import Path

# Add the parent directory to sys.path to import app modules
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from sqlalchemy.ext.asyncio import create_async_engine
    from sqlalchemy import text
    from app.core.config import Settings
except ImportError as e:
    print(f"‚ùå Import error: {e}")
    print(
        "Make sure you're running this from the backend directory with the correct Python environment"
    )
    sys.exit(1)

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


async def fix_orphaned_revision(
    target_revision: str = "001_comprehensive_initial_schema",
):
    """
    Fix orphaned revision by resetting alembic_version to a known good state

    Args:
        target_revision: The revision to reset to (should be the base migration)
    """
    logger.info(f"üîß Starting orphaned revision fix (target: {target_revision})")

    # Create database connection
    settings = Settings()
    engine = create_async_engine(settings.database_url_async, echo=False)

    try:
        async with engine.connect() as conn:
            # Check current state
            logger.info("üìä Checking current database state...")

            # Check if alembic_version table exists
            result = await conn.execute(
                text(
                    """
                SELECT EXISTS (
                    SELECT 1 FROM information_schema.tables
                    WHERE table_name = 'alembic_version'
                )
            """
                )
            )
            alembic_table_exists = result.scalar()

            if not alembic_table_exists:
                logger.info("üìã Creating alembic_version table...")
                await conn.execute(
                    text(
                        """
                    CREATE TABLE alembic_version (
                        version_num VARCHAR(255) NOT NULL,
                        CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)
                    )
                """
                    )
                )
                await conn.commit()

            # Get current version
            try:
                result = await conn.execute(
                    text("SELECT version_num FROM alembic_version LIMIT 1")
                )
                current_version = result.scalar()
                logger.info(f"üìç Current alembic version: {current_version}")
            except Exception as e:
                logger.warning(f"Could not read current version: {e}")
                current_version = None

            # Check if target revision file exists
            alembic_versions_dir = Path(__file__).parent.parent / "alembic" / "versions"
            target_file = alembic_versions_dir / f"{target_revision}.py"

            if not target_file.exists():
                logger.error(f"‚ùå Target revision file not found: {target_file}")
                # List available files
                available_files = sorted(
                    [f.stem for f in alembic_versions_dir.glob("*.py")]
                )[:5]
                logger.info(f"Available revisions (first 5): {available_files}")
                return False

            # Check if we have migration schema
            result = await conn.execute(
                text(
                    """
                SELECT EXISTS (
                    SELECT 1 FROM information_schema.schemata
                    WHERE schema_name = 'migration'
                )
            """
                )
            )
            migration_schema_exists = result.scalar()

            if not migration_schema_exists:
                logger.info("üìã Creating migration schema...")
                await conn.execute(text("CREATE SCHEMA migration"))
                await conn.commit()

            # Reset alembic version to target revision
            logger.info(f"üîÑ Resetting alembic version to {target_revision}")

            # Clear existing version
            await conn.execute(text("DELETE FROM alembic_version"))

            # Insert target version
            await conn.execute(
                text(
                    """
                INSERT INTO alembic_version (version_num) VALUES (:version)
            """
                ),
                {"version": target_revision},
            )

            await conn.commit()

            logger.info(f"‚úÖ Successfully reset alembic version to {target_revision}")
            logger.info("üìå Next steps:")
            logger.info(
                "   1. Run 'alembic upgrade head' to apply remaining migrations"
            )
            logger.info("   2. Verify the database schema is correct")

            return True

    except Exception as e:
        logger.error(f"‚ùå Failed to fix orphaned revision: {e}")
        return False
    finally:
        await engine.dispose()


async def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="Fix orphaned Alembic revision by resetting to known good state"
    )
    parser.add_argument(
        "--target-revision",
        default="001_comprehensive_initial_schema",
        help="Target revision to reset to (default: 001_comprehensive_initial_schema)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be done without making changes",
    )

    args = parser.parse_args()

    if args.dry_run:
        logger.info("üîç DRY RUN MODE - No changes will be made")
        logger.info(f"Would reset alembic_version to: {args.target_revision}")
        return 0

    try:
        success = await fix_orphaned_revision(args.target_revision)
        return 0 if success else 1
    except KeyboardInterrupt:
        logger.info("‚ùå Operation cancelled by user")
        return 1
    except Exception as e:
        logger.error(f"‚ùå Unexpected error: {e}")
        return 1


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)
