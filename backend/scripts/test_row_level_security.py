#!/usr/bin/env python3
"""
Test Row-Level Security Implementation - Generated by CC

This script tests that Row-Level Security policies are working correctly
by attempting cross-tenant data access.

Usage:
    python scripts/test_row_level_security.py
"""

import asyncio
import sys
import uuid
from pathlib import Path

# Add the parent directory to sys.path
sys.path.append(str(Path(__file__).parent.parent))

from sqlalchemy import text
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

from app.core.config import Settings
from app.core.demo_constants import TEST_TENANT_1, TEST_TENANT_2


async def test_rls_isolation():
    """Test that RLS properly isolates tenant data"""
    settings = Settings()
    engine = create_async_engine(settings.database_url_async, echo=False)
    AsyncSessionLocal = sessionmaker(
        engine, class_=AsyncSession, expire_on_commit=False
    )

    print("üß™ Testing Row-Level Security Implementation\n")

    async with AsyncSessionLocal() as session:
        try:
            # First, check if we have test data
            result = await session.execute(
                text(
                    """
                    SELECT COUNT(*) as total,
                           COUNT(DISTINCT client_account_id) as tenants
                    FROM migration.agent_task_history
                """
                )
            )
            row = result.fetchone()
            print(f"üìä Found {row.total} total records across {row.tenants} tenants\n")

            # Test 1: Set tenant context to TEST_TENANT_1
            print(f"üîç Test 1: Setting context to TEST_TENANT_1 ({TEST_TENANT_1})")
            await session.execute(
                text("SELECT migration.set_tenant_context(:client_id)"),
                {"client_id": str(TEST_TENANT_1)},
            )

            # Query data - should only see TEST_TENANT_1 data
            result = await session.execute(
                text(
                    """
                    SELECT COUNT(*) as count,
                           MIN(client_account_id)::text as client_id
                    FROM migration.agent_task_history
                """
                )
            )
            row = result.fetchone()
            print(f"   ‚úÖ Can see {row.count} records")
            print(f"   ‚úÖ All from client: {row.client_id}")

            # Test 2: Switch to TEST_TENANT_2
            print(f"\nüîç Test 2: Switching context to TEST_TENANT_2 ({TEST_TENANT_2})")
            await session.execute(
                text("SELECT migration.set_tenant_context(:client_id)"),
                {"client_id": str(TEST_TENANT_2)},
            )

            # Query data - should only see TEST_TENANT_2 data
            result = await session.execute(
                text(
                    """
                    SELECT COUNT(*) as count,
                           MIN(client_account_id)::text as client_id
                    FROM migration.agent_task_history
                """
                )
            )
            row = result.fetchone()
            print(f"   ‚úÖ Can see {row.count} records")
            if row.count > 0:
                print(f"   ‚úÖ All from client: {row.client_id}")

            # Test 3: Try to access data without setting context
            print("\nüîç Test 3: Accessing data without tenant context")
            await session.execute(text("RESET app.client_id"))

            result = await session.execute(
                text(
                    """
                    SELECT COUNT(*) as count
                    FROM migration.agent_task_history
                """
                )
            )
            row = result.fetchone()
            print(f"   ‚úÖ Can see {row.count} records (should be 0 with RLS enabled)")

            # Test 4: Verify cross-tenant isolation
            print("\nüîç Test 4: Verifying cross-tenant data isolation")

            # Set to tenant 1
            await session.execute(
                text("SELECT migration.set_tenant_context(:client_id)"),
                {"client_id": str(TEST_TENANT_1)},
            )

            # Try to explicitly query tenant 2 data
            result = await session.execute(
                text(
                    """
                    SELECT COUNT(*) as count
                    FROM migration.agent_task_history
                    WHERE client_account_id = :tenant2_id
                """
                ),
                {"tenant2_id": str(TEST_TENANT_2)},
            )
            row = result.fetchone()
            print(f"   ‚úÖ Tenant 1 trying to access Tenant 2 data: {row.count} records")
            print(
                "   ‚úÖ Cross-tenant access blocked!"
                if row.count == 0
                else "   ‚ùå SECURITY ISSUE: Cross-tenant access allowed!"
            )

            # Test 5: Check multiple tables
            print("\nüîç Test 5: Checking RLS on multiple tables")
            tables_to_check = [
                "agent_discovered_patterns",
                "assets",
                "data_imports",
                "discovery_flows",
            ]

            await session.execute(
                text("SELECT migration.set_tenant_context(:client_id)"),
                {"client_id": str(TEST_TENANT_1)},
            )

            for table in tables_to_check:
                try:
                    result = await session.execute(  # nosec B608 - table name is from trusted list
                        text(f"SELECT COUNT(*) FROM migration.{table}")
                    )
                    count = result.scalar()
                    print(f"   ‚úÖ {table}: {count} records visible")
                except Exception as e:
                    print(f"   ‚ÑπÔ∏è  {table}: {str(e)}")

            print("\n‚úÖ Row-Level Security tests completed!")

        except Exception as e:
            print(f"\n‚ùå Error during RLS testing: {e}")
            import traceback

            traceback.print_exc()

    await engine.dispose()


async def test_rls_functions():
    """Test the RLS helper functions"""
    settings = Settings()
    engine = create_async_engine(settings.database_url_async, echo=False)
    AsyncSessionLocal = sessionmaker(
        engine, class_=AsyncSession, expire_on_commit=False
    )

    print("\nüß™ Testing RLS Helper Functions\n")

    async with AsyncSessionLocal() as session:
        try:
            # Test set_tenant_context function
            test_uuid = str(uuid.uuid4())
            print(f"üîß Testing set_tenant_context with UUID: {test_uuid}")
            await session.execute(
                text("SELECT migration.set_tenant_context(:client_id)"),
                {"client_id": test_uuid},
            )
            print("   ‚úÖ set_tenant_context executed successfully")

            # Test get_current_tenant function
            print("\nüîß Testing get_current_tenant")
            result = await session.execute(
                text("SELECT migration.get_current_tenant()")
            )
            current_tenant = result.scalar()
            print(f"   ‚úÖ Current tenant: {current_tenant}")
            print(f"   ‚úÖ Matches set value: {current_tenant == test_uuid}")

            # Test with no context
            print("\nüîß Testing get_current_tenant with no context")
            await session.execute(text("RESET app.client_id"))
            result = await session.execute(
                text("SELECT migration.get_current_tenant()")
            )
            current_tenant = result.scalar()
            print(f"   ‚úÖ Current tenant (should be None): {current_tenant}")

        except Exception as e:
            print(f"\n‚ùå Error testing RLS functions: {e}")
            import traceback

            traceback.print_exc()

    await engine.dispose()


async def main():
    """Main entry point"""
    await test_rls_isolation()
    await test_rls_functions()


if __name__ == "__main__":
    asyncio.run(main())
