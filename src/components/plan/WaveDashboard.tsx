/**
 * Wave Dashboard Component with Drag-Drop Support
 *
 * Displays migration waves in a grid layout with drag-drop application assignment.
 * Uses @dnd-kit for drag and drop functionality between waves.
 *
 * Features:
 * - Display all waves from wave_plan_data
 * - Drag applications between waves
 * - Real-time wave metadata updates
 * - Persistent changes via API
 *
 * Uses snake_case field names per CLAUDE.md.
 *
 * Generated by CC - Claude Code
 */

import React, { useState, useCallback } from 'react';
import {
  DndContext,
  DragOverlay,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragStartEvent,
  DragEndEvent,
} from '@dnd-kit/core';
import {
  SortableContext,
  sortableKeyboardCoordinates,
} from '@dnd-kit/sortable';
import type { Wave } from '@/lib/api/planningFlowService';
import WaveCard from './WaveCard';
import { Package } from 'lucide-react';

interface WaveDashboardProps {
  /** Array of waves to display */
  waves: Wave[];
  /** Map of application IDs to application details */
  applications?: Map<string, { id: string; name: string }>;
  /** Callback when user clicks edit on a wave */
  onEditWave: (wave: Wave) => void;
  /** Callback when user clicks delete on a wave */
  onDeleteWave: (wave: Wave) => void;
  /** Callback when an application is moved between waves */
  onApplicationMoved?: (appId: string, fromWave: number, toWave: number) => Promise<void>;
  /** Whether drag-drop is enabled */
  isDragEnabled?: boolean;
}

/**
 * Wave Dashboard Component with drag-drop support.
 */
export default function WaveDashboard({
  waves,
  applications = new Map(),
  onEditWave,
  onDeleteWave,
  onApplicationMoved,
  isDragEnabled = true,
}: WaveDashboardProps): JSX.Element {
  const [activeId, setActiveId] = useState<string | null>(null);
  const [isMoving, setIsMoving] = useState(false);

  // Configure drag sensors
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // Require 8px movement before drag starts
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  /**
   * Handle drag start event.
   */
  const handleDragStart = useCallback((event: DragStartEvent) => {
    setActiveId(event.active.id as string);
  }, []);

  /**
   * Handle drag end event - move application between waves.
   */
  const handleDragEnd = useCallback(
    async (event: DragEndEvent) => {
      const { active, over } = event;

      setActiveId(null);

      if (!over || !onApplicationMoved) {
        return;
      }

      // Extract data from drag event
      const activeData = active.data.current;
      const overData = over.data.current;

      // Validate this is an application being dropped on a wave
      if (
        activeData?.type !== 'application' ||
        overData?.type !== 'wave'
      ) {
        return;
      }

      const appId = activeData.app_id;
      const sourceWave = activeData.source_wave;
      const targetWave = overData.wave_number;

      // Don't move if dropped on the same wave
      if (sourceWave === targetWave) {
        return;
      }

      // Call the callback to persist the change
      setIsMoving(true);
      try {
        await onApplicationMoved(appId, sourceWave, targetWave);
      } catch (error) {
        console.error('Failed to move application:', error);
        // TODO: Show error toast
      } finally {
        setIsMoving(false);
      }
    },
    [onApplicationMoved]
  );

  /**
   * Get applications assigned to a specific wave.
   */
  const getWaveApplications = useCallback(
    (wave: Wave): Array<{ id: string; name: string }> => {
      if (!wave.applications || wave.applications.length === 0) {
        return [];
      }

      return wave.applications
        .map((appId) => applications.get(appId))
        .filter((app): app is { id: string; name: string } => app !== undefined);
    },
    [applications]
  );

  // Collect all application IDs for sortable context
  const allAppIds = waves.flatMap((wave) =>
    (wave.applications || []).map((appId) => `app-${appId}`)
  );

  // Empty state
  if (waves.length === 0) {
    return (
      <div className="border-2 border-dashed border-gray-300 rounded-lg p-12 text-center">
        <svg
          className="mx-auto h-12 w-12 text-gray-400 mb-4"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"
          />
        </svg>
        <p className="text-gray-500 text-lg font-medium">No waves created yet</p>
        <p className="text-gray-400 text-sm mt-2">
          Click "Create Wave" to organize applications into migration waves
        </p>
      </div>
    );
  }

  // Render active drag overlay
  const activeApp = activeId
    ? applications.get(activeId.replace('app-', ''))
    : null;

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      <SortableContext items={allAppIds}>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {waves.map((wave) => (
            <WaveCard
              key={wave.wave_number}
              wave={wave}
              applications={getWaveApplications(wave)}
              onEdit={onEditWave}
              onDelete={onDeleteWave}
              isDragEnabled={isDragEnabled && !isMoving}
            />
          ))}
        </div>

        {/* Drag Overlay */}
        <DragOverlay>
          {activeApp ? (
            <div className="flex items-center gap-2 p-2 bg-white rounded border-2 border-blue-500 shadow-xl">
              <Package className="h-4 w-4 text-gray-500" />
              <span className="text-sm text-gray-700">{activeApp.name}</span>
            </div>
          ) : null}
        </DragOverlay>
      </SortableContext>

      {/* Moving Indicator */}
      {isMoving && (
        <div className="fixed inset-0 bg-black bg-opacity-20 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg shadow-xl p-6">
            <div className="flex items-center gap-3">
              <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
              <span className="text-gray-700">Moving application...</span>
            </div>
          </div>
        </div>
      )}
    </DndContext>
  );
}
