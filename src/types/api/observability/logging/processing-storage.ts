/**
 * Observability Logging Processing and Storage Types
 * 
 * Type definitions for log processing pipelines, storage configuration,
 * retention policies, and forwarding setups.
 * 
 * Generated by CC (Claude Code) - Modularized from logging-types.ts
 */

// Processing Configuration
export interface LogProcessingConfig {
  pipelines: ProcessingPipeline[];
  parsers: ParserConfig[];
  transformations: TransformationConfig[];
  enrichment: EnrichmentConfig[];
  validation: ValidationConfig;
  errorHandling: ErrorHandlingConfig;
}

export interface ProcessingPipeline {
  id: string;
  name: string;
  stages: PipelineStage[];
  errorHandling: PipelineErrorHandling;
  monitoring: PipelineMonitoring;
  parallelism: number;
}

export interface PipelineStage {
  id: string;
  type: 'parse' | 'transform' | 'enrich' | 'validate' | 'route';
  configuration: Record<string, any>;
  errorHandling: StageErrorHandling;
  conditions?: StageCondition[];
}

export interface StageCondition {
  field: string;
  operator: string;
  value: unknown;
  action: 'continue' | 'skip' | 'route' | 'fail';
}

export interface StageErrorHandling {
  onFailure: 'continue' | 'skip' | 'fail' | 'retry';
  retries?: number;
  retryDelay?: string;
  fallbackAction?: string;
}

export interface PipelineErrorHandling {
  strategy: 'drop' | 'retry' | 'dead_letter' | 'fallback';
  maxRetries: number;
  retryDelay: string;
  deadLetterIndex: string;
  alerting: ErrorAlertingConfig;
}

export interface ErrorAlertingConfig {
  enabled: boolean;
  thresholds: Record<string, number>;
  channels: string[];
  escalation: AlertEscalation[];
}

export interface AlertEscalation {
  level: number;
  threshold: number;
  recipients: string[];
  delay: string;
}

export interface PipelineMonitoring {
  enabled: boolean;
  metrics: PipelineMetric[];
  sampling: MonitoringSampling;
}

export interface PipelineMetric {
  name: string;
  type: 'counter' | 'gauge' | 'histogram';
  labels: string[];
  description: string;
}

export interface MonitoringSampling {
  enabled: boolean;
  rate: number;
  strategy: 'random' | 'systematic';
}

export interface ParserConfig {
  name: string;
  type: string;
  configuration: Record<string, any>;
  fieldMappings: Record<string, string>;
  performance: ParserPerformance;
}

export interface ParserPerformance {
  timeout: string;
  maxMemory: string;
  cacheSize?: number;
  cacheTimeout?: string;
}

export interface TransformationConfig {
  type: 'add_field' | 'remove_field' | 'rename_field' | 'convert_type' | 'extract' | 'replace';
  configuration: Record<string, any>;
  conditions: TransformationCondition[];
}

export interface TransformationCondition {
  field: string;
  operator: string;
  value: unknown;
  required: boolean;
}

export interface EnrichmentConfig {
  type: 'geo' | 'dns' | 'user_agent' | 'database' | 'api' | 'file';
  source: string;
  mapping: EnrichmentMapping;
  caching: EnrichmentCaching;
  failureHandling: EnrichmentFailureHandling;
}

export interface EnrichmentMapping {
  keyField: string;
  targetFields: EnrichmentField[];
  defaultValues: Record<string, any>;
}

export interface EnrichmentField {
  source: string;
  target: string;
  type: string;
  required: boolean;
}

export interface EnrichmentCaching {
  enabled: boolean;
  ttl: string;
  maxSize: number;
  evictionPolicy: 'lru' | 'lfu' | 'ttl';
}

export interface EnrichmentFailureHandling {
  onFailure: 'skip' | 'default' | 'fail';
  timeout: string;
  retries: number;
  fallbackValues: Record<string, any>;
}

export interface ValidationConfig {
  enabled: boolean;
  rules: ValidationRule[];
  onFailure: 'drop' | 'tag' | 'route';
  strictMode: boolean;
}

export interface ValidationRule {
  field: string;
  type: 'required' | 'format' | 'range' | 'custom';
  configuration: Record<string, any>;
  errorMessage: string;
}

export interface ErrorHandlingConfig {
  strategy: 'drop' | 'retry' | 'dead_letter' | 'fallback';
  maxRetries: number;
  retryDelay: string;
  deadLetterIndex: string;
  alerting: ErrorAlertingConfig;
}

// Storage Configuration
export interface LogStorageConfig {
  backend: 'elasticsearch' | 'opensearch' | 'clickhouse' | 'loki' | 'bigquery' | 's3';
  configuration: StorageConfiguration;
  indexing: IndexingConfig;
  sharding: ShardingConfig;
  replication: ReplicationConfig;
  compression: StorageCompressionConfig;
}

export interface StorageConfiguration {
  hosts: string[];
  authentication: StorageAuthentication;
  connection: StorageConnection;
  performance: StoragePerformance;
}

export interface StorageAuthentication {
  type: 'none' | 'basic' | 'token' | 'cert' | 'iam';
  username?: string;
  password?: string;
  token?: string;
  certificatePath?: string;
  keyPath?: string;
  roleArn?: string;
}

export interface StorageConnection {
  timeout: string;
  retries: number;
  backoff: BackoffConfig;
  poolSize: number;
  keepAlive: boolean;
  ssl: SSLConfig;
}

export interface SSLConfig {
  enabled: boolean;
  certificatePath?: string;
  keyPath?: string;
  caPath?: string;
  verifyServerCert: boolean;
}

export interface StoragePerformance {
  bulkSize: number;
  bulkTimeout: string;
  refreshInterval: string;
  flushInterval: string;
  workers: number;
}

export interface IndexingConfig {
  strategy: 'time_based' | 'size_based' | 'custom';
  pattern: string;
  rollover: RolloverConfig;
  aliases: IndexAlias[];
  mappings: IndexMapping;
}

export interface RolloverConfig {
  enabled: boolean;
  maxSize: string;
  maxAge: string;
  maxDocs: number;
  conditions: RolloverCondition[];
}

export interface RolloverCondition {
  type: 'size' | 'age' | 'docs' | 'custom';
  value: unknown;
  operator: string;
}

export interface IndexAlias {
  name: string;
  pattern: string;
  writeIndex?: boolean;
  routing?: string;
  filter?: Record<string, any>;
}

export interface IndexMapping {
  properties: Record<string, FieldMapping>;
  dynamicTemplates: DynamicTemplate[];
  settings: IndexSettings;
}

export interface FieldMapping {
  type: string;
  index?: boolean;
  store?: boolean;
  analyzer?: string;
  format?: string;
  properties?: Record<string, FieldMapping>;
}

export interface DynamicTemplate {
  name: string;
  match?: string;
  matchMappingType?: string;
  pathMatch?: string;
  mapping: FieldMapping;
}

export interface IndexSettings {
  numberOfShards: number;
  numberOfReplicas: number;
  refreshInterval: string;
  maxResultWindow: number;
  analysis?: AnalysisSettings;
}

export interface AnalysisSettings {
  analyzers: Record<string, AnalyzerConfig>;
  tokenizers: Record<string, TokenizerConfig>;
  filters: Record<string, FilterConfig>;
}

export interface AnalyzerConfig {
  type: string;
  tokenizer: string;
  filters: string[];
}

export interface TokenizerConfig {
  type: string;
  configuration: Record<string, any>;
}

export interface FilterConfig {
  type: string;
  configuration: Record<string, any>;
}

export interface ShardingConfig {
  numberOfShards: number;
  numberOfReplicas: number;
  routingField?: string;
  allocationRules: AllocationRule[];
}

export interface AllocationRule {
  type: 'include' | 'exclude' | 'require';
  attribute: string;
  values: string[];
}

export interface ReplicationConfig {
  enabled: boolean;
  factor: number;
  crossRegion: boolean;
  consistency: 'one' | 'quorum' | 'all';
}

export interface StorageCompressionConfig {
  enabled: boolean;
  codec: 'lz4' | 'best_compression' | 'default';
  level: number;
}

// Retention Configuration
export interface LogRetentionPolicy {
  hotStorage: string;
  warmStorage: string;
  coldStorage: string;
  deletion: string;
  archival: ArchivalConfig;
  compliance: ComplianceConfig;
}

export interface ArchivalConfig {
  enabled: boolean;
  destination: 's3' | 'glacier' | 'azure' | 'gcs';
  configuration: ArchivalDestination;
  schedule: string;
  compression: boolean;
}

export interface ArchivalDestination {
  bucket: string;
  prefix: string;
  region: string;
  storageClass: string;
  encryption: ArchivalEncryption;
  lifecycle: ArchivalLifecycle;
}

export interface ArchivalEncryption {
  enabled: boolean;
  algorithm: string;
  keyId?: string;
  keyManagement: KeyManagementConfig;
}

export interface ArchivalLifecycle {
  transitions: LifecycleTransition[];
  expiration: LifecycleExpiration;
}

export interface LifecycleTransition {
  days: number;
  storageClass: string;
}

export interface LifecycleExpiration {
  days?: number;
  deleteMarkers?: boolean;
  incompleteMultipartUploads?: number;
}

export interface ComplianceConfig {
  enabled: boolean;
  standards: string[];
  dataClassification: DataClassification;
  accessControls: AccessControl[];
  auditLogging: boolean;
}

export interface DataClassification {
  level: 'public' | 'internal' | 'confidential' | 'restricted';
  categories: string[];
  sensitiveFields: string[];
  maskingRules: MaskingRule[];
}

export interface MaskingRule {
  field: string;
  strategy: 'hash' | 'encrypt' | 'redact' | 'tokenize';
  configuration: Record<string, any>;
}

export interface AccessControl {
  principal: string;
  actions: string[];
  resources: string[];
  conditions: AccessCondition[];
}

export interface AccessCondition {
  type: 'ip' | 'time' | 'mfa' | 'custom';
  operator: string;
  value: unknown;
}

// Forwarding Configuration
export interface LogForwardingConfig {
  enabled: boolean;
  destinations: ForwardingDestination[];
  filtering: ForwardingFilter[];
  batching: ForwardingBatching;
  errorHandling: ForwardingErrorHandling;
}

export interface ForwardingDestination {
  id: string;
  name: string;
  type: 'syslog' | 'http' | 'kafka' | 'elasticsearch' | 's3';
  configuration: DestinationConfiguration;
  authentication: DestinationAuthentication;
  healthCheck: DestinationHealthCheck;
}

export interface DestinationConfiguration {
  endpoint: string;
  port?: number;
  protocol?: string;
  format: string;
  customConfig?: Record<string, any>;
}

export interface DestinationAuthentication {
  type: 'none' | 'basic' | 'token' | 'cert' | 'oauth';
  credentials: Record<string, any>;
}

export interface DestinationHealthCheck {
  enabled: boolean;
  interval: string;
  timeout: string;
  retries: number;
  endpoint?: string;
}

export interface ForwardingFilter {
  type: 'include' | 'exclude';
  conditions: FilterCondition[];
  destinations: string[];
}

export interface ForwardingBatching {
  enabled: boolean;
  size: number;
  timeout: string;
  compression: boolean;
}

export interface ForwardingErrorHandling {
  strategy: 'retry' | 'drop' | 'dead_letter';
  maxRetries: number;
  retryDelay: string;
  deadLetterDestination?: string;
}