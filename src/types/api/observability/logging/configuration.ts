/**
 * Observability Logging Configuration Types
 * 
 * Type definitions for logging system configuration, collection setup,
 * processing pipelines, storage, and retention policies.
 * 
 * Generated by CC (Claude Code) - Modularized from logging-types.ts
 */

import type { BaseMetadata, AuditableMetadata } from '../../../shared/metadata-types';
import { PrimitiveValue, FilterValue, ConfigValue } from '../../shared/value-types';
import {
  BaseApiRequest,
  BaseApiResponse,
  CreateRequest,
  CreateResponse,
  MultiTenantContext
} from '../../shared';

// Logging Configuration API
export interface ConfigureLoggingRequest extends CreateRequest<LoggingConfigurationData> {
  flowId: string;
  data: LoggingConfigurationData;
  logSources: LogSource[];
  collection: LogCollectionConfig;
  processing: LogProcessingConfig;
  storage: LogStorageConfig;
  retention: LogRetentionPolicy;
  forwarding: LogForwardingConfig;
}

export interface ConfigureLoggingResponse extends CreateResponse<LoggingConfiguration> {
  data: LoggingConfiguration;
  configurationId: string;
  deploymentPlan: LoggingDeploymentPlan;
  estimatedVolume: LogVolumeEstimate;
  estimatedCost: LoggingCost;
}

// Core Configuration Types
export interface LoggingConfigurationData {
  name: string;
  description?: string;
  environment: string;
  version: string;
  settings: LoggingSettings;
  tags: Record<string, string>;
  metadata: AuditableMetadata;
}

export interface LoggingSettings {
  structured: boolean;
  jsonFormat: boolean;
  timestampFormat: string;
  timezone: string;
  includeStackTrace: boolean;
  maskSensitiveData: boolean;
  samplingEnabled: boolean;
}

export interface LoggingConfiguration {
  id: string;
  configurationId: string;
  name: string;
  description?: string;
  environment: string;
  version: string;
  sources: LogSource[];
  collection: LogCollectionConfig;
  processing: LogProcessingConfig;
  storage: LogStorageConfig;
  retention: LogRetentionPolicy;
  forwarding: LogForwardingConfig;
  status: 'draft' | 'validated' | 'deployed' | 'active' | 'inactive';
  createdAt: string;
  updatedAt: string;
  deployedAt?: string;
}

// Log Source Configuration
export interface LogSource {
  id: string;
  name: string;
  type: 'application' | 'system' | 'infrastructure' | 'security' | 'audit' | 'custom';
  source: string;
  format: LogFormat;
  parser: LogParser;
  filters: LogFilter[];
  enrichment: LogEnrichment;
  sampling: LogSampling;
  enabled: boolean;
}

export interface LogFormat {
  type: 'json' | 'text' | 'syslog' | 'apache' | 'nginx' | 'custom';
  pattern?: string;
  multiline?: MultilineConfig;
  delimiter?: string;
  escape?: string;
  quote?: string;
}

export interface MultilineConfig {
  pattern: string;
  negate: boolean;
  match: 'after' | 'before';
  maxLines: number;
  timeout: string;
}

export interface LogParser {
  type: 'grok' | 'json' | 'regex' | 'csv' | 'xml' | 'kv' | 'custom';
  configuration: ParserConfiguration;
  fieldMapping: FieldMapping[];
  typeConversion: TypeConversion[];
  errorHandling: ParserErrorHandling;
}

export interface ParserConfiguration {
  patterns?: Record<string, string>;
  delimiter?: string;
  quote?: string;
  escape?: string;
  skipHeaders?: boolean;
  trimWhitespace?: boolean;
  customConfig?: BaseMetadata;
}

export interface FieldMapping {
  source: string;
  target: string;
  type?: string;
  default?: ConfigValue;
}

export interface TypeConversion {
  field: string;
  from: string;
  to: string;
  format?: string;
}

export interface ParserErrorHandling {
  onFailure: 'drop' | 'tag' | 'route_to_dead_letter';
  tagField?: string;
  deadLetterDestination?: string;
  logErrors: boolean;
}

export interface LogFilter {
  type: 'include' | 'exclude' | 'transform' | 'route';
  condition: FilterCondition;
  action: FilterAction;
  priority: number;
  enabled: boolean;
}

export interface FilterCondition {
  field: string;
  operator: string;
  value: FilterValue;
  logicalOperator?: 'and' | 'or';
}

export interface FilterAction {
  type: 'pass' | 'drop' | 'modify' | 'route';
  modifications?: BaseMetadata;
  destination?: string;
}

export interface LogEnrichment {
  enabled: boolean;
  geoLocation: boolean;
  userAgent: boolean;
  dns: boolean;
  customFields: CustomField[];
  lookups: LookupConfig[];
}

export interface CustomField {
  name: string;
  value: string;
  type: 'static' | 'dynamic' | 'computed';
  condition?: string;
}

export interface LookupConfig {
  type: 'database' | 'file' | 'api' | 'cache';
  name: string;
  source: string;
  keyField: string;
  valueFields: string[];
  cacheTimeout?: string;
  fallback?: PrimitiveValue;
}

export interface LogSampling {
  enabled: boolean;
  rate: number;
  strategy: 'random' | 'deterministic' | 'adaptive' | 'rate_limit';
  preserveErrors: boolean;
  configuration: SamplingConfiguration;
}

export interface SamplingConfiguration {
  seed?: number;
  hashField?: string;
  adaptiveWindow?: string;
  rateLimitWindow?: string;
  preservePatterns?: string[];
}

// Collection Configuration
export interface LogCollectionConfig {
  agents: CollectionAgent[];
  protocols: CollectionProtocol[];
  buffering: BufferingConfig;
  compression: CompressionConfig;
  encryption: EncryptionConfig;
  batching: BatchingConfig;
  reliability: ReliabilityConfig;
}

export interface CollectionAgent {
  type: 'filebeat' | 'fluentd' | 'logstash' | 'vector' | 'custom';
  version: string;
  configuration: AgentConfiguration;
  resources: ResourceRequirements;
  deployment: AgentDeployment;
}

export interface AgentConfiguration {
  inputs: AgentInput[];
  outputs: AgentOutput[];
  processors: AgentProcessor[];
  monitoring: AgentMonitoring;
  customConfig?: BaseMetadata;
}

export interface AgentInput {
  type: string;
  path?: string;
  port?: number;
  configuration: BaseMetadata;
}

export interface AgentOutput {
  type: string;
  destination: string;
  configuration: BaseMetadata;
}

export interface AgentProcessor {
  type: string;
  configuration: BaseMetadata;
  order: number;
}

export interface AgentMonitoring {
  enabled: boolean;
  metricsPort?: number;
  healthCheckPath?: string;
  logLevel: string;
}

export interface ResourceRequirements {
  cpu: string;
  memory: string;
  disk: string;
  network: string;
}

export interface AgentDeployment {
  strategy: 'daemonset' | 'sidecar' | 'centralized';
  nodeSelector?: Record<string, string>;
  tolerations?: Toleration[];
  affinity?: Affinity;
}

export interface Toleration {
  key: string;
  operator: string;
  value?: string;
  effect: string;
}

export interface Affinity {
  nodeAffinity?: NodeAffinity;
  podAffinity?: PodAffinity;
  podAntiAffinity?: PodAntiAffinity;
}

export interface NodeAffinity {
  requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
}

export interface NodeSelector {
  nodeSelectorTerms: NodeSelectorTerm[];
}

export interface NodeSelectorTerm {
  matchExpressions?: NodeSelectorRequirement[];
  matchFields?: NodeSelectorRequirement[];
}

export interface NodeSelectorRequirement {
  key: string;
  operator: string;
  values?: string[];
}

export interface PreferredSchedulingTerm {
  weight: number;
  preference: NodeSelectorTerm;
}

export interface PodAffinity {
  requiredDuringSchedulingIgnoredDuringExecution?: PodAffinityTerm[];
  preferredDuringSchedulingIgnoredDuringExecution?: WeightedPodAffinityTerm[];
}

export interface PodAntiAffinity {
  requiredDuringSchedulingIgnoredDuringExecution?: PodAffinityTerm[];
  preferredDuringSchedulingIgnoredDuringExecution?: WeightedPodAffinityTerm[];
}

export interface PodAffinityTerm {
  labelSelector?: LabelSelector;
  namespaces?: string[];
  topologyKey: string;
}

export interface WeightedPodAffinityTerm {
  weight: number;
  podAffinityTerm: PodAffinityTerm;
}

export interface LabelSelector {
  matchLabels?: Record<string, string>;
  matchExpressions?: LabelSelectorRequirement[];
}

export interface LabelSelectorRequirement {
  key: string;
  operator: string;
  values?: string[];
}

export interface CollectionProtocol {
  type: 'syslog' | 'http' | 'tcp' | 'udp' | 'grpc' | 'kafka';
  port: number;
  ssl: boolean;
  authentication: ProtocolAuthentication;
  rateLimiting: ProtocolRateLimit;
}

export interface ProtocolAuthentication {
  enabled: boolean;
  type?: 'basic' | 'token' | 'cert' | 'oauth';
  credentials?: BaseMetadata;
  certificatePath?: string;
  keyPath?: string;
}

export interface ProtocolRateLimit {
  enabled: boolean;
  requestsPerSecond?: number;
  burstSize?: number;
  strategy?: 'fixed' | 'sliding';
}

export interface BufferingConfig {
  enabled: boolean;
  type: 'memory' | 'disk' | 'hybrid';
  size: string;
  flushInterval: string;
  maxEvents: number;
  persistOnShutdown: boolean;
}

export interface CompressionConfig {
  enabled: boolean;
  algorithm: 'gzip' | 'lz4' | 'snappy' | 'zstd';
  level: number;
}

export interface EncryptionConfig {
  enabled: boolean;
  algorithm: 'aes256' | 'chacha20';
  keyRotation: string;
  keyManagement: KeyManagementConfig;
}

export interface KeyManagementConfig {
  provider: 'vault' | 'aws_kms' | 'azure_kv' | 'gcp_kms' | 'local';
  configuration: BaseMetadata;
  autoRotation: boolean;
  rotationInterval?: string;
}

export interface BatchingConfig {
  enabled: boolean;
  size: number;
  timeout: string;
  maxSize: string;
  compression: boolean;
}

export interface ReliabilityConfig {
  acknowledgments: boolean;
  retries: number;
  backoff: BackoffConfig;
  deadLetterQueue: boolean;
  monitoring: ReliabilityMonitoring;
}

export interface BackoffConfig {
  strategy: 'fixed' | 'linear' | 'exponential';
  initialDelay: string;
  maxDelay: string;
  multiplier?: number;
}

export interface ReliabilityMonitoring {
  enabled: boolean;
  metrics: string[];
  alerting: ReliabilityAlerting;
}

export interface ReliabilityAlerting {
  enabled: boolean;
  thresholds: Record<string, number>;
  channels: string[];
}