/**
 * FinOps Cost Allocation and Chargeback Types
 * 
 * Type definitions for cost allocation configuration, chargeback models, and allocation execution.
 * Covers allocation rules, cost pools, chargeback reporting, and approval workflows.
 * 
 * Generated by CC (Claude Code) - Modularized from finops.ts
 */

import {
  BaseApiRequest,
  BaseApiResponse,
  MultiTenantContext,
  CreateRequest,
  CreateResponse
} from '../shared';
import { CostAmount } from './cost-analysis';

// Cost Allocation and Chargeback APIs
export interface ConfigureCostAllocationRequest extends CreateRequest<CostAllocationConfiguration> {
  flowId: string;
  data: CostAllocationConfiguration;
  allocationMethod: 'direct' | 'proportional' | 'activity_based' | 'shared_services';
  allocationRules: AllocationRule[];
  costPools: CostPool[];
  chargebackModel: ChargebackModel;
}

export interface ConfigureCostAllocationResponse extends CreateResponse<CostAllocation> {
  data: CostAllocation;
  allocationId: string;
  validationResults: AllocationValidationResult[];
  scheduleEnabled: boolean;
  reportingEnabled: boolean;
}

export interface ExecuteCostAllocationRequest extends BaseApiRequest {
  allocationId: string;
  period: {
    start: string;
    end: string;
  };
  dryRun?: boolean;
  includeApprovals?: boolean;
  context: MultiTenantContext;
}

export interface ExecuteCostAllocationResponse extends BaseApiResponse<CostAllocationExecution> {
  data: CostAllocationExecution;
  executionId: string;
  allocatedCosts: AllocatedCost[];
  chargebacks: Chargeback[];
  approvals: AllocationApproval[];
}

export interface GetChargebackReportRequest extends BaseApiRequest {
  flowId: string;
  period: {
    start: string;
    end: string;
  };
  recipients?: string[];
  costCategories?: string[];
  includeDetails?: boolean;
  format?: 'summary' | 'detailed' | 'itemized';
  context: MultiTenantContext;
}

export interface GetChargebackReportResponse extends BaseApiResponse<ChargebackReport> {
  data: ChargebackReport;
  reportId: string;
  chargebacks: ChargebackDetail[];
  summary: ChargebackSummary;
  approvals: ChargebackApproval[];
}

// Supporting Data Types
export interface CostAllocationConfiguration {
  id: string;
  flowId: string;
  name: string;
  description: string;
  allocationMethod: string;
  scope: AllocationScope;
  rules: AllocationRule[];
  costPools: CostPool[];
  chargebackModel: ChargebackModel;
  schedule: AllocationSchedule;
  reporting: AllocationReporting;
  approvals: AllocationApprovalConfig;
  metadata: Record<string, any>;
}

export interface CostAllocation extends CostAllocationConfiguration {
  allocationId: string;
  status: 'draft' | 'active' | 'inactive' | 'suspended' | 'archived';
  validation: AllocationValidation;
  executionHistory: AllocationExecutionSummary[];
  performance: AllocationPerformance;
  createdAt: string;
  updatedAt: string;
  createdBy: string;
  lastModifiedBy: string;
}

export interface AllocationScope {
  accounts: string[];
  services: string[];
  resources: string[];
  regions: string[];
  costCenters: string[];
  projects: string[];
  environments: string[];
  timeRange: {
    start: string;
    end: string;
  };
  filters: AllocationFilter[];
  exclusions: AllocationExclusion[];
}

export interface AllocationFilter {
  dimension: string;
  operator: 'equals' | 'not_equals' | 'contains' | 'in' | 'not_in';
  values: string[];
  description: string;
}

export interface AllocationExclusion {
  type: 'service' | 'resource' | 'account' | 'tag';
  values: string[];
  reason: string;
  temporary: boolean;
  expirationDate?: string;
}

export interface AllocationRule {
  id: string;
  name: string;
  description: string;
  priority: number;
  type: 'direct' | 'proportional' | 'fixed' | 'calculated';
  source: AllocationSource;
  targets: AllocationTarget[];
  allocation: AllocationLogic;
  conditions: AllocationCondition[];
  overrides: AllocationOverride[];
  validation: RuleValidation;
  enabled: boolean;
}

export interface AllocationSource {
  type: 'cost_pool' | 'service' | 'resource' | 'account' | 'tag';
  identifier: string;
  filters: AllocationFilter[];
  amount?: CostAmount;
}

export interface AllocationTarget {
  id: string;
  type: 'cost_center' | 'project' | 'department' | 'business_unit' | 'product';
  identifier: string;
  name: string;
  allocation: AllocationMethod;
  constraints: AllocationConstraint[];
}

export interface AllocationMethod {
  type: 'percentage' | 'fixed_amount' | 'usage_based' | 'resource_based' | 'activity_based';
  value: number;
  unit: string;
  basis: AllocationBasis;
  calculation: AllocationCalculation;
}

export interface AllocationBasis {
  metric: string;
  source: string;
  timeframe: string;
  aggregation: 'sum' | 'avg' | 'max' | 'weighted_avg';
  normalization: boolean;
}

export interface AllocationCalculation {
  formula: string;
  variables: AllocationVariable[];
  factors: AllocationFactor[];
  adjustments: AllocationAdjustment[];
}

export interface AllocationVariable {
  name: string;
  source: string;
  type: 'metric' | 'constant' | 'calculated';
  value?: number;
  refresh: string;
}

export interface AllocationFactor {
  name: string;
  type: 'multiplier' | 'divisor' | 'offset';
  value: number;
  condition?: string;
}

export interface AllocationAdjustment {
  type: 'seasonal' | 'promotional' | 'exceptional' | 'regulatory';
  value: number;
  period: string;
  justification: string;
  approval_required: boolean;
}

export interface AllocationConstraint {
  type: 'min_allocation' | 'max_allocation' | 'percentage_limit' | 'budget_limit';
  value: number;
  unit: string;
  enforcement: 'warning' | 'blocking' | 'override';
}

export interface AllocationLogic {
  method: string;
  parameters: Record<string, any>;
  distribution: DistributionLogic;
  rounding: RoundingLogic;
  residual: ResidualHandling;
}

export interface DistributionLogic {
  approach: 'proportional' | 'equal' | 'weighted' | 'tiered';
  weights: Record<string, number>;
  tiers: AllocationTier[];
  spillover: boolean;
}

export interface AllocationTier {
  threshold: number;
  rate: number;
  limit?: number;
}

export interface RoundingLogic {
  method: 'nearest' | 'up' | 'down' | 'banker';
  precision: number;
  currency_rules: boolean;
}

export interface ResidualHandling {
  method: 'proportional' | 'largest_first' | 'separate_bucket' | 'absorb';
  target?: string;
  threshold: number;
}

export interface AllocationCondition {
  type: 'time_based' | 'value_based' | 'tag_based' | 'dependency_based';
  condition: string;
  value?: any;
  operator: string;
  action: 'apply' | 'skip' | 'modify' | 'escalate';
}

export interface AllocationOverride {
  id: string;
  type: 'emergency' | 'business_exception' | 'correction' | 'adjustment';
  scope: AllocationOverrideScope;
  modification: AllocationModification;
  justification: string;
  approver: string;
  approvedAt: string;
  effectiveDate: string;
  expirationDate?: string;
}

export interface AllocationOverrideScope {
  targets: string[];
  period: string;
  amount?: CostAmount;
  percentage?: number;
}

export interface AllocationModification {
  type: 'replace' | 'add' | 'multiply' | 'adjust';
  value: number;
  operation: string;
}

export interface RuleValidation {
  checks: ValidationCheck[];
  tolerance: number;
  reconciliation: ReconciliationRule[];
  audit: AuditRequirement[];
}

export interface ValidationCheck {
  type: 'total_equals_source' | 'percentage_equals_100' | 'min_max_constraints' | 'circular_reference';
  enabled: boolean;
  tolerance: number;
  action: 'warning' | 'error' | 'block';
}

export interface ReconciliationRule {
  source: string;
  target: string;
  tolerance: number;
  frequency: string;
  automated: boolean;
}

export interface AuditRequirement {
  trigger: string;
  scope: string;
  documentation: string[];
  approval: boolean;
}

export interface CostPool {
  id: string;
  name: string;
  description: string;
  type: 'shared_services' | 'infrastructure' | 'overhead' | 'direct' | 'indirect';
  scope: CostPoolScope;
  allocation: CostPoolAllocation;
  drivers: CostDriver[];
  budget: CostPoolBudget;
  tracking: CostPoolTracking;
  governance: CostPoolGovernance;
}

export interface CostPoolScope {
  services: string[];
  resources: string[];
  accounts: string[];
  costCategories: string[];
  tags: Record<string, string>;
  timeframe: string;
}

export interface CostPoolAllocation {
  method: 'usage_based' | 'benefit_based' | 'capacity_based' | 'equal' | 'negotiated';
  drivers: string[];
  frequency: 'real_time' | 'daily' | 'weekly' | 'monthly';
  automation: boolean;
}

export interface CostDriver {
  id: string;
  name: string;
  type: 'usage' | 'capacity' | 'transaction' | 'headcount' | 'revenue' | 'custom';
  metric: string;
  source: string;
  weight: number;
  normalization: DriverNormalization;
  validation: DriverValidation;
}

export interface DriverNormalization {
  method: 'none' | 'min_max' | 'z_score' | 'percentage';
  baseline: number;
  factors: Record<string, number>;
}

export interface DriverValidation {
  range: {
    min: number;
    max: number;
  };
  outlier_detection: boolean;
  correlation_check: boolean;
  consistency_check: boolean;
}

export interface CostPoolBudget {
  totalBudget: CostAmount;
  allocation: BudgetAllocation[];
  tracking: boolean;
  variance: VarianceTracking;
}

export interface BudgetAllocation {
  target: string;
  amount: CostAmount;
  percentage: number;
  basis: string;
}

export interface VarianceTracking {
  threshold: number;
  frequency: string;
  escalation: string[];
  investigation: boolean;
}

export interface CostPoolTracking {
  metrics: string[];
  reporting: string[];
  alerts: PoolAlert[];
  dashboard: string;
}

export interface PoolAlert {
  metric: string;
  threshold: number;
  condition: string;
  severity: 'info' | 'warning' | 'critical';
  action: string;
}

export interface CostPoolGovernance {
  owner: string;
  stakeholders: string[];
  reviewFrequency: string;
  approvals: PoolApprovalConfig;
  audit: PoolAuditConfig;
}

export interface PoolApprovalConfig {
  required: string[];
  threshold: number;
  workflow: string;
  timeout: string;
}

export interface PoolAuditConfig {
  frequency: string;
  scope: string[];
  automated: boolean;
  documentation: string[];
}

export interface ChargebackModel {
  id: string;
  name: string;
  description: string;
  type: 'full_chargeback' | 'showback' | 'hybrid';
  methodology: ChargebackMethodology;
  pricing: ChargebackPricing;
  billing: ChargebackBilling;
  adjustments: ChargebackAdjustment[];
  governance: ChargebackGovernance;
}

export interface ChargebackMethodology {
  approach: 'actual_cost' | 'budgeted_cost' | 'market_rate' | 'negotiated_rate';
  basis: 'usage' | 'allocation' | 'subscription' | 'hybrid';
  granularity: 'service' | 'resource' | 'feature' | 'transaction';
  frequency: 'real_time' | 'daily' | 'weekly' | 'monthly';
}

export interface ChargebackPricing {
  model: 'unit_pricing' | 'tiered_pricing' | 'volume_pricing' | 'value_based';
  rates: PricingRate[];
  discounts: PricingDiscount[];
  premiums: PricingPremium[];
  adjustments: PricingAdjustment[];
}

export interface PricingRate {
  service: string;
  unit: string;
  rate: number;
  currency: string;
  effectiveDate: string;
  expirationDate?: string;
}

export interface PricingDiscount {
  type: 'volume' | 'commitment' | 'loyalty' | 'negotiated';
  threshold: number;
  rate: number;
  conditions: string[];
}

export interface PricingPremium {
  type: 'peak_hours' | 'rush_service' | 'priority' | 'sla';
  multiplier: number;
  conditions: string[];
}

export interface PricingAdjustment {
  type: 'inflation' | 'market' | 'cost_plus' | 'regulatory';
  value: number;
  frequency: string;
  automated: boolean;
}

export interface ChargebackBilling {
  cycle: 'monthly' | 'quarterly' | 'annually';
  timing: 'advance' | 'arrears';
  aggregation: BillingAggregation;
  format: BillingFormat;
  delivery: BillingDelivery;
  payment: BillingPayment;
}

export interface BillingAggregation {
  level: 'account' | 'project' | 'department' | 'cost_center';
  rollup: boolean;
  consolidation: string[];
  splitting: SplittingRule[];
}

export interface SplittingRule {
  condition: string;
  method: 'proportional' | 'equal' | 'weighted';
  targets: string[];
}

export interface BillingFormat {
  template: string;
  currency: string;
  precision: number;
  language: string;
  customizations: Record<string, any>;
}

export interface BillingDelivery {
  method: 'email' | 'portal' | 'api' | 'file_transfer';
  recipients: BillingRecipient[];
  schedule: BillingSchedule;
  notifications: BillingNotification[];
}

export interface BillingRecipient {
  type: 'primary' | 'cc' | 'approver' | 'finance';
  contact: string;
  format: string;
  customizations: Record<string, any>;
}

export interface BillingSchedule {
  day: number;
  time: string;
  timezone: string;
  advance_notice: number;
  retry_policy: RetryPolicy;
}

export interface RetryPolicy {
  attempts: number;
  interval: string;
  escalation: string[];
}

export interface BillingNotification {
  event: 'generated' | 'sent' | 'viewed' | 'paid' | 'overdue';
  recipients: string[];
  template: string;
  delay: string;
}

export interface BillingPayment {
  terms: string;
  methods: string[];
  automation: boolean;
  tracking: boolean;
  reconciliation: PaymentReconciliation;
}

export interface PaymentReconciliation {
  automated: boolean;
  tolerance: number;
  frequency: string;
  escalation: string[];
}

export interface ChargebackAdjustment {
  id: string;
  type: 'credit' | 'debit' | 'refund' | 'write_off';
  reason: string;
  amount: CostAmount;
  target: string;
  period: string;
  approval: AdjustmentApproval;
  documentation: string[];
}

export interface AdjustmentApproval {
  required: boolean;
  approver: string;
  status: 'pending' | 'approved' | 'rejected';
  approvedAt?: string;
  reason?: string;
}

export interface ChargebackGovernance {
  policies: string[];
  approvals: ChargebackApprovalConfig;
  dispute: DisputeProcess;
  audit: ChargebackAuditConfig;
  compliance: ComplianceConfig;
}

export interface ChargebackApprovalConfig {
  thresholds: ApprovalThreshold[];
  workflow: string;
  timeout: string;
  escalation: string[];
}

export interface ApprovalThreshold {
  type: 'amount' | 'percentage' | 'variance';
  value: number;
  approver: string;
  urgency: 'normal' | 'expedited' | 'emergency';
}

export interface DisputeProcess {
  enabled: boolean;
  timeLimit: string;
  workflow: string;
  escalation: string[];
  resolution: DisputeResolution;
}

export interface DisputeResolution {
  methods: string[];
  timeline: string;
  documentation: string[];
  finality: boolean;
}

export interface ChargebackAuditConfig {
  frequency: string;
  scope: string[];
  automated: boolean;
  external: boolean;
  documentation: string[];
}

export interface ComplianceConfig {
  standards: string[];
  requirements: string[];
  certifications: string[];
  reporting: ComplianceReporting;
}

export interface ComplianceReporting {
  frequency: string;
  recipients: string[];
  format: string;
  external: boolean;
}

export interface AllocationSchedule {
  frequency: 'real_time' | 'daily' | 'weekly' | 'monthly' | 'quarterly';
  timing: AllocationTiming;
  dependencies: ScheduleDependency[];
  automation: ScheduleAutomation;
  monitoring: ScheduleMonitoring;
}

export interface AllocationTiming {
  executionTime: string;
  timezone: string;
  businessDays: boolean;
  holidays: string[];
  cutoffTime: string;
}

export interface ScheduleDependency {
  type: 'data_availability' | 'approval' | 'external_system' | 'validation';
  source: string;
  timeout: string;
  action: 'wait' | 'proceed' | 'alert' | 'skip';
}

export interface ScheduleAutomation {
  enabled: boolean;
  failureHandling: FailureHandling;
  notifications: ScheduleNotification[];
  rollback: RollbackConfig;
}

export interface FailureHandling {
  retries: number;
  interval: string;
  escalation: string[];
  fallback: string;
}

export interface ScheduleNotification {
  event: 'start' | 'success' | 'failure' | 'delay';
  recipients: string[];
  channels: string[];
  template: string;
}

export interface RollbackConfig {
  automated: boolean;
  triggers: string[];
  approval: boolean;
  timeline: string;
}

export interface ScheduleMonitoring {
  metrics: string[];
  alerts: string[];
  dashboard: string;
  reporting: string;
}

export interface AllocationReporting {
  reports: AllocationReport[];
  dashboards: string[];
  exports: ReportExport[];
  distribution: ReportDistribution;
}

export interface AllocationReport {
  type: 'summary' | 'detailed' | 'variance' | 'audit';
  frequency: string;
  recipients: string[];
  format: string;
  customizations: Record<string, any>;
}

export interface ReportExport {
  format: 'csv' | 'excel' | 'pdf' | 'json' | 'xml';
  schedule: string;
  destination: string;
  encryption: boolean;
}

export interface ReportDistribution {
  internal: DistributionConfig;
  external: DistributionConfig;
  compliance: DistributionConfig;
}

export interface DistributionConfig {
  enabled: boolean;
  recipients: string[];
  schedule: string;
  security: string;
}

export interface AllocationApprovalConfig {
  required: string[];
  thresholds: AllocationApprovalThreshold[];
  workflow: string;
  timeout: string;
  escalation: string[];
}

export interface AllocationApprovalThreshold {
  type: 'amount' | 'percentage' | 'variance' | 'risk';
  value: number;
  approver: string;
  parallel: boolean;
}

export interface AllocationValidation {
  checks: AllocationValidationCheck[];
  tolerance: number;
  reconciliation: boolean;
  certification: ValidationCertification;
}

export interface AllocationValidationCheck {
  name: string;
  type: 'mathematical' | 'business' | 'compliance' | 'technical';
  enabled: boolean;
  tolerance: number;
  action: 'warning' | 'error' | 'block';
}

export interface ValidationCertification {
  required: boolean;
  certifier: string;
  frequency: string;
  documentation: string[];
}

export interface AllocationValidationResult {
  check: string;
  status: 'passed' | 'failed' | 'warning';
  result: ValidationResult;
  details: string;
  recommendation: string;
}

export interface ValidationResult {
  expected: number;
  actual: number;
  variance: number;
  tolerance: number;
  significance: 'low' | 'medium' | 'high';
}

export interface AllocationExecutionSummary {
  executionId: string;
  period: string;
  status: 'success' | 'failure' | 'partial';
  duration: string;
  recordsProcessed: number;
  totalAllocated: CostAmount;
  issues: ExecutionIssue[];
}

export interface ExecutionIssue {
  type: 'validation' | 'data' | 'calculation' | 'system';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  resolution: string;
}

export interface AllocationPerformance {
  executionTime: PerformanceMetric;
  dataQuality: QualityMetric;
  accuracy: AccuracyMetric;
  efficiency: EfficiencyMetric;
}

export interface PerformanceMetric {
  average: number;
  trend: 'improving' | 'stable' | 'degrading';
  target: number;
  unit: string;
}

export interface QualityMetric {
  completeness: number;
  accuracy: number;
  consistency: number;
  timeliness: number;
}

export interface AccuracyMetric {
  reconciliation: number;
  variance: number;
  corrections: number;
  confidence: number;
}

export interface EfficiencyMetric {
  automation: number;
  manual_effort: number;
  cost_per_allocation: number;
  processing_rate: number;
}

export interface CostAllocationExecution {
  id: string;
  allocationId: string;
  period: string;
  status: 'running' | 'completed' | 'failed' | 'cancelled';
  startedAt: string;
  completedAt?: string;
  summary: ExecutionSummary;
  results: ExecutionResult[];
  issues: ExecutionIssue[];
  validation: ExecutionValidation;
}

export interface ExecutionSummary {
  totalAmount: CostAmount;
  allocatedAmount: CostAmount;
  unallocatedAmount: CostAmount;
  targetsProcessed: number;
  rulesApplied: number;
  exceptions: number;
}

export interface ExecutionResult {
  ruleId: string;
  source: string;
  targets: AllocationResultTarget[];
  totalAllocated: CostAmount;
  variance: number;
  issues: string[];
}

export interface AllocationResultTarget {
  targetId: string;
  name: string;
  allocatedAmount: CostAmount;
  percentage: number;
  basis: string;
  calculation: string;
}

export interface ExecutionValidation {
  overall: 'passed' | 'failed' | 'warning';
  checks: ExecutionValidationCheck[];
  reconciliation: ReconciliationResult;
  certification: CertificationResult;
}

export interface ExecutionValidationCheck {
  name: string;
  status: 'passed' | 'failed' | 'warning';
  expected: number;
  actual: number;
  variance: number;
  acceptable: boolean;
}

export interface ReconciliationResult {
  status: 'balanced' | 'unbalanced' | 'under_tolerance';
  variance: CostAmount;
  tolerance: number;
  adjustments: ReconciliationAdjustment[];
}

export interface ReconciliationAdjustment {
  type: 'rounding' | 'residual' | 'correction';
  amount: CostAmount;
  target: string;
  reason: string;
}

export interface CertificationResult {
  required: boolean;
  status: 'certified' | 'pending' | 'rejected';
  certifier: string;
  certifiedAt?: string;
  conditions: string[];
}

export interface AllocatedCost {
  id: string;
  source: CostSource;
  target: CostTarget;
  amount: CostAmount;
  allocation: AllocationDetail;
  period: string;
  validation: AllocationValidation;
}

export interface CostSource {
  type: 'service' | 'resource' | 'pool' | 'account';
  identifier: string;
  name: string;
  originalAmount: CostAmount;
  tags: Record<string, string>;
}

export interface CostTarget {
  type: 'cost_center' | 'project' | 'department' | 'business_unit';
  identifier: string;
  name: string;
  allocation_basis: string;
  tags: Record<string, string>;
}

export interface AllocationDetail {
  method: string;
  basis: string;
  percentage: number;
  driver_value: number;
  calculation: string;
  overrides: string[];
}

export interface Chargeback {
  id: string;
  target: ChargebackTarget;
  period: string;
  amount: CostAmount;
  items: ChargebackItem[];
  adjustments: ChargebackItemAdjustment[];
  billing: ChargebackBilling;
  status: ChargebackStatus;
}

export interface ChargebackTarget {
  type: 'cost_center' | 'project' | 'department' | 'external';
  identifier: string;
  name: string;
  contact: string;
  billing_address: BillingAddress;
}

export interface BillingAddress {
  name: string;
  address: string[];
  city: string;
  state: string;
  country: string;
  postal_code: string;
}

export interface ChargebackItem {
  id: string;
  service: string;
  description: string;
  quantity: number;
  unit: string;
  rate: number;
  amount: CostAmount;
  period: string;
  tags: Record<string, string>;
}

export interface ChargebackItemAdjustment {
  type: 'discount' | 'credit' | 'tax' | 'fee';
  description: string;
  amount: CostAmount;
  rate?: number;
  basis?: string;
}

export interface ChargebackStatus {
  billing: 'draft' | 'generated' | 'sent' | 'disputed' | 'paid' | 'overdue';
  approval: 'pending' | 'approved' | 'rejected' | 'conditional';
  payment: 'pending' | 'processing' | 'paid' | 'failed' | 'disputed';
  collection: 'current' | 'overdue' | 'collections' | 'written_off';
}

export interface AllocationApproval {
  id: string;
  type: 'execution' | 'adjustment' | 'exception' | 'override';
  status: 'pending' | 'approved' | 'rejected' | 'expired';
  approver: string;
  requestedAt: string;
  approvedAt?: string;
  rejectedAt?: string;
  amount?: CostAmount;
  justification: string;
  conditions: string[];
}

export interface ChargebackReport {
  id: string;
  flowId: string;
  period: string;
  type: 'summary' | 'detailed' | 'itemized' | 'variance';
  scope: ChargebackReportScope;
  summary: ChargebackSummary;
  details: ChargebackDetail[];
  analytics: ChargebackAnalytics;
  generatedAt: string;
}

export interface ChargebackReportScope {
  targets: string[];
  services: string[];
  cost_categories: string[];
  period: string;
  currency: string;
}

export interface ChargebackSummary {
  totalAmount: CostAmount;
  totalTargets: number;
  totalItems: number;
  averageChargeback: CostAmount;
  topChargebacks: TopChargeback[];
  trends: ChargebackTrend[];
}

export interface TopChargeback {
  target: string;
  amount: CostAmount;
  percentage: number;
  items: number;
}

export interface ChargebackTrend {
  metric: string;
  direction: 'increasing' | 'decreasing' | 'stable';
  rate: number;
  significance: 'low' | 'medium' | 'high';
}

export interface ChargebackDetail {
  target: ChargebackTarget;
  totalAmount: CostAmount;
  items: ChargebackItem[];
  adjustments: ChargebackItemAdjustment[];
  payment: PaymentDetail;
  dispute?: DisputeDetail;
}

export interface PaymentDetail {
  status: string;
  method: string;
  dueDate: string;
  paidDate?: string;
  amount: CostAmount;
  fees: CostAmount;
}

export interface DisputeDetail {
  id: string;
  reason: string;
  amount: CostAmount;
  status: string;
  submittedAt: string;
  resolvedAt?: string;
  resolution: string;
}

export interface ChargebackAnalytics {
  utilization: UtilizationAnalytics;
  trends: TrendAnalytics;
  efficiency: EfficiencyAnalytics;
  satisfaction: SatisfactionAnalytics;
}

export interface UtilizationAnalytics {
  byService: ServiceUtilization[];
  byTarget: TargetUtilization[];
  patterns: UsagePattern[];
}

export interface ServiceUtilization {
  service: string;
  usage: number;
  cost: CostAmount;
  efficiency: number;
  trend: string;
}

export interface TargetUtilization {
  target: string;
  usage: number;
  cost: CostAmount;
  budget: CostAmount;
  variance: number;
}

export interface UsagePattern {
  type: 'seasonal' | 'growth' | 'cyclical' | 'irregular';
  description: string;
  confidence: number;
  impact: string;
}

export interface TrendAnalytics {
  cost: CostTrendAnalytics;
  usage: UsageTrendAnalytics;
  efficiency: EfficiencyTrendAnalytics;
}

export interface CostTrendAnalytics {
  direction: string;
  rate: number;
  forecast: CostAmount;
  drivers: string[];
}

export interface UsageTrendAnalytics {
  direction: string;
  rate: number;
  forecast: number;
  patterns: string[];
}

export interface EfficiencyTrendAnalytics {
  direction: string;
  rate: number;
  benchmark: number;
  opportunities: string[];
}

export interface EfficiencyAnalytics {
  overall: number;
  byService: Record<string, number>;
  byTarget: Record<string, number>;
  benchmarks: Record<string, number>;
}

export interface SatisfactionAnalytics {
  overall: number;
  byTarget: Record<string, number>;
  feedback: FeedbackSummary[];
  improvements: string[];
}

export interface FeedbackSummary {
  category: string;
  rating: number;
  comments: string[];
  trends: string;
}

export interface ChargebackApproval {
  id: string;
  chargebackId: string;
  type: 'amount' | 'allocation' | 'adjustment' | 'dispute';
  status: 'pending' | 'approved' | 'rejected' | 'conditional';
  approver: string;
  requestedAt: string;
  approvedAt?: string;
  rejectedAt?: string;
  amount?: CostAmount;
  conditions: string[];
  justification: string;
}