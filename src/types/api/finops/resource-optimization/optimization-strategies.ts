/**
 * FinOps Resource Optimization Strategies Types
 * 
 * Type definitions for resource optimization strategies, constraints, and objectives.
 * Covers optimization approaches, allocation strategies, and resource state management.
 * 
 * Generated by CC (Claude Code) - Modularized from resource-optimization.ts
 */

import {
  BaseApiRequest,
  BaseApiResponse,
  MultiTenantContext
} from '../../shared';
import { CostAmount } from '../cost-analysis';
import {
  ResourceConfiguration
} from './resource-discovery';
import type { ConfigurationValue, TypedConstraint } from '../../../shared/config-types';

// Resource Allocation Optimization APIs
export interface OptimizeResourceAllocationRequest extends BaseApiRequest {
  analysisId: string;
  optimizationStrategy: ResourceOptimizationStrategy;
  constraints: ResourceConstraint[];
  objectives: ResourceObjective[];
  simulateOnly?: boolean;
  context: MultiTenantContext;
}

export interface OptimizeResourceAllocationResponse extends BaseApiResponse<ResourceOptimization> {
  data: ResourceOptimization;
  optimizationId: string;
  currentAllocation: ResourceAllocation;
  optimizedAllocation: ResourceAllocation;
  projectedSavings: CostAmount;
  implementationPlan: import('./implementation-planning').ResourceImplementationPlan;
}

export interface ResourceOptimizationStrategy {
  objective: 'cost' | 'performance' | 'balanced' | 'sustainability';
  approach: 'conservative' | 'moderate' | 'aggressive';
  constraints: OptimizationConstraint[];
  priorities: OptimizationPriority[];
  timeframe: string;
}

export interface OptimizationConstraint extends Omit<TypedConstraint, 'type' | 'impact'> {
  type: 'budget' | 'performance' | 'availability' | 'compliance';
  mandatory: boolean;
}

export interface OptimizationPriority {
  dimension: string;
  weight: number;
  direction: 'minimize' | 'maximize';
}

export interface ResourceConstraint extends Omit<TypedConstraint, 'type' | 'impact'> {
  type: 'capacity' | 'performance' | 'location' | 'compliance' | 'budget';
  flexibility: 'none' | 'low' | 'medium' | 'high';
}

export interface ResourceObjective {
  type: 'cost_reduction' | 'performance_improvement' | 'capacity_optimization';
  target: number;
  unit: string;
  timeframe: string;
  priority: number;
}

export interface ResourceOptimization {
  id: string;
  strategy: ResourceOptimizationStrategy;
  currentState: ResourceState;
  optimizedState: ResourceState;
  changes: ResourceChange[];
  impact: OptimizationImpact;
  implementation: import('./implementation-planning').ResourceImplementationPlan;
  validation: OptimizationValidation;
}

export interface ResourceState {
  resources: ResourceStateDetail[];
  totalCost: CostAmount;
  totalCapacity: Record<string, number>;
  utilization: Record<string, number>;
  performance: Record<string, number>;
}

export interface ResourceStateDetail {
  resourceId: string;
  configuration: ResourceConfiguration;
  cost: CostAmount;
  utilization: Record<string, number>;
  performance: Record<string, number>;
}

export interface ResourceChange {
  resourceId: string;
  type: 'resize' | 'terminate' | 'migrate' | 'reconfigure';
  from: ResourceConfiguration;
  to: ResourceConfiguration;
  impact: ChangeImpact;
  complexity: 'low' | 'medium' | 'high';
  risk: 'low' | 'medium' | 'high';
}

export interface ChangeImpact {
  cost: CostAmount;
  performance: Record<string, number>;
  availability: string;
  dependencies: string[];
}

export interface OptimizationImpact {
  costSavings: CostAmount;
  performanceChange: Record<string, number>;
  capacityChange: Record<string, number>;
  utilizationImprovement: Record<string, number>;
  riskAssessment: RiskAssessment;
}

export interface RiskAssessment {
  overallRisk: 'low' | 'medium' | 'high';
  risks: Risk[];
  mitigations: Mitigation[];
}

export interface Risk {
  type: 'performance' | 'availability' | 'cost' | 'operational';
  description: string;
  likelihood: 'low' | 'medium' | 'high';
  impact: 'low' | 'medium' | 'high';
}

export interface Mitigation {
  risk: string;
  strategy: string;
  cost: CostAmount;
  effectiveness: number;
}

export interface ResourceAllocation {
  resources: AllocationDetail[];
  totalCost: CostAmount;
  efficiency: number;
  utilization: Record<string, number>;
  constraints: ConstraintStatus[];
}

export interface AllocationDetail {
  resourceId: string;
  allocation: ResourceConfiguration;
  cost: CostAmount;
  utilization: Record<string, number>;
  efficiency: number;
}

export interface ConstraintStatus {
  constraint: string;
  status: 'satisfied' | 'violated' | 'at_risk';
  value: ConfigurationValue;
  limit: ConfigurationValue;
}

export interface OptimizationValidation {
  status: 'passed' | 'failed' | 'partial';
  checks: import('./implementation-planning').ValidationResult[];
  score: number;
  issues: string[];
}