/**
 * FinOps Cost Optimization Types
 * 
 * Type definitions for cost optimization identification, planning, and execution.
 * Covers optimization opportunities, implementation plans, and execution tracking.
 * 
 * Generated by CC (Claude Code) - Modularized from finops.ts
 */

import {
  BaseApiRequest,
  BaseApiResponse,
  MultiTenantContext,
  CreateRequest,
  CreateResponse,
  GetRequest,
  GetResponse
} from '../shared';
import { CostAmount } from './cost-analysis';

// Cost Optimization APIs
export interface IdentifyOptimizationsRequest extends BaseApiRequest {
  flowId: string;
  optimizationTypes: OptimizationType[];
  scope: OptimizationScope;
  constraints: OptimizationConstraint[];
  targets: OptimizationTarget[];
  riskTolerance: 'low' | 'medium' | 'high';
  includeAutomated?: boolean;
  context: MultiTenantContext;
}

export interface IdentifyOptimizationsResponse extends BaseApiResponse<OptimizationOpportunity[]> {
  data: OptimizationOpportunity[];
  totalPotentialSavings: CostAmount;
  highImpactOpportunities: OptimizationOpportunity[];
  quickWins: OptimizationOpportunity[];
  riskAssessment: OptimizationRiskAssessment;
}

export interface CreateOptimizationPlanRequest extends CreateRequest<OptimizationPlanData> {
  flowId: string;
  data: OptimizationPlanData;
  opportunities: string[];
  prioritization: OptimizationPrioritization;
  timeline: OptimizationTimeline;
  approvals: OptimizationApproval[];
  rollbackPlan?: RollbackPlan;
}

export interface CreateOptimizationPlanResponse extends CreateResponse<OptimizationPlan> {
  data: OptimizationPlan;
  planId: string;
  executionPlan: OptimizationExecutionPlan;
  riskMitigation: RiskMitigationPlan;
  approvalWorkflow: ApprovalWorkflow;
}

export interface ExecuteOptimizationRequest extends BaseApiRequest {
  planId: string;
  optimizationIds?: string[];
  executionMode: 'simulate' | 'implement' | 'rollback';
  approvalOverride?: boolean;
  monitoringEnabled?: boolean;
  context: MultiTenantContext;
}

export interface ExecuteOptimizationResponse extends BaseApiResponse<OptimizationExecution> {
  data: OptimizationExecution;
  executionId: string;
  status: OptimizationExecutionStatus;
  estimatedSavings: CostAmount;
  monitoringDashboard?: string;
}

export interface GetOptimizationResultsRequest extends GetRequest {
  executionId: string;
  includeMetrics?: boolean;
  includeSavings?: boolean;
  includeImpact?: boolean;
  includeValidation?: boolean;
  timeRange?: {
    start: string;
    end: string;
  };
}

export interface GetOptimizationResultsResponse extends GetResponse<OptimizationResults> {
  data: OptimizationResults;
  actualSavings: CostAmount;
  impactAnalysis: OptimizationImpactAnalysis;
  validation: OptimizationValidation;
  recommendations: PostOptimizationRecommendation[];
}

// Supporting Data Types
export type OptimizationType = 
  | 'rightsizing' | 'scheduling' | 'purchasing_options' | 'architecture'
  | 'resource_cleanup' | 'storage_optimization' | 'network_optimization';

export type OptimizationExecutionStatus = 
  | 'planned' | 'simulating' | 'approved' | 'implementing'
  | 'monitoring' | 'completed' | 'failed' | 'rolled_back';

export interface OptimizationOpportunity {
  id: string;
  type: OptimizationType;
  name: string;
  description: string;
  scope: OptimizationScope;
  estimatedSavings: CostAmount;
  confidence: number;
  effort: 'low' | 'medium' | 'high';
  risk: 'low' | 'medium' | 'high';
  timeToValue: string;
  prerequisites: string[];
  implementation: OptimizationImplementation;
  validation: OptimizationValidationCriteria;
  metadata: Record<string, any>;
}

export interface OptimizationScope {
  accounts: string[];
  services: string[];
  resources: string[];
  regions: string[];
  projects: string[];
  environments: string[];
  tags: Record<string, string>;
  exclusions: string[];
}

export interface OptimizationConstraint {
  type: 'performance' | 'availability' | 'security' | 'compliance' | 'operational';
  description: string;
  value: any;
  operator: string;
  mandatory: boolean;
  exceptions: string[];
}

export interface OptimizationTarget {
  type: 'cost_reduction' | 'efficiency_improvement' | 'performance_optimization';
  value: number;
  unit: string;
  timeframe: string;
  priority: number;
}

export interface OptimizationRiskAssessment {
  overallRisk: 'low' | 'medium' | 'high' | 'critical';
  riskFactors: RiskFactor[];
  mitigationStrategies: MitigationStrategy[];
  rollbackComplexity: 'simple' | 'moderate' | 'complex';
  impactAssessment: ImpactAssessment;
}

export interface RiskFactor {
  type: 'performance' | 'availability' | 'security' | 'operational' | 'financial';
  description: string;
  likelihood: 'low' | 'medium' | 'high';
  impact: 'low' | 'medium' | 'high';
  mitigation: string;
}

export interface MitigationStrategy {
  risk: string;
  strategy: string;
  cost: CostAmount;
  timeline: string;
  effectiveness: number;
}

export interface ImpactAssessment {
  performance: PerformanceImpact;
  availability: AvailabilityImpact;
  security: SecurityImpact;
  operational: OperationalImpact;
  financial: FinancialImpact;
}

export interface OptimizationImpactAnalysis {
  costSavings: CostAmount;
  performanceChange: Record<string, number>;
  capacityChange: Record<string, number>;
  utilizationImprovement: Record<string, number>;
  riskAssessment: OptimizationRiskAssessmentSummary;
}

export interface OptimizationRiskAssessmentSummary {
  overallRisk: 'low' | 'medium' | 'high';
  risks: Risk[];
  mitigations: Mitigation[];
}

export interface Risk {
  type: 'performance' | 'availability' | 'cost' | 'operational';
  description: string;
  likelihood: 'low' | 'medium' | 'high';
  impact: 'low' | 'medium' | 'high';
}

export interface Mitigation {
  risk: string;
  strategy: string;
  cost: CostAmount;
  effectiveness: number;
}

export interface PerformanceImpact {
  level: 'none' | 'minimal' | 'moderate' | 'significant';
  description: string;
  metrics: string[];
  baseline: Record<string, number>;
  projected: Record<string, number>;
}

export interface AvailabilityImpact {
  level: 'none' | 'minimal' | 'moderate' | 'significant';
  description: string;
  slaImpact: boolean;
  downtimeRisk: string;
  mitigations: string[];
}

export interface SecurityImpact {
  level: 'none' | 'minimal' | 'moderate' | 'significant';
  description: string;
  securityRisks: string[];
  complianceImpact: string[];
  mitigations: string[];
}

export interface OperationalImpact {
  level: 'none' | 'minimal' | 'moderate' | 'significant';
  description: string;
  processChanges: string[];
  skillRequirements: string[];
  toolingChanges: string[];
}

export interface FinancialImpact {
  savings: CostAmount;
  costs: CostAmount;
  netBenefit: CostAmount;
  roi: number;
  paybackPeriod: string;
  cashFlowImpact: CashFlowImpact[];
}

export interface CashFlowImpact {
  period: string;
  inflow: CostAmount;
  outflow: CostAmount;
  net: CostAmount;
}

export interface OptimizationPlanData {
  id: string;
  flowId: string;
  name: string;
  description: string;
  objectives: string[];
  opportunities: string[];
  prioritization: OptimizationPrioritization;
  timeline: OptimizationTimeline;
  budget: CostAmount;
  approvals: OptimizationApproval[];
  rollbackPlan: RollbackPlan;
  metadata: Record<string, any>;
}

export interface OptimizationPlan extends OptimizationPlanData {
  planId: string;
  status: 'draft' | 'review' | 'approved' | 'executing' | 'completed' | 'failed' | 'cancelled';
  totalEstimatedSavings: CostAmount;
  totalImplementationCost: CostAmount;
  netBenefit: CostAmount;
  riskAssessment: OptimizationRiskAssessment;
  executionPlan: OptimizationExecutionPlan;
  createdAt: string;
  updatedAt: string;
  approvedAt?: string;
  approvedBy?: string;
}

export interface OptimizationPrioritization {
  method: 'roi' | 'effort' | 'risk' | 'savings' | 'custom';
  criteria: PrioritizationCriteria[];
  weights: Record<string, number>;
  phases: OptimizationPhase[];
}

export interface PrioritizationCriteria {
  name: string;
  type: 'savings' | 'effort' | 'risk' | 'time' | 'impact';
  weight: number;
  direction: 'ascending' | 'descending';
}

export interface OptimizationPhase {
  id: string;
  name: string;
  description: string;
  opportunities: string[];
  estimatedDuration: string;
  estimatedSavings: CostAmount;
  prerequisites: string[];
  dependencies: string[];
}

export interface OptimizationTimeline {
  startDate: string;
  endDate: string;
  phases: PhaseTimeline[];
  milestones: Milestone[];
  dependencies: Dependency[];
  criticalPath: string[];
}

export interface PhaseTimeline {
  phaseId: string;
  name: string;
  startDate: string;
  endDate: string;
  duration: string;
  tasks: TaskTimeline[];
}

export interface TaskTimeline {
  id: string;
  name: string;
  startDate: string;
  endDate: string;
  duration: string;
  assignee: string;
  dependencies: string[];
}

export interface Milestone {
  id: string;
  name: string;
  date: string;
  type: 'phase_completion' | 'savings_target' | 'approval' | 'validation';
  criteria: string[];
}

export interface Dependency {
  id: string;
  type: 'start_to_start' | 'start_to_finish' | 'finish_to_start' | 'finish_to_finish';
  predecessor: string;
  successor: string;
  lag: string;
}

export interface OptimizationApproval {
  id: string;
  type: 'plan' | 'execution' | 'budget' | 'change';
  status: 'pending' | 'approved' | 'rejected' | 'conditional';
  approver: string;
  requestedAt: string;
  approvedAt?: string;
  rejectedAt?: string;
  conditions?: string[];
  reason?: string;
}

export interface RollbackPlan {
  triggers: RollbackTrigger[];
  procedures: RollbackProcedure[];
  timeline: string;
  validationSteps: string[];
  communicationPlan: CommunicationPlan;
}

export interface RollbackTrigger {
  type: 'performance_degradation' | 'cost_increase' | 'availability_impact' | 'manual';
  threshold: any;
  automated: boolean;
  description: string;
}

export interface RollbackProcedure {
  step: number;
  description: string;
  commands: string[];
  validation: string;
  rollbackTime: string;
}

export interface CommunicationPlan {
  stakeholders: string[];
  channels: string[];
  templates: string[];
  escalation: string[];
}

export interface OptimizationExecutionPlan {
  phases: ExecutionPhase[];
  tasks: ExecutionTask[];
  validations: ExecutionValidation[];
  monitoring: ExecutionMonitoring;
  rollback: ExecutionRollback;
}

export interface ExecutionPhase {
  id: string;
  name: string;
  tasks: string[];
  startConditions: string[];
  exitCriteria: string[];
  rollbackTriggers: string[];
}

export interface ExecutionTask {
  id: string;
  name: string;
  type: 'manual' | 'automated' | 'approval';
  description: string;
  commands: string[];
  validation: string[];
  rollback: string[];
  assignee: string;
  estimatedDuration: string;
}

export interface ExecutionValidation {
  id: string;
  name: string;
  type: 'pre_execution' | 'post_execution' | 'continuous';
  criteria: ValidationCriteria[];
  automated: boolean;
  frequency: string;
}

export interface ValidationCriteria {
  metric: string;
  operator: string;
  value: any;
  tolerance: number;
  critical: boolean;
}

export interface ExecutionMonitoring {
  metrics: string[];
  dashboards: string[];
  alerts: MonitoringAlert[];
  reporting: MonitoringReporting;
}

export interface MonitoringAlert {
  metric: string;
  condition: string;
  threshold: any;
  severity: 'info' | 'warning' | 'error' | 'critical';
  actions: string[];
}

export interface MonitoringReporting {
  frequency: string;
  recipients: string[];
  format: string;
  metrics: string[];
}

export interface ExecutionRollback {
  automaticTriggers: string[];
  manualTriggers: string[];
  procedures: string[];
  validation: string[];
  timeline: string;
}

export interface RiskMitigationPlan {
  risks: IdentifiedRisk[];
  strategies: MitigationStrategy[];
  contingencies: ContingencyPlan[];
  monitoring: RiskMonitoring;
}

export interface IdentifiedRisk {
  id: string;
  type: string;
  description: string;
  likelihood: 'low' | 'medium' | 'high';
  impact: 'low' | 'medium' | 'high';
  mitigation: string;
  owner: string;
}

export interface ContingencyPlan {
  trigger: string;
  actions: string[];
  timeline: string;
  resources: string[];
}

export interface RiskMonitoring {
  indicators: string[];
  thresholds: Record<string, any>;
  frequency: string;
  escalation: string[];
}

export interface ApprovalWorkflow {
  steps: ApprovalStep[];
  parallel: boolean;
  timeout: string;
  escalation: EscalationRule[];
}

export interface ApprovalStep {
  id: string;
  name: string;
  approvers: string[];
  required: number;
  timeout: string;
  criteria: string[];
}

export interface EscalationRule {
  trigger: string;
  escalateTo: string[];
  timeout: string;
  actions: string[];
}

export interface OptimizationExecution {
  id: string;
  planId: string;
  status: OptimizationExecutionStatus;
  startedAt: string;
  completedAt?: string;
  progress: number;
  currentPhase: string;
  executedTasks: ExecutedTask[];
  validationResults: ValidationResult[];
  metrics: ExecutionMetrics;
  issues: ExecutionIssue[];
}

export interface ExecutedTask {
  taskId: string;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';
  startedAt: string;
  completedAt?: string;
  output: string;
  errors: string[];
}

export interface ValidationResult {
  validationId: string;
  status: 'passed' | 'failed' | 'warning';
  results: Record<string, any>;
  timestamp: string;
}

export interface ExecutionMetrics {
  tasksCompleted: number;
  totalTasks: number;
  successRate: number;
  averageTaskDuration: string;
  totalExecutionTime: string;
  resourcesModified: number;
}

export interface ExecutionIssue {
  id: string;
  type: 'error' | 'warning' | 'info';
  description: string;
  impact: 'low' | 'medium' | 'high';
  resolution: string;
  timestamp: string;
}

export interface OptimizationResults {
  executionId: string;
  status: 'success' | 'partial' | 'failed';
  actualSavings: CostAmount;
  projectedSavings: CostAmount;
  savingsRealization: number;
  optimizationsCompleted: number;
  optimizationsTotal: number;
  metrics: ResultMetrics;
  validation: OptimizationValidation;
  recommendations: PostOptimizationRecommendation[];
  generatedAt: string;
}

export interface ResultMetrics {
  costSavings: CostAmount;
  performanceImpact: Record<string, number>;
  utilizationImprovement: Record<string, number>;
  resourcesOptimized: number;
  timeToValue: string;
}

export interface OptimizationValidation {
  overallStatus: 'passed' | 'failed' | 'partial';
  validationResults: ValidationSummary[];
  performanceValidation: PerformanceValidation;
  costValidation: CostValidation;
  complianceValidation: ComplianceValidation;
}

export interface ValidationSummary {
  category: string;
  status: 'passed' | 'failed' | 'warning';
  score: number;
  details: string[];
}

export interface PerformanceValidation {
  baseline: Record<string, number>;
  current: Record<string, number>;
  delta: Record<string, number>;
  passed: boolean;
  issues: string[];
}

export interface CostValidation {
  expectedSavings: CostAmount;
  actualSavings: CostAmount;
  variance: CostAmount;
  realizationRate: number;
  passed: boolean;
}

export interface ComplianceValidation {
  policies: PolicyValidation[];
  overallCompliance: boolean;
  violations: string[];
  recommendations: string[];
}

export interface PolicyValidation {
  policyId: string;
  name: string;
  compliant: boolean;
  violations: string[];
}

export interface PostOptimizationRecommendation {
  type: 'further_optimization' | 'monitoring' | 'rollback' | 'enhancement';
  priority: 'low' | 'medium' | 'high';
  title: string;
  description: string;
  estimatedValue: CostAmount;
  effort: 'low' | 'medium' | 'high';
  timeline: string;
}

export interface OptimizationImplementation {
  method: 'manual' | 'automated' | 'hybrid';
  tools: string[];
  scripts: string[];
  documentation: string;
  rollbackProcedure: string;
  validationSteps: string[];
}

export interface OptimizationValidationCriteria {
  preExecution: string[];
  postExecution: string[];
  continuous: string[];
  rollbackTriggers: string[];
}