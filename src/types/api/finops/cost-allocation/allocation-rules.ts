/**
 * Allocation Rules and Logic Types
 * 
 * Types for allocation rules, methods, calculations, and distribution logic.
 * Covers rule definitions, allocation targets, calculation methods, and constraints.
 * 
 * Generated by CC (Claude Code) - Modularized from cost-allocation.ts
 */

import { CostAmount } from '../cost-analysis';
import type { AllocationFilter } from './configuration';

// Allocation Rule Types
export interface AllocationRule {
  id: string;
  name: string;
  description: string;
  priority: number;
  type: 'direct' | 'proportional' | 'fixed' | 'calculated';
  source: AllocationSource;
  targets: AllocationTarget[];
  allocation: AllocationLogic;
  conditions: AllocationCondition[];
  overrides: AllocationOverride[];
  validation: RuleValidation;
  enabled: boolean;
}

export interface AllocationSource {
  type: 'cost_pool' | 'service' | 'resource' | 'account' | 'tag';
  identifier: string;
  filters: AllocationFilter[];
  amount?: CostAmount;
}

export interface AllocationTarget {
  id: string;
  type: 'cost_center' | 'project' | 'department' | 'business_unit' | 'product';
  identifier: string;
  name: string;
  allocation: AllocationMethod;
  constraints: AllocationConstraint[];
}

export interface AllocationMethod {
  type: 'percentage' | 'fixed_amount' | 'usage_based' | 'resource_based' | 'activity_based';
  value: number;
  unit: string;
  basis: AllocationBasis;
  calculation: AllocationCalculation;
}

export interface AllocationBasis {
  metric: string;
  source: string;
  timeframe: string;
  aggregation: 'sum' | 'avg' | 'max' | 'weighted_avg';
  normalization: boolean;
}

export interface AllocationCalculation {
  formula: string;
  variables: AllocationVariable[];
  factors: AllocationFactor[];
  adjustments: AllocationAdjustment[];
}

export interface AllocationVariable {
  name: string;
  source: string;
  type: 'metric' | 'constant' | 'calculated';
  value?: number;
  refresh: string;
}

export interface AllocationFactor {
  name: string;
  type: 'multiplier' | 'divisor' | 'offset';
  value: number;
  condition?: string;
}

export interface AllocationAdjustment {
  type: 'seasonal' | 'promotional' | 'exceptional' | 'regulatory';
  value: number;
  period: string;
  justification: string;
  approval_required: boolean;
}

export interface AllocationConstraint {
  type: 'min_allocation' | 'max_allocation' | 'percentage_limit' | 'budget_limit';
  value: number;
  unit: string;
  enforcement: 'warning' | 'blocking' | 'override';
}

// Allocation Logic and Distribution
export interface AllocationLogic {
  method: string;
  parameters: Record<string, any>;
  distribution: DistributionLogic;
  rounding: RoundingLogic;
  residual: ResidualHandling;
}

export interface DistributionLogic {
  approach: 'proportional' | 'equal' | 'weighted' | 'tiered';
  weights: Record<string, number>;
  tiers: AllocationTier[];
  spillover: boolean;
}

export interface AllocationTier {
  threshold: number;
  rate: number;
  limit?: number;
}

export interface RoundingLogic {
  method: 'nearest' | 'up' | 'down' | 'banker';
  precision: number;
  currency_rules: boolean;
}

export interface ResidualHandling {
  method: 'proportional' | 'largest_first' | 'separate_bucket' | 'absorb';
  target?: string;
  threshold: number;
}

// Conditions and Overrides
export interface AllocationCondition {
  type: 'time_based' | 'value_based' | 'tag_based' | 'dependency_based';
  condition: string;
  value?: any;
  operator: string;
  action: 'apply' | 'skip' | 'modify' | 'escalate';
}

export interface AllocationOverride {
  id: string;
  type: 'emergency' | 'business_exception' | 'correction' | 'adjustment';
  scope: AllocationOverrideScope;
  modification: AllocationModification;
  justification: string;
  approver: string;
  approvedAt: string;
  effectiveDate: string;
  expirationDate?: string;
}

export interface AllocationOverrideScope {
  targets: string[];
  period: string;
  amount?: CostAmount;
  percentage?: number;
}

export interface AllocationModification {
  type: 'replace' | 'add' | 'multiply' | 'adjust';
  value: number;
  operation: string;
}

// Rule Validation
export interface RuleValidation {
  checks: ValidationCheck[];
  tolerance: number;
  reconciliation: ReconciliationRule[];
  audit: AuditRequirement[];
}

export interface ValidationCheck {
  type: 'total_equals_source' | 'percentage_equals_100' | 'min_max_constraints' | 'circular_reference';
  enabled: boolean;
  tolerance: number;
  action: 'warning' | 'error' | 'block';
}

export interface ReconciliationRule {
  source: string;
  target: string;
  tolerance: number;
  frequency: string;
  automated: boolean;
}

export interface AuditRequirement {
  trigger: string;
  scope: string;
  documentation: string[];
  approval: boolean;
}