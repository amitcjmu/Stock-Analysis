/**
 * Decommission Strategy Types
 * 
 * Type definitions specific to system decommissioning flows.
 * Covers decommission planning, data migration, system shutdown, and cleanup activities.
 * 
 * Generated by CC (Claude Code) - Modularized from decommission.ts
 */

import {
  BaseApiRequest,
  BaseApiResponse,
  MultiTenantContext,
  CreateRequest,
  CreateResponse,
  ValidationResult
} from '../../shared';

import {
  InitializeStrategyFlowRequest,
  InitializeStrategyFlowResponse,
  GetStrategyFlowStatusRequest,
  GetStrategyFlowStatusResponse,
  ListStrategyFlowsRequest,
  ListStrategyFlowsResponse,
  StrategyFlowData,
  StrategyFlowState,
  StrategyScope,
  StrategyFlowStatus,
  TimeRange,
  PriorityLevel,
  Stakeholder,
  Dependency,
  ApprovalRequirement,
  RiskAssessment,
  ExecutionPlan,
  CommunicationPlan,
  RollbackPlan
} from '../shared';

// Decommission-Specific Flow Management
export interface InitializeDecommissionFlowRequest extends InitializeStrategyFlowRequest {
  decommissionScope: DecommissionScope;
  decommissionStrategy: DecommissionStrategy;
  timeline: DecommissionTimeline;
  stakeholders: DecommissionStakeholder[];
  dependencies: DecommissionDependency[];
  configuration?: DecommissionFlowConfiguration;
}

export interface InitializeDecommissionFlowResponse extends InitializeStrategyFlowResponse {
  decommissionPlan: DecommissionPlan;
  riskAssessment: DecommissionRiskAssessment;
  approvalRequirements: ApprovalRequirement[];
}

export interface DecommissionFlowConfiguration {
  automated: boolean;
  dataRetentionRequired: boolean;
  complianceValidation: boolean;
  stakeholderApproval: boolean;
  rollbackCapability: boolean;
  archivalRequired: boolean;
  secureDisposal: boolean;
  auditTrail: boolean;
}

// Decommission Planning Types
export interface CreateDecommissionPlanRequest extends CreateRequest<DecommissionPlanData> {
  flowId: string;
  data: DecommissionPlanData;
  planningMethod: 'big_bang' | 'phased' | 'parallel_run' | 'gradual_cutover';
  riskMitigation: RiskMitigationStrategy[];
  dataHandling: DataHandlingStrategy;
  communicationPlan: CommunicationPlan;
  rollbackPlan: RollbackPlan;
  complianceRequirements: ComplianceRequirement[];
}

export interface CreateDecommissionPlanResponse extends CreateResponse<DecommissionPlan> {
  data: DecommissionPlan;
  planId: string;
  executionPlan: DecommissionExecutionPlan;
  dataMapping: DataMappingPlan;
  validationPlan: DecommissionValidationPlan;
  approvalWorkflow: DecommissionApprovalWorkflow;
}

// Core Decommission Types
export interface DecommissionScope extends StrategyScope {
  systemsToDecommission: SystemInventory[];
  dataAssets: DataAsset[];
  businessProcesses: BusinessProcess[];
  integrations: SystemIntegration[];
  dependencies: SystemDependency[];
  complianceScope: ComplianceScope[];
}

export interface SystemInventory {
  id: string;
  name: string;
  type: 'application' | 'database' | 'infrastructure' | 'service';
  criticality: 'low' | 'medium' | 'high' | 'critical';
  owner: string;
  location: string;
  environment: 'development' | 'testing' | 'staging' | 'production';
  status: 'active' | 'deprecated' | 'maintenance' | 'retired';
  dependencies: string[];
  dataStores: string[];
  integrations: string[];
  documentation: string[];
}

export interface DataAsset {
  id: string;
  name: string;
  type: 'database' | 'file' | 'stream' | 'api' | 'document';
  classification: 'public' | 'internal' | 'confidential' | 'restricted';
  size: number;
  format: string;
  location: string;
  owner: string;
  retention: DataRetentionPolicy;
  privacy: DataPrivacyRequirement;
  compliance: DataComplianceRequirement[];
  backups: BackupInfo[];
}

export interface DataRetentionPolicy {
  period: string;
  reason: string;
  disposal: DataDisposalMethod;
  archival: DataArchivalRequirement;
  legalHold: boolean;
}

export interface DataDisposalMethod {
  method: 'delete' | 'anonymize' | 'archive' | 'transfer';
  certification: boolean;
  verification: string[];
  timeline: string;
}

export interface DataArchivalRequirement {
  required: boolean;
  location: string;
  format: string;
  encryption: boolean;
  accessControl: string[];
  retrieval: string;
}

export interface DataPrivacyRequirement {
  pii: boolean;
  gdprApplicable: boolean;
  ccpaApplicable: boolean;
  anonymization: AnonymizationRequirement;
  consent: ConsentRequirement;
}

export interface AnonymizationRequirement {
  required: boolean;
  method: 'deletion' | 'masking' | 'generalization' | 'suppression';
  fields: string[];
  validation: string[];
}

export interface ConsentRequirement {
  required: boolean;
  withdrawalMethod: string;
  notificationRequired: boolean;
  gracePeriod: string;
}

export interface DataComplianceRequirement {
  regulation: string;
  requirement: string;
  action: string;
  verification: string;
  deadline: string;
}

export interface BackupInfo {
  location: string;
  frequency: string;
  retention: string;
  lastBackup: string;
  verified: boolean;
}

export interface BusinessProcess {
  id: string;
  name: string;
  description: string;
  owner: string;
  criticality: 'low' | 'medium' | 'high' | 'critical';
  affectedSystems: string[];
  alternatives: ProcessAlternative[];
  impact: ProcessImpact;
  mitigation: ProcessMitigation;
}

export interface ProcessAlternative {
  name: string;
  description: string;
  effort: 'low' | 'medium' | 'high';
  timeline: string;
  cost: number;
  risks: string[];
}

export interface ProcessImpact {
  users: number;
  transactions: number;
  revenue: number;
  compliance: string[];
  customer: string;
}

export interface ProcessMitigation {
  approach: string;
  timeline: string;
  resources: string[];
  validation: string[];
}

export interface SystemIntegration {
  id: string;
  name: string;
  type: 'api' | 'database' | 'file' | 'message_queue' | 'batch';
  direction: 'inbound' | 'outbound' | 'bidirectional';
  frequency: string;
  volume: number;
  criticality: 'low' | 'medium' | 'high' | 'critical';
  connectedSystems: string[];
  decommissionAction: IntegrationDecommissionAction;
}

export interface IntegrationDecommissionAction {
  action: 'disable' | 'redirect' | 'archive' | 'migrate';
  timeline: string;
  testing: string[];
  validation: string[];
  rollback: string[];
}

export interface SystemDependency {
  id: string;
  name: string;
  type: 'upstream' | 'downstream' | 'peer';
  relationship: 'data' | 'service' | 'infrastructure' | 'process';
  criticality: 'low' | 'medium' | 'high' | 'critical';
  impact: string;
  mitigation: string;
  alternativeSource?: string;
}

export interface ComplianceScope {
  regulation: string;
  applicableData: string[];
  requirements: string[];
  actions: ComplianceAction[];
  timeline: string;
  validation: string[];
}

export interface ComplianceAction {
  action: string;
  description: string;
  deadline: string;
  owner: string;
  validation: string[];
  evidence: string[];
}

// Decommission Strategy Types
export interface DecommissionStrategy {
  approach: DecommissionApproach;
  timeline: DecommissionTimeline;
  phases: DecommissionPhase[];
  dataStrategy: DataMigrationStrategy;
  cutoverStrategy: CutoverStrategy;
  riskMitigation: DecommissionRiskMitigation;
  rollbackStrategy: DecommissionRollbackStrategy;
}

export type DecommissionApproach = 
  | 'big_bang' | 'phased' | 'parallel_run' | 'gradual_cutover' | 'pilot_rollout';

export interface DecommissionTimeline {
  plannedStart: string;
  plannedEnd: string;
  phases: PhaseTimeline[];
  milestones: DecommissionMilestone[];
  dependencies: TimelineDependency[];
  bufferTime: string;
  freezePeriods: FreezePeriod[];
}

export interface PhaseTimeline {
  phaseId: string;
  name: string;
  startDate: string;
  endDate: string;
  duration: string;
  prerequisites: string[];
  deliverables: string[];
  approvals: string[];
}

export interface DecommissionMilestone {
  id: string;
  name: string;
  date: string;
  type: 'planning' | 'approval' | 'cutover' | 'validation' | 'completion';
  criteria: string[];
  deliverables: string[];
  approvals: string[];
  risks: string[];
}

export interface TimelineDependency {
  id: string;
  predecessor: string;
  successor: string;
  type: 'finish_to_start' | 'start_to_start' | 'finish_to_finish' | 'start_to_finish';
  lag: string;
  constraint: string;
}

export interface FreezePeriod {
  name: string;
  startDate: string;
  endDate: string;
  description: string;
  restrictions: string[];
  exceptions: string[];
}

export interface DecommissionPhase {
  id: string;
  name: string;
  description: string;
  type: 'preparation' | 'data_migration' | 'cutover' | 'validation' | 'cleanup';
  duration: string;
  activities: DecommissionActivity[];
  prerequisites: string[];
  deliverables: string[];
  risks: string[];
  rollbackTriggers: string[];
}

export interface DecommissionActivity {
  id: string;
  name: string;
  description: string;
  type: 'planning' | 'technical' | 'data' | 'testing' | 'approval' | 'communication';
  effort: string;
  resources: string[];
  dependencies: string[];
  deliverables: string[];
  validationCriteria: string[];
}

// Data Migration Strategy Types
export interface DataMigrationStrategy {
  approach: 'extract_archive' | 'migrate_transform' | 'selective_migration' | 'real_time_sync';
  dataHandling: DataHandlingApproach[];
  migrationTools: MigrationTool[];
  validation: DataValidationStrategy;
  rollback: DataRollbackStrategy;
  timeline: DataMigrationTimeline;
}

export interface DataHandlingApproach {
  dataType: string;
  approach: 'migrate' | 'archive' | 'delete' | 'anonymize' | 'transform';
  destination: string;
  transformation: DataTransformation[];
  validation: string[];
  timeline: string;
}

export interface DataTransformation {
  type: 'format' | 'structure' | 'content' | 'anonymization';
  description: string;
  rules: TransformationRule[];
  validation: string[];
  reversible: boolean;
}

export interface TransformationRule {
  field: string;
  action: string;
  parameters: Record<string, any>;
  condition?: string;
}

export interface MigrationTool {
  name: string;
  type: 'etl' | 'replication' | 'custom' | 'manual';
  capabilities: string[];
  limitations: string[];
  configuration: Record<string, any>;
  performance: ToolPerformance;
}

export interface ToolPerformance {
  throughput: string;
  concurrency: number;
  reliability: number;
  scalability: string;
}

export interface DataValidationStrategy {
  levels: ValidationLevel[];
  methods: ValidationMethod[];
  acceptance: AcceptanceCriteria[];
  reporting: ValidationReporting;
}

export interface ValidationLevel {
  level: 'record' | 'aggregate' | 'business_rule' | 'referential_integrity';
  coverage: number;
  sampling: SamplingStrategy;
  automation: boolean;
}

export interface SamplingStrategy {
  method: 'random' | 'systematic' | 'stratified' | 'complete';
  size: number;
  confidence: number;
}

export interface ValidationMethod {
  name: string;
  type: 'comparison' | 'checksum' | 'business_rule' | 'referential';
  automated: boolean;
  tools: string[];
  reporting: string;
}

export interface AcceptanceCriteria {
  metric: string;
  threshold: number;
  mandatory: boolean;
  measurement: string;
}

export interface ValidationReporting {
  frequency: string;
  recipients: string[];
  format: string;
  escalation: string[];
}

export interface DataRollbackStrategy {
  capability: 'full' | 'partial' | 'none';
  method: string[];
  timeline: string;
  triggers: string[];
  validation: string[];
  limitations: string[];
}

export interface DataMigrationTimeline {
  preparation: string;
  extraction: string;
  transformation: string;
  loading: string;
  validation: string;
  cutover: string;
  total: string;
}

// Cutover Strategy Types
export interface CutoverStrategy {
  type: 'immediate' | 'gradual' | 'pilot' | 'parallel_run';
  sequence: CutoverSequence[];
  validation: CutoverValidation;
  rollback: CutoverRollback;
  monitoring: CutoverMonitoring;
  communication: CutoverCommunication;
}

export interface CutoverSequence {
  step: number;
  name: string;
  description: string;
  duration: string;
  systems: string[];
  validation: string[];
  rollbackPoint: boolean;
  noGoConditions: string[];
}

export interface CutoverValidation {
  preCutover: ValidationCheck[];
  duringCutover: ValidationCheck[];
  postCutover: ValidationCheck[];
  successCriteria: string[];
  failureCriteria: string[];
}

export interface ValidationCheck {
  name: string;
  type: 'automated' | 'manual';
  description: string;
  timeout: string;
  retries: number;
  escalation: string;
}

export interface CutoverRollback {
  triggers: RollbackTrigger[];
  procedures: RollbackProcedure[];
  timeline: string;
  communication: string[];
  validation: string[];
}

export interface RollbackTrigger {
  condition: string;
  threshold: unknown;
  automatic: boolean;
  approver?: string;
  timeframe: string;
}

export interface RollbackProcedure {
  step: number;
  description: string;
  type: 'automatic' | 'manual';
  duration: string;
  validation: string[];
  dependencies: string[];
}

export interface CutoverMonitoring {
  metrics: MonitoringMetric[];
  dashboards: string[];
  alerts: AlertConfiguration[];
  reporting: MonitoringReporting;
}

export interface MonitoringMetric {
  name: string;
  type: 'performance' | 'availability' | 'data_integrity' | 'user_activity';
  threshold: MetricThreshold;
  frequency: string;
  escalation: string;
}

export interface MetricThreshold {
  warning: number;
  critical: number;
  operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';
}

export interface AlertConfiguration {
  name: string;
  condition: string;
  severity: 'info' | 'warning' | 'error' | 'critical';
  recipients: string[];
  escalation: AlertEscalation[];
}

export interface AlertEscalation {
  level: number;
  delay: string;
  recipients: string[];
  actions: string[];
}

export interface MonitoringReporting {
  frequency: string;
  recipients: string[];
  format: string;
  content: string[];
  escalation: string[];
}

export interface CutoverCommunication {
  plan: CommunicationPlan;
  notifications: NotificationPlan[];
  updates: UpdateSchedule[];
  escalation: CommunicationEscalation[];
}

export interface NotificationPlan {
  event: string;
  timing: string;
  recipients: string[];
  channels: string[];
  template: string;
}

export interface UpdateSchedule {
  frequency: string;
  recipients: string[];
  content: string[];
  channels: string[];
}

export interface CommunicationEscalation {
  trigger: string;
  recipients: string[];
  channels: string[];
  template: string;
  timing: string;
}

// Extended types for decommission-specific features
export interface DecommissionStakeholder extends Stakeholder {
  decommissionRole: 'business_owner' | 'technical_lead' | 'data_owner' | 'compliance_officer' | 'end_user';
  impactLevel: 'none' | 'low' | 'medium' | 'high' | 'critical';
  signoffRequired: boolean;
  trainingNeeded: boolean;
  alternativeProcess: string;
}

export interface DecommissionDependency extends Dependency {
  decommissionImpact: 'blocking' | 'high' | 'medium' | 'low' | 'none';
  alternativeAvailable: boolean;
  alternativeDescription?: string;
  mitigationPlan: string;
  validationRequired: boolean;
}

export interface DecommissionPlanData {
  name: string;
  description: string;
  approach: DecommissionApproach;
  scope: DecommissionScope;
  strategy: DecommissionStrategy;
  timeline: DecommissionTimeline;
  resources: DecommissionResources;
  risks: DecommissionRisk[];
  compliance: ComplianceRequirement[];
  stakeholders: DecommissionStakeholder[];
  dependencies: DecommissionDependency[];
  approval: DecommissionApprovalRequirement[];
}

export interface DecommissionPlan extends DecommissionPlanData {
  id: string;
  planId: string;
  status: 'draft' | 'review' | 'approved' | 'executing' | 'completed' | 'cancelled';
  version: string;
  createdBy: string;
  createdAt: string;
  updatedAt: string;
  approvedAt?: string;
  approvedBy?: string;
}

export interface DecommissionResources {
  team: TeamResource[];
  infrastructure: InfrastructureResource[];
  tools: ToolResource[];
  budget: BudgetResource;
}

export interface TeamResource {
  role: string;
  name: string;
  allocation: number;
  duration: string;
  skills: string[];
  availability: string;
}

export interface InfrastructureResource {
  type: string;
  description: string;
  quantity: number;
  duration: string;
  cost: number;
  availability: string;
}

export interface ToolResource {
  name: string;
  type: string;
  purpose: string;
  license: string;
  cost: number;
  training: boolean;
}

export interface BudgetResource {
  total: number;
  allocated: number;
  currency: string;
  breakdown: BudgetBreakdown[];
  contingency: number;
}

export interface BudgetBreakdown {
  category: string;
  amount: number;
  description: string;
  approval: string;
}

export interface DecommissionRisk {
  id: string;
  name: string;
  description: string;
  category: 'technical' | 'business' | 'data' | 'compliance' | 'operational';
  likelihood: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  impact: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  mitigation: DecommissionRiskMitigation;
  contingency: string;
  owner: string;
  status: 'open' | 'mitigating' | 'mitigated' | 'accepted' | 'closed';
}

export interface DecommissionRiskMitigation {
  strategy: string;
  actions: MitigationAction[];
  timeline: string;
  cost: number;
  effectiveness: number;
  monitoring: string[];
}

export interface MitigationAction {
  action: string;
  owner: string;
  dueDate: string;
  status: 'planned' | 'in_progress' | 'completed' | 'blocked';
  dependencies: string[];
}

export interface ComplianceRequirement {
  regulation: string;
  requirement: string;
  applicability: string[];
  actions: string[];
  validation: string[];
  evidence: string[];
  deadline: string;
  owner: string;
}

export interface DecommissionApprovalRequirement {
  type: 'plan' | 'execution' | 'data_disposal' | 'compliance' | 'business' | 'final';
  approver: string;
  criteria: string[];
  dependencies: string[];
  timeline: string;
  status: 'pending' | 'approved' | 'rejected' | 'conditional';
}

// Execution and Monitoring Types
export interface DecommissionExecutionPlan extends ExecutionPlan {
  cutoverPlan: CutoverExecutionPlan;
  dataMigrationPlan: DataMigrationExecutionPlan;
  validationPlan: DecommissionValidationPlan;
  rollbackPlan: DecommissionRollbackPlan;
}

export interface CutoverExecutionPlan {
  sequence: CutoverStep[];
  validation: CutoverValidationPlan;
  rollback: CutoverRollbackPlan;
  monitoring: CutoverMonitoringPlan;
  communication: CutoverCommunicationPlan;
}

export interface CutoverStep {
  id: string;
  name: string;
  description: string;
  type: 'preparation' | 'execution' | 'validation' | 'rollback';
  duration: string;
  resources: string[];
  prerequisites: string[];
  successCriteria: string[];
  rollbackTriggers: string[];
  validation: string[];
}

export interface DataMigrationExecutionPlan {
  phases: DataMigrationPhase[];
  validation: DataValidationPlan;
  monitoring: DataMigrationMonitoring;
  rollback: DataMigrationRollback;
}

export interface DataMigrationPhase {
  id: string;
  name: string;
  type: 'extraction' | 'transformation' | 'loading' | 'validation';
  datasets: string[];
  duration: string;
  resources: string[];
  validation: string[];
  rollbackPoint: boolean;
}

export interface DecommissionValidationPlan {
  phases: DecommissionValidationPhase[];
  acceptance: ValidationAcceptance;
  reporting: ValidationReporting;
  escalation: ValidationEscalation[];
}

export interface DecommissionValidationPhase {
  phase: string;
  validations: DecommissionValidation[];
  criteria: ValidationCriteria[];
  timeline: string;
  resources: string[];
}

export interface DecommissionValidation {
  id: string;
  name: string;
  type: 'functional' | 'data' | 'integration' | 'performance' | 'security';
  method: 'automated' | 'manual' | 'hybrid';
  scope: string[];
  criteria: string[];
  tools: string[];
  timeline: string;
}

export interface ValidationCriteria {
  criterion: string;
  measurement: string;
  threshold: number;
  mandatory: boolean;
  validation: string;
}

export interface ValidationAcceptance {
  criteria: AcceptanceCriteria[];
  signoff: SignoffRequirement[];
  conditions: string[];
  exceptions: string[];
}

export interface SignoffRequirement {
  role: string;
  name: string;
  criteria: string[];
  dependencies: string[];
}

export interface ValidationEscalation {
  condition: string;
  recipients: string[];
  timeline: string;
  actions: string[];
}

export interface DecommissionRollbackPlan extends RollbackPlan {
  scope: RollbackScope;
  triggers: DecommissionRollbackTrigger[];
  procedures: DecommissionRollbackProcedure[];
  validation: RollbackValidation;
  communication: RollbackCommunication;
  timeline: RollbackTimeline;
}

export interface RollbackScope {
  systems: string[];
  data: string[];
  integrations: string[];
  processes: string[];
  limitations: string[];
}

export interface DecommissionRollbackTrigger {
  type: 'automatic' | 'manual';
  condition: string;
  threshold: unknown;
  approver?: string;
  timeline: string;
  actions: string[];
}

export interface DecommissionRollbackProcedure {
  step: number;
  name: string;
  description: string;
  type: 'system' | 'data' | 'process' | 'communication';
  duration: string;
  resources: string[];
  validation: string[];
  dependencies: string[];
}

export interface RollbackValidation {
  preRollback: string[];
  postRollback: string[];
  acceptance: string[];
  signoff: string[];
}

export interface RollbackCommunication {
  stakeholders: string[];
  timeline: string;
  channels: string[];
  templates: string[];
  escalation: string[];
}

export interface RollbackTimeline {
  preparation: string;
  execution: string;
  validation: string;
  communication: string;
  total: string;
}

// Status and Progress Types specific to Decommission
export interface DecommissionStatusDetail {
  flowId: string;
  status: StrategyFlowStatus;
  progress: DecommissionProgress;
  currentPhase: string;
  phaseDetails: DecommissionPhaseDetail[];
  dataMigration: DataMigrationStatus;
  systemStatus: SystemDecommissionStatus[];
  risks: DecommissionRisk[];
  approvals: DecommissionApprovalStatus[];
  blockers: DecommissionBlocker[];
  nextActions: DecommissionNextAction[];
  lastUpdated: string;
}

export interface DecommissionProgress {
  overall: number;
  planning: number;
  dataMigration: number;
  systemDecommission: number;
  validation: number;
  cleanup: number;
  milestones: DecommissionMilestoneStatus[];
}

export interface DecommissionMilestoneStatus {
  milestoneId: string;
  name: string;
  status: 'upcoming' | 'in_progress' | 'completed' | 'at_risk' | 'missed';
  dueDate: string;
  completion: number;
  blockers: string[];
}

export interface DecommissionPhaseDetail {
  phaseId: string;
  name: string;
  status: 'not_started' | 'in_progress' | 'completed' | 'blocked' | 'at_risk';
  progress: number;
  activities: DecommissionActivityStatus[];
  deliverables: DecommissionDeliverableStatus[];
  issues: DecommissionIssue[];
}

export interface DecommissionActivityStatus {
  activityId: string;
  name: string;
  status: string;
  progress: number;
  assignee: string;
  dueDate: string;
  dependencies: string[];
  blockers: string[];
}

export interface DecommissionDeliverableStatus {
  name: string;
  status: 'not_started' | 'in_progress' | 'under_review' | 'approved' | 'rejected';
  dueDate: string;
  owner: string;
  approver?: string;
  quality: number;
}

export interface DecommissionIssue {
  id: string;
  type: 'blocker' | 'risk' | 'concern' | 'question';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  impact: string;
  owner: string;
  status: 'open' | 'investigating' | 'resolved' | 'escalated';
  createdAt: string;
  resolution?: string;
}

export interface DataMigrationStatus {
  overall: number;
  extraction: number;
  transformation: number;
  loading: number;
  validation: number;
  datasets: DatasetMigrationStatus[];
  issues: DataMigrationIssue[];
  metrics: DataMigrationMetrics;
}

export interface DatasetMigrationStatus {
  dataset: string;
  status: 'not_started' | 'extracting' | 'transforming' | 'loading' | 'validating' | 'completed' | 'failed';
  progress: number;
  recordsProcessed: number;
  recordsTotal: number;
  errors: number;
  lastUpdate: string;
}

export interface DataMigrationIssue {
  id: string;
  dataset: string;
  type: 'data_quality' | 'transformation_error' | 'validation_failure' | 'performance';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  count: number;
  resolution: string;
  status: 'open' | 'investigating' | 'resolved';
}

export interface DataMigrationMetrics {
  throughput: number;
  errorRate: number;
  dataQualityScore: number;
  validationScore: number;
  performanceMetrics: Record<string, number>;
}

export interface SystemDecommissionStatus {
  systemId: string;
  name: string;
  status: 'active' | 'draining' | 'offline' | 'decommissioned' | 'disposed';
  progress: number;
  activities: SystemDecommissionActivity[];
  dependencies: SystemDecommissionDependency[];
  lastUpdate: string;
}

export interface SystemDecommissionActivity {
  activity: string;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  startedAt?: string;
  completedAt?: string;
  errors: string[];
}

export interface SystemDecommissionDependency {
  system: string;
  status: 'resolved' | 'pending' | 'blocked';
  description: string;
  resolution?: string;
}

export interface DecommissionApprovalStatus {
  approvalId: string;
  type: string;
  status: 'pending' | 'approved' | 'rejected' | 'conditional' | 'expired';
  approver: string;
  requestedAt: string;
  respondedAt?: string;
  conditions?: string[];
  comments?: string;
}

export interface DecommissionBlocker {
  id: string;
  type: 'dependency' | 'approval' | 'technical' | 'data' | 'compliance';
  description: string;
  impact: 'low' | 'medium' | 'high' | 'critical';
  owner: string;
  estimatedResolution: string;
  alternatives: string[];
  escalation: string[];
}

export interface DecommissionNextAction {
  id: string;
  type: 'task' | 'approval' | 'decision' | 'escalation';
  description: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  dueDate: string;
  assignee: string;
  dependencies: string[];
  blockers: string[];
}

// Aggregation and Analytics Types specific to Decommission
export interface DecommissionAggregation {
  dimension: 'status' | 'approach' | 'system_type' | 'complexity' | 'risk_level';
  values: DecommissionAggregationValue[];
  total: number;
}

export interface DecommissionAggregationValue {
  key: string;
  count: number;
  percentage: number;
  avgDuration?: number;
  avgCost?: number;
  successRate?: number;
}

export interface DecommissionTrend {
  metric: 'volume' | 'duration' | 'cost' | 'success_rate' | 'complexity';
  period: 'daily' | 'weekly' | 'monthly' | 'quarterly';
  dataPoints: DecommissionTrendPoint[];
  forecast?: DecommissionTrendPoint[];
}

export interface DecommissionTrendPoint {
  period: string;
  value: number;
  change?: number;
  changePercentage?: number;
  events?: string[];
}

export interface DecommissionPortfolioMetrics {
  totalSystems: number;
  activeDecommissions: number;
  completedDecommissions: number;
  avgDecommissionTime: string;
  costSavings: number;
  riskReduction: number;
  complianceImprovement: number;
  dataDisposed: number;
  systemsRetired: number;
}

// Risk Assessment specific to Decommission
export interface DecommissionRiskAssessment extends RiskAssessment {
  dataRisks: DataRisk[];
  systemRisks: SystemRisk[];
  businessRisks: BusinessRisk[];
  complianceRisks: ComplianceRisk[];
  operationalRisks: OperationalRisk[];
}

export interface DataRisk {
  type: 'data_loss' | 'privacy_breach' | 'retention_violation' | 'corruption';
  description: string;
  likelihood: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  impact: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  affectedData: string[];
  mitigation: string;
  contingency: string;
}

export interface SystemRisk {
  type: 'dependency_failure' | 'integration_break' | 'performance_degradation' | 'rollback_failure';
  description: string;
  likelihood: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  impact: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  affectedSystems: string[];
  mitigation: string;
  contingency: string;
}

export interface BusinessRisk {
  type: 'process_disruption' | 'revenue_loss' | 'customer_impact' | 'reputation_damage';
  description: string;
  likelihood: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  impact: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  affectedProcesses: string[];
  mitigation: string;
  contingency: string;
}

export interface ComplianceRisk {
  type: 'regulatory_violation' | 'audit_failure' | 'data_breach' | 'retention_violation';
  description: string;
  likelihood: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  impact: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  regulations: string[];
  mitigation: string;
  contingency: string;
}

export interface OperationalRisk {
  type: 'resource_shortage' | 'skill_gap' | 'timeline_overrun' | 'budget_overrun';
  description: string;
  likelihood: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  impact: 'very_low' | 'low' | 'medium' | 'high' | 'very_high';
  mitigation: string;
  contingency: string;
}

export interface RiskMitigationStrategy {
  riskId: string;
  strategy: string;
  actions: string[];
  timeline: string;
  cost: number;
  effectiveness: number;
  owner: string;
  monitoring: string[];
  reporting: string;
}

// Data Mapping and Migration Planning
export interface DataMappingPlan {
  mappings: DataMapping[];
  transformations: DataTransformation[];
  validations: DataValidation[];
  dependencies: DataDependency[];
  timeline: DataMappingTimeline;
}

export interface DataMapping {
  sourceSystem: string;
  sourceData: string;
  targetSystem: string;
  targetData: string;
  mappingType: 'direct' | 'transformation' | 'aggregation' | 'split';
  transformation?: string;
  validation: string[];
}

export interface DataValidation {
  type: 'completeness' | 'accuracy' | 'consistency' | 'integrity' | 'timeliness';
  description: string;
  scope: string[];
  method: string;
  acceptance: number;
  reporting: string;
}

export interface DataDependency {
  sourceData: string;
  dependentData: string;
  relationship: 'foreign_key' | 'lookup' | 'derivation' | 'aggregation';
  criticality: 'low' | 'medium' | 'high' | 'critical';
  impact: string;
  resolution: string;
}

export interface DataMappingTimeline {
  analysis: string;
  mapping: string;
  validation: string;
  approval: string;
  total: string;
}

// Workflow and Approval Types specific to Decommission
export interface DecommissionApprovalWorkflow {
  steps: DecommissionApprovalStep[];
  routing: ApprovalRouting[];
  escalation: ApprovalEscalation[];
  notifications: ApprovalNotification[];
}

export interface DecommissionApprovalStep {
  id: string;
  name: string;
  type: 'plan' | 'data_disposal' | 'system_shutdown' | 'compliance' | 'final';
  approvers: string[];
  criteria: string[];
  parallel: boolean;
  timeout: string;
  escalation: string[];
}

export interface ApprovalRouting {
  condition: string;
  destination: string;
  action: 'route' | 'skip' | 'escalate';
}

export interface ApprovalEscalation {
  stepId: string;
  condition: string;
  escalateTo: string[];
  timeout: string;
  actions: string[];
}

export interface ApprovalNotification {
  event: 'requested' | 'approved' | 'rejected' | 'escalated' | 'expired';
  recipients: string[];
  channels: string[];
  template: string;
  timing: string;
}