/**
 * Plan Approval Workflow Types
 * 
 * Type definitions for plan approval processes, workflow management,
 * authorization, delegation, and escalation handling. Covers approval
 * stages, routing, conditions, and comprehensive workflow orchestration.
 * 
 * Generated by CC - Claude Code
 */

import type {
  BaseApiRequest,
  BaseApiResponse,
  MultiTenantContext
} from '../../shared';

// Plan Approval API Types
export interface ApprovePlanRequest extends BaseApiRequest {
  planId: string;
  planType: string;
  approvalLevel: 'technical' | 'business' | 'executive' | 'governance';
  approverComments?: string;
  conditions?: ApprovalCondition[];
  context: MultiTenantContext;
}

export interface ApprovePlanResponse extends BaseApiResponse<PlanApprovalResult> {
  data: PlanApprovalResult;
  approvalId: string;
  status: 'approved' | 'approved_with_conditions' | 'rejected' | 'needs_revision';
  nextSteps: string[];
  conditions: ApprovalCondition[];
}

// Approval Core Types
export interface PlanApprovalResult {
  id: string;
  planId: string;
  planType: string;
  approvalLevel: string;
  approver: ApproverInfo;
  decision: ApprovalDecision;
  timestamp: string;
  workflow: ApprovalWorkflow;
  history: ApprovalHistory[];
  delegation: ApprovalDelegation;
}

export interface ApprovalCondition {
  id: string;
  type: 'prerequisite' | 'constraint' | 'requirement' | 'mitigation';
  description: string;
  owner: string;
  deadline: string;
  status: 'pending' | 'in_progress' | 'completed' | 'overdue';
  verification: ConditionVerification;
}

export interface ApproverInfo {
  id: string;
  name: string;
  role: string;
  authority: ApprovalAuthority;
  delegation: ApprovalDelegation;
  expertise: string[];
  history: ApprovalHistory[];
}

export interface ApprovalDecision {
  decision: 'approved' | 'approved_with_conditions' | 'rejected' | 'deferred' | 'escalated';
  rationale: string;
  comments: string;
  conditions: ApprovalCondition[];
  recommendations: string[];
  nextActions: string[];
  escalation?: EscalationInfo;
}

export interface ApprovalWorkflow {
  id: string;
  name: string;
  stages: ApprovalStage[];
  routing: WorkflowRouting;
  escalation: WorkflowEscalation;
  parallel: boolean;
  conditional: boolean;
  timeouts: WorkflowTimeout[];
}

export interface ApprovalHistory {
  timestamp: string;
  stage: string;
  approver: string;
  decision: string;
  comments: string;
  duration: number;
}

export interface ApprovalDelegation {
  delegated: boolean;
  delegatee: string;
  delegator: string;
  scope: DelegationScope;
  duration: DelegationDuration;
  conditions: string[];
}

// Authority and Permission Types
export interface ApprovalAuthority {
  level: string;
  scope: string[];
  limits: AuthorityLimit[];
  delegation: boolean;
  escalation: string;
}

export interface AuthorityLimit {
  type: 'budget' | 'timeline' | 'scope' | 'risk';
  value: number;
  currency?: string;
  conditions: string[];
}

export interface ConditionVerification {
  method: 'automated' | 'manual' | 'hybrid';
  criteria: string[];
  evidence: string[];
  validator: string;
  timestamp: string;
}

export interface EscalationInfo {
  reason: string;
  level: string;
  recipient: string;
  timeline: string;
  conditions: string[];
}

// Workflow Stage Types
export interface ApprovalStage {
  id: string;
  name: string;
  sequence: number;
  type: 'sequential' | 'parallel' | 'conditional';
  approvers: StageApprover[];
  criteria: StageCriteria[];
  timeout: StageTimeout;
  escalation: StageEscalation;
}

export interface WorkflowRouting {
  rules: RoutingRule[];
  conditions: RoutingCondition[];
  branches: RoutingBranch[];
  merges: RoutingMerge[];
}

export interface WorkflowEscalation {
  triggers: EscalationTrigger[];
  levels: EscalationLevel[];
  paths: EscalationPath[];
  actions: EscalationAction[];
}

export interface WorkflowTimeout {
  stage: string;
  duration: number;
  action: 'escalate' | 'approve' | 'reject' | 'notify';
  recipient: string;
}

// Delegation Management Types
export interface DelegationScope {
  plans: string[];
  amounts: AmountLimit[];
  duration: DurationLimit;
  conditions: string[];
}

export interface DelegationDuration {
  start: string;
  end: string;
  renewable: boolean;
  conditions: string[];
}

export interface AmountLimit {
  currency: string;
  limit: number;
  period: string;
}

export interface DurationLimit {
  minimum: number;
  maximum: number;
  unit: 'hours' | 'days' | 'weeks' | 'months';
}

// Stage and Routing Supporting Types
export interface StageApprover {
  approver: string;
  role: string;
  required: boolean;
  weight: number;
  delegation: boolean;
}

export interface StageCriteria {
  criteria: string;
  required: boolean;
  weight: number;
  measurement: string;
}

export interface StageTimeout {
  duration: number;
  unit: 'hours' | 'days' | 'weeks';
  action: 'escalate' | 'auto_approve' | 'auto_reject';
}

export interface StageEscalation {
  triggers: string[];
  recipient: string;
  timeline: string;
  action: string;
}

export interface RoutingRule {
  condition: string;
  action: 'route' | 'skip' | 'parallel' | 'wait';
  target: string;
  priority: number;
}

export interface RoutingCondition {
  field: string;
  operator: string;
  value: unknown;
  logic: 'and' | 'or' | 'not';
}

export interface RoutingBranch {
  condition: string;
  path: string[];
  merge: string;
  parallel: boolean;
}

export interface RoutingMerge {
  branches: string[];
  logic: 'all' | 'any' | 'majority';
  target: string;
}

// Escalation Management Types
export interface EscalationTrigger {
  event: string;
  condition: string;
  threshold: number;
  timeframe: string;
}

export interface EscalationLevel {
  level: number;
  authority: string;
  timeline: string;
  auto_escalate: boolean;
}

export interface EscalationPath {
  from: string;
  to: string;
  condition: string;
  timeline: string;
}

export interface EscalationAction {
  action: string;
  recipient: string;
  timeline: string;
  automated: boolean;
}