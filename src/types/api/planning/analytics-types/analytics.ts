/**
 * Plan Analytics Core Types
 *
 * Type definitions for planning analytics, metrics, dimensions, segments,
 * correlations, patterns, and anomaly detection. Covers comprehensive
 * analytics data structures and measurement frameworks.
 *
 * Generated by CC - Claude Code
 */

import type {
  BaseApiRequest,
  BaseApiResponse,
  MultiTenantContext
} from '../../shared';

// Plan Analytics API Types
export interface GetPlanningAnalyticsRequest extends BaseApiRequest {
  flowId?: string;
  planIds?: string[];
  planTypes?: string[];
  timeRange?: {
    start: string;
    end: string;
  };
  metrics?: string[];
  dimensions?: string[];
  aggregation?: 'sum' | 'avg' | 'min' | 'max' | 'count';
  context: MultiTenantContext;
}

export interface GetPlanningAnalyticsResponse extends BaseApiResponse<PlanningAnalytics> {
  data: PlanningAnalytics;
  insights: PlanningInsight[];
  trends: PlanningTrend[];
  benchmarks: PlanningBenchmark[];
  predictions: PlanningPrediction[];
}

// Analytics Core Types
export interface PlanningAnalytics {
  id: string;
  scope: AnalyticsScope;
  timeframe: AnalyticsTimeframe;
  metrics: AnalyticsMetric[];
  dimensions: AnalyticsDimension[];
  segments: AnalyticsSegment[];
  correlations: AnalyticsCorrelation[];
  patterns: AnalyticsPattern[];
  anomalies: AnalyticsAnomaly[];
  forecasts: AnalyticsForecast[];
}

export interface PlanningInsight {
  id: string;
  type: 'trend' | 'pattern' | 'anomaly' | 'correlation' | 'prediction';
  category: string;
  title: string;
  description: string;
  significance: 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  evidence: InsightEvidence[];
  implications: string[];
  recommendations: string[];
  actionable: boolean;
}

export interface PlanningTrend {
  id: string;
  metric: string;
  dimension: string;
  direction: 'increasing' | 'decreasing' | 'stable' | 'volatile';
  magnitude: number;
  duration: number;
  confidence: number;
  drivers: TrendDriver[];
  forecast: TrendForecast;
  implications: string[];
}

export interface PlanningBenchmark {
  id: string;
  metric: string;
  dimension: string;
  internal: BenchmarkValue;
  external: BenchmarkValue;
  industry: BenchmarkValue;
  bestPractice: BenchmarkValue;
  variance: BenchmarkVariance;
  insights: BenchmarkInsight[];
}

export interface PlanningPrediction {
  id: string;
  target: string;
  horizon: string;
  method: 'statistical' | 'machine_learning' | 'expert' | 'hybrid';
  value: PredictionValue;
  confidence: PredictionConfidence;
  scenarios: PredictionScenario[];
  assumptions: string[];
  limitations: string[];
}

// Analytics Scope and Time Management
export interface AnalyticsScope {
  plans: string[];
  timeframe: AnalyticsTimeframe;
  dimensions: string[];
  filters: AnalyticsFilter[];
  segments: string[];
}

export interface AnalyticsTimeframe {
  start: string;
  end: string;
  granularity: 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';
  comparison: TimeframeComparison;
}

export interface AnalyticsFilter {
  field: string;
  operator: string;
  value: unknown;
  description: string;
}

export interface TimeframeComparison {
  enabled: boolean;
  periods: ComparisonPeriod[];
  baseline: string;
  variance_analysis: boolean;
}

export interface ComparisonPeriod {
  name: string;
  start: string;
  end: string;
  type: 'previous' | 'same_period_last_year' | 'baseline' | 'target';
}

// Metrics and Dimensions
export interface AnalyticsMetric {
  id: string;
  name: string;
  description: string;
  category: string;
  type: 'count' | 'sum' | 'average' | 'percentage' | 'ratio';
  unit: string;
  calculation: MetricCalculation;
  targets: MetricTarget[];
  thresholds: MetricThreshold[];
}

export interface AnalyticsDimension {
  id: string;
  name: string;
  description: string;
  type: 'categorical' | 'numerical' | 'temporal' | 'geographical';
  values: DimensionValue[];
  hierarchy: DimensionHierarchy;
  relationships: DimensionRelationship[];
}

export interface AnalyticsSegment {
  id: string;
  name: string;
  description: string;
  criteria: SegmentCriteria[];
  size: number;
  characteristics: SegmentCharacteristic[];
  behavior: SegmentBehavior;
}

// Correlation and Pattern Analysis
export interface AnalyticsCorrelation {
  id: string;
  variables: CorrelationVariable[];
  coefficient: number;
  significance: number;
  strength: 'weak' | 'moderate' | 'strong' | 'very_strong';
  direction: 'positive' | 'negative';
  interpretation: string;
}

export interface AnalyticsPattern {
  id: string;
  type: 'seasonal' | 'cyclical' | 'trend' | 'irregular' | 'recurring';
  description: string;
  frequency: string;
  amplitude: number;
  confidence: number;
  occurrences: PatternOccurrence[];
}

export interface AnalyticsAnomaly {
  id: string;
  type: 'outlier' | 'spike' | 'drop' | 'drift' | 'break';
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  detection: AnomalyDetection;
  investigation: AnomalyInvestigation;
  impact: AnomalyImpact;
}

export interface AnalyticsForecast {
  id: string;
  target: string;
  method: 'time_series' | 'regression' | 'machine_learning' | 'expert';
  horizon: number;
  values: ForecastValue[];
  accuracy: ForecastAccuracy;
  assumptions: string[];
  limitations: string[];
}

// Supporting Detail Types
export interface MetricCalculation {
  formula: string;
  variables: CalculationVariable[];
  aggregation: string;
  filters: CalculationFilter[];
}

export interface MetricTarget {
  type: 'absolute' | 'relative' | 'improvement';
  value: number;
  period: string;
  rationale: string;
}

export interface MetricThreshold {
  level: 'green' | 'amber' | 'red';
  value: number;
  operator: string;
  action: string;
}

export interface DimensionValue {
  value: string;
  label: string;
  description: string;
  metadata: ValueMetadata;
}

export interface DimensionHierarchy {
  levels: HierarchyLevel[];
  relationships: HierarchyRelationship[];
  rollup_rules: RollupRule[];
}

export interface DimensionRelationship {
  type: 'parent_child' | 'many_to_many' | 'lookup';
  related_dimension: string;
  cardinality: string;
  strength: number;
}

export interface SegmentCriteria {
  dimension: string;
  operator: string;
  value: unknown;
  logic: 'and' | 'or' | 'not';
}

export interface SegmentCharacteristic {
  characteristic: string;
  value: unknown;
  prevalence: number;
  significance: number;
}

export interface SegmentBehavior {
  patterns: BehaviorPattern[];
  trends: BehaviorTrend[];
  preferences: BehaviorPreference[];
  interactions: BehaviorInteraction[];
}

export interface CorrelationVariable {
  variable: string;
  type: 'independent' | 'dependent' | 'control';
  lag: number;
  transformation: string;
}

export interface PatternOccurrence {
  start: string;
  end: string;
  strength: number;
  confidence: number;
  context: string[];
}

export interface AnomalyDetection {
  method: string;
  sensitivity: number;
  parameters: DetectionParameter[];
  validation: DetectionValidation;
}

export interface AnomalyInvestigation {
  status: 'pending' | 'investigating' | 'resolved' | 'false_positive';
  findings: InvestigationFinding[];
  root_cause: string;
  actions: InvestigationAction[];
}

export interface AnomalyImpact {
  scope: string[];
  magnitude: number;
  duration: number;
  consequences: string[];
}

export interface ForecastValue {
  period: string;
  value: number;
  confidence: number;
  range: ForecastRange;
}

export interface ForecastAccuracy {
  method: string;
  historical: HistoricalAccuracy;
  metrics: AccuracyMetric[];
  validation: AccuracyValidation;
}

// Utility Supporting Types
export interface CalculationVariable {
  variable: string;
  source: string;
  transformation: string;
  aggregation: string;
}

export interface CalculationFilter {
  field: string;
  operator: string;
  value: unknown;
}

export interface ValueMetadata {
  created: string;
  updated: string;
  source: string;
  quality: number;
}

export interface HierarchyLevel {
  level: number;
  name: string;
  cardinality: number;
}

export interface HierarchyRelationship {
  parent: string;
  child: string;
  type: string;
}

export interface RollupRule {
  from_level: number;
  to_level: number;
  aggregation: string;
  filters: string[];
}

export interface BehaviorPattern {
  pattern: string;
  frequency: number;
  context: string[];
  significance: number;
}

export interface BehaviorTrend {
  trend: string;
  direction: string;
  magnitude: number;
  duration: number;
}

export interface BehaviorPreference {
  preference: string;
  strength: number;
  context: string[];
}

export interface BehaviorInteraction {
  interaction: string;
  frequency: number;
  outcome: string;
  satisfaction: number;
}

export interface DetectionParameter {
  parameter: string;
  value: unknown;
  description: string;
}

export interface DetectionValidation {
  method: string;
  accuracy: number;
  false_positive_rate: number;
}

export interface InvestigationFinding {
  finding: string;
  evidence: string[];
  confidence: number;
  impact: string;
}

export interface InvestigationAction {
  action: string;
  owner: string;
  timeline: string;
  status: string;
}

export interface ForecastRange {
  lower: number;
  upper: number;
  probability: number;
}

export interface HistoricalAccuracy {
  periods: number;
  mean_error: number;
  absolute_error: number;
  percentage_error: number;
}

export interface AccuracyMetric {
  metric: string;
  value: number;
  interpretation: string;
}

export interface AccuracyValidation {
  method: string;
  results: AccuracyResult[];
  confidence: number;
}

export interface AccuracyResult {
  test: string;
  result: boolean;
  details: string;
}

// Insight and Benchmark Supporting Types
export interface InsightEvidence {
  type: 'data' | 'analysis' | 'observation' | 'expert_opinion';
  source: string;
  strength: 'weak' | 'moderate' | 'strong';
  description: string;
  reference: string;
}

export interface TrendDriver {
  driver: string;
  influence: number;
  confidence: number;
  mechanism: string;
  controllable: boolean;
}

export interface TrendForecast {
  direction: 'continuing' | 'reversing' | 'accelerating' | 'decelerating';
  confidence: number;
  timeline: string;
  factors: string[];
}

export interface BenchmarkValue {
  value: number;
  source: string;
  date: string;
  confidence: number;
  context: string[];
}

export interface BenchmarkVariance {
  absolute: number;
  relative: number;
  percentile: number;
  significance: 'not_significant' | 'significant' | 'highly_significant';
}

export interface BenchmarkInsight {
  insight: string;
  implication: string;
  action: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
}

export interface PredictionValue {
  point: number;
  range: PredictionRange;
  distribution: PredictionDistribution;
  scenarios: PredictionScenario[];
}

export interface PredictionConfidence {
  level: number;
  interval: ConfidenceInterval;
  factors: ConfidenceFactor[];
  validation: ConfidenceValidation;
}

export interface PredictionScenario {
  scenario: string;
  probability: number;
  value: number;
  conditions: string[];
  implications: string[];
}

export interface PredictionRange {
  lower: number;
  upper: number;
  median: number;
  mode: number;
}

export interface PredictionDistribution {
  type: string;
  parameters: DistributionParameter[];
  percentiles: Percentile[];
  statistics: DistributionStatistics;
}

export interface ConfidenceInterval {
  lower: number;
  upper: number;
  level: number;
}

export interface ConfidenceFactor {
  factor: string;
  impact: 'positive' | 'negative' | 'neutral';
  magnitude: number;
  description: string;
}

export interface ConfidenceValidation {
  method: string;
  results: ValidationResult[];
  accuracy: number;
  reliability: number;
}

export interface ValidationResult {
  test: string;
  result: boolean;
  details: string;
}

export interface DistributionParameter {
  parameter: string;
  value: number;
  description: string;
}

export interface DistributionStatistics {
  mean: number;
  median: number;
  mode: number;
  variance: number;
  skewness: number;
  kurtosis: number;
}

export interface Percentile {
  percentile: number;
  value: number;
}
