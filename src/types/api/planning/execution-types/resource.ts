/**
 * Resource Assignment and Management Types
 * 
 * Type definitions for resource assignment, allocation, performance tracking,
 * and optimization within execution planning.
 * 
 * Generated by CC - Claude Code
 */

export interface ResourceAssignment {
  id: string;
  elementId: string;
  resourceId: string;
  role: AssignmentRole;
  responsibility: AssignmentResponsibility[];
  allocation: AssignmentAllocation;
  timeline: AssignmentTimeline;
  skills: AssignmentSkill[];
  performance: AssignmentPerformance;
  cost: AssignmentCost;
  status: AssignmentStatus;
  constraints: AssignmentConstraint[];
  optimization: AssignmentOptimization;
  governance: AssignmentGovernance;
}

export interface AssignmentRole {
  role: string;
  level: string;
  category: 'primary' | 'secondary' | 'support' | 'advisory';
  authority: string[];
  responsibilities: string[];
  accountabilities: string[];
  competencies: string[];
  certification: RoleCertification[];
  development: RoleDevelopment;
}

export interface RoleCertification {
  certification: string;
  authority: string;
  level: string;
  expiry: string;
  renewal: string;
}

export interface RoleDevelopment {
  current_level: string;
  target_level: string;
  gaps: string[];
  development_plan: string[];
  timeline: string;
}

export interface AssignmentResponsibility {
  responsibility: string;
  description: string;
  scope: string;
  authority: string;
  accountability: string;
  measurement: string;
  reporting: ResponsibilityReporting;
  escalation: ResponsibilityEscalation;
}

export interface ResponsibilityReporting {
  frequency: string;
  format: string;
  recipients: string[];
  metrics: string[];
  escalation: string;
}

export interface ResponsibilityEscalation {
  triggers: string[];
  process: string;
  timeline: string;
  authority: string;
}

export interface AssignmentAllocation {
  percentage: number;
  hours: number;
  fte: number;
  startDate: string;
  endDate: string;
  pattern: AllocationPattern;
  flexibility: AllocationFlexibility;
  optimization: AllocationOptimization;
  constraints: AllocationConstraint[];
}

export interface AllocationPattern {
  type: 'continuous' | 'intermittent' | 'seasonal' | 'project_based';
  schedule: PatternSchedule[];
  variations: PatternVariation[];
  adjustments: PatternAdjustment[];
}

export interface PatternSchedule {
  period: string;
  allocation: number;
  hours: number;
  availability: string[];
  constraints: string[];
}

export interface PatternVariation {
  variation: string;
  trigger: string;
  adjustment: number;
  duration: string;
  approval: string;
}

export interface PatternAdjustment {
  adjustment: string;
  reason: string;
  impact: string;
  approval: string;
  communication: string;
}

export interface AllocationFlexibility {
  scalability: 'fixed' | 'limited' | 'moderate' | 'high';
  timing: 'rigid' | 'negotiable' | 'flexible';
  scope: 'narrow' | 'moderate' | 'broad';
  substitutability: 'none' | 'limited' | 'moderate' | 'high';
  conditions: FlexibilityCondition[];
}

export interface FlexibilityCondition {
  condition: string;
  impact: string;
  mitigation: string;
  approval: string;
}

export interface AllocationOptimization {
  opportunities: OptimizationOpportunity[];
  constraints: OptimizationConstraint[];
  methods: string[];
  tools: string[];
  benefits: OptimizationBenefit[];
}

export interface OptimizationOpportunity {
  opportunity: string;
  description: string;
  potential: string;
  effort: string;
  timeline: string;
  dependencies: string[];
}

export interface OptimizationConstraint {
  constraint: string;
  type: 'hard' | 'soft' | 'preference';
  impact: string;
  workaround: string;
  negotiability: string;
}

export interface OptimizationBenefit {
  benefit: string;
  type: 'cost' | 'time' | 'quality' | 'risk' | 'efficiency';
  quantification: string;
  realization: string;
  measurement: string;
}

export interface AllocationConstraint {
  constraint: string;
  type: 'availability' | 'skill' | 'location' | 'cost' | 'regulatory';
  description: string;
  impact: string;
  mitigation: string;
  flexibility: string;
  negotiability: string;
}

export interface AssignmentTimeline {
  phases: AssignmentPhase[];
  milestones: AssignmentMilestone[];
  dependencies: AssignmentDependency[];
  constraints: AssignmentConstraint[];
  buffers: AssignmentBuffer[];
  optimization: TimelineOptimization;
}

export interface AssignmentPhase {
  phase: string;
  startDate: string;
  endDate: string;
  allocation: number;
  activities: string[];
  deliverables: string[];
  milestones: string[];
  risks: string[];
}

export interface AssignmentMilestone {
  milestone: string;
  date: string;
  type: 'start' | 'delivery' | 'review' | 'decision' | 'completion';
  criteria: string[];
  dependencies: string[];
  stakeholders: string[];
}

export interface AssignmentDependency {
  dependency: string;
  type: 'predecessor' | 'successor' | 'parallel' | 'resource' | 'approval';
  description: string;
  impact: string;
  mitigation: string;
  status: 'pending' | 'active' | 'satisfied' | 'blocked';
}

export interface AssignmentConstraint {
  constraint: string;
  category: 'temporal' | 'resource' | 'skill' | 'location' | 'regulatory';
  description: string;
  impact: string;
  workaround: string;
  escalation: string;
}

export interface AssignmentBuffer {
  type: 'time' | 'resource' | 'skill' | 'cost';
  amount: number;
  rationale: string;
  triggers: string[];
  governance: string;
}

export interface TimelineOptimization {
  acceleration: AccelerationOption[];
  parallelization: ParallelizationOption[];
  resource_leveling: ResourceLevelingOption[];
  critical_path: CriticalPathOptimization;
}

export interface AccelerationOption {
  option: string;
  method: string;
  impact: string;
  cost: string;
  risk: string;
  feasibility: string;
}

export interface ParallelizationOption {
  activities: string[];
  dependencies: string[];
  resource_impact: string;
  coordination: string;
  risk: string;
}

export interface ResourceLevelingOption {
  scenario: string;
  smoothing: string;
  impact: string;
  trade_offs: string[];
  benefits: string[];
}

export interface CriticalPathOptimization {
  current_path: string[];
  alternatives: string[];
  bottlenecks: string[];
  acceleration: string[];
  risks: string[];
}

export interface AssignmentSkill {
  skill: string;
  category: 'technical' | 'functional' | 'behavioral' | 'leadership';
  level: 'beginner' | 'intermediate' | 'advanced' | 'expert';
  required: boolean;
  critical: boolean;
  development: boolean;
  certification: string;
  proficiency: SkillProficiency;
  development_plan: SkillDevelopment;
}

export interface SkillProficiency {
  current_level: string;
  required_level: string;
  gap: string;
  evidence: string[];
  assessment: string;
  validation: string;
}

export interface SkillDevelopment {
  approach: string[];
  timeline: string;
  resources: string[];
  measurement: string;
  validation: string;
}

export interface AssignmentPerformance {
  metrics: PerformanceMetric[];
  targets: PerformanceTarget[];
  measurement: PerformanceMeasurement;
  feedback: PerformanceFeedback;
  improvement: PerformanceImprovement;
  recognition: PerformanceRecognition;
}

export interface PerformanceMetric {
  metric: string;
  category: 'productivity' | 'quality' | 'efficiency' | 'collaboration';
  description: string;
  calculation: string;
  frequency: string;
  target: number;
  threshold: number;
}

export interface PerformanceTarget {
  target: string;
  value: number;
  period: string;
  measurement: string;
  rationale: string;
  adjustability: string;
}

export interface PerformanceMeasurement {
  methods: string[];
  tools: string[];
  frequency: string;
  automation: string;
  validation: string;
  reporting: string;
}

export interface PerformanceFeedback {
  sources: string[];
  frequency: string;
  methods: string[];
  processing: string;
  response: string;
  improvement: string;
}

export interface PerformanceImprovement {
  identification: string;
  planning: string[];
  implementation: string;
  monitoring: string;
  evaluation: string;
}

export interface PerformanceRecognition {
  criteria: string[];
  methods: string[];
  frequency: string;
  impact: string;
  communication: string;
}

export interface AssignmentCost {
  rate: number;
  total: number;
  currency: string;
  billing: BillingModel;
  tracking: CostTracking;
  optimization: CostOptimization;
  governance: CostGovernance;
}

export interface BillingModel {
  type: 'hourly' | 'daily' | 'monthly' | 'fixed' | 'milestone' | 'outcome';
  structure: BillingStructure;
  terms: BillingTerms;
  adjustments: BillingAdjustment[];
}

export interface BillingStructure {
  base_rate: number;
  premium_rate: number;
  overtime_rate: number;
  holiday_rate: number;
  escalation: number;
}

export interface BillingTerms {
  payment_schedule: string;
  payment_terms: string;
  invoicing: string;
  approval: string;
  penalties: string[];
}

export interface BillingAdjustment {
  adjustment: string;
  reason: string;
  amount: number;
  period: string;
  approval: string;
}

export interface CostTracking {
  methods: string[];
  frequency: string;
  approval: string;
  reconciliation: string;
  reporting: string;
  alerts: CostAlert[];
}

export interface CostAlert {
  alert: string;
  threshold: number;
  frequency: string;
  recipients: string[];
  escalation: string;
}

export interface CostOptimization {
  opportunities: string[];
  strategies: string[];
  implementation: string;
  measurement: string;
  governance: string;
}

export interface CostGovernance {
  approval_limits: ApprovalLimit[];
  oversight: string;
  audit: string;
  compliance: string;
  reporting: string;
}

export interface ApprovalLimit {
  level: string;
  limit: number;
  scope: string[];
  escalation: string;
}

export interface AssignmentStatus {
  current: 'planned' | 'confirmed' | 'active' | 'paused' | 'completed' | 'cancelled';
  health: 'green' | 'amber' | 'red';
  progress: number;
  issues: string[];
  risks: string[];
  forecast: StatusForecast;
  transitions: StatusTransition[];
}

export interface StatusForecast {
  completion: string;
  confidence: number;
  scenarios: ForecastScenario[];
  assumptions: string[];
  risks: string[];
}

export interface ForecastScenario {
  scenario: string;
  probability: number;
  completion: string;
  impact: string;
  mitigation: string;
}

export interface StatusTransition {
  from: string;
  to: string;
  date: string;
  reason: string;
  approval: string;
  impact: string;
}

export interface AssignmentOptimization {
  scope: OptimizationScope;
  objectives: OptimizationObjective[];
  constraints: OptimizationConstraint[];
  methods: OptimizationMethod[];
  implementation: OptimizationImplementation;
  monitoring: OptimizationMonitoring;
}

export interface OptimizationScope {
  dimensions: string[];
  boundaries: string[];
  inclusions: string[];
  exclusions: string[];
  priorities: string[];
}

export interface OptimizationObjective {
  objective: string;
  type: 'maximize' | 'minimize' | 'target';
  priority: 'high' | 'medium' | 'low';
  measurement: string;
  target: number;
  weight: number;
}

export interface OptimizationMethod {
  method: string;
  approach: string;
  tools: string[];
  applicability: string[];
  limitations: string[];
  effectiveness: string;
}

export interface OptimizationImplementation {
  phases: string[];
  activities: string[];
  timeline: string;
  resources: string[];
  governance: string;
}

export interface OptimizationMonitoring {
  metrics: string[];
  frequency: string;
  methods: string[];
  reporting: string;
  adjustment: string;
}

export interface AssignmentGovernance {
  framework: GovernanceFramework;
  oversight: GovernanceOversight;
  approval: GovernanceApproval;
  change_control: GovernanceChangeControl;
  compliance: GovernanceCompliance;
  reporting: GovernanceReporting;
}

export interface GovernanceFramework {
  model: string;
  principles: string[];
  policies: string[];
  procedures: string[];
  standards: string[];
}

export interface GovernanceOversight {
  body: string;
  responsibilities: string[];
  authority: string[];
  frequency: string;
  escalation: string;
}

export interface GovernanceApproval {
  levels: string[];
  criteria: string[];
  process: string;
  timeline: string;
  appeals: string;
}

export interface GovernanceChangeControl {
  process: string;
  approval: string;
  impact_assessment: string;
  implementation: string;
  communication: string;
}

export interface GovernanceCompliance {
  requirements: string[];
  monitoring: string;
  assessment: string;
  reporting: string;
  remediation: string;
}

export interface GovernanceReporting {
  frequency: string;
  format: string[];
  recipients: string[];
  escalation: string;
  retention: string;
}