/**
 * Work Breakdown Structure Types
 * 
 * Type definitions for work breakdown structure, hierarchical decomposition,
 * element management, and structural validation within execution planning.
 * 
 * Generated by CC - Claude Code
 */

export interface WorkBreakdownStructure {
  levels: WBSLevel[];
  structure: WBSStructure;
  elements: WBSElement[];
  relationships: WBSRelationship[];
  hierarchy: WBSHierarchy;
  decomposition: WBSDecomposition;
  integration: WBSIntegration;
  validation: WBSValidation;
  governance: WBSGovernance;
  evolution: WBSEvolution;
}

export interface WBSLevel {
  level: number;
  name: string;
  description: string;
  purpose: string;
  decomposition: string;
  aggregation: string;
  governance: string;
  criteria: LevelCriteria;
  rules: LevelRule[];
  validation: LevelValidation;
}

export interface LevelCriteria {
  completeness: string[];
  consistency: string[];
  granularity: string;
  measurability: string[];
  manageability: string[];
}

export interface LevelRule {
  rule: string;
  description: string;
  application: string[];
  validation: string;
  exceptions: string[];
}

export interface LevelValidation {
  checks: string[];
  criteria: string[];
  methods: string[];
  frequency: string;
  reporting: string;
}

export interface WBSStructure {
  rootElement: string;
  branches: WBSBranch[];
  leaves: WBSLeaf[];
  depth: number;
  breadth: number;
  complexity: number;
  characteristics: StructureCharacteristics;
  design: StructureDesign;
  metrics: StructureMetric[];
}

export interface StructureCharacteristics {
  type: 'deliverable' | 'functional' | 'organizational' | 'phase' | 'hybrid';
  symmetry: 'balanced' | 'unbalanced' | 'mixed';
  granularity: 'coarse' | 'medium' | 'fine' | 'variable';
  consistency: 'uniform' | 'variable' | 'adaptive';
}

export interface StructureDesign {
  principles: string[];
  patterns: string[];
  constraints: string[];
  optimization: string[];
  trade_offs: string[];
}

export interface StructureMetric {
  metric: string;
  value: number;
  target: number;
  threshold: number;
  trend: string;
}

export interface WBSBranch {
  id: string;
  parent: string;
  children: string[];
  depth: number;
  complexity: number;
  span: number;
  characteristics: BranchCharacteristics;
  decomposition: BranchDecomposition;
  integration: BranchIntegration;
}

export interface BranchCharacteristics {
  type: string;
  scope: string;
  responsibility: string;
  authority: string;
  coordination: string;
}

export interface BranchDecomposition {
  criteria: string[];
  method: string;
  rationale: string;
  validation: string;
  completeness: string;
}

export interface BranchIntegration {
  dependencies: string[];
  interfaces: string[];
  coordination: string;
  aggregation: string;
  reporting: string;
}

export interface WBSLeaf {
  id: string;
  parent: string;
  level: number;
  effort: number;
  duration: number;
  resources: string[];
  deliverables: string[];
  characteristics: LeafCharacteristics;
  definition: LeafDefinition;
  estimation: LeafEstimation;
}

export interface LeafCharacteristics {
  type: 'work_package' | 'activity' | 'task' | 'milestone';
  assignability: boolean;
  measurability: boolean;
  independence: string;
  granularity: string;
}

export interface LeafDefinition {
  scope: string[];
  objectives: string[];
  deliverables: string[];
  acceptance: string[];
  assumptions: string[];
  constraints: string[];
}

export interface LeafEstimation {
  method: string;
  confidence: number;
  assumptions: string[];
  risks: string[];
  validation: string;
}

export interface WBSElement {
  id: string;
  code: string;
  name: string;
  description: string;
  level: number;
  parent: string;
  children: string[];
  type: 'workstream' | 'activity' | 'task' | 'deliverable' | 'milestone';
  scope: ElementScope;
  effort: ElementEffort;
  duration: ElementDuration;
  resources: ElementResource[];
  dependencies: ElementDependency[];
  risks: ElementRisk[];
  quality: ElementQuality;
  status: ElementStatus;
  ownership: ElementOwnership;
  governance: ElementGovernance;
}

export interface ElementScope {
  boundaries: string[];
  deliverables: string[];
  activities: string[];
  exclusions: string[];
  assumptions: string[];
  constraints: string[];
  interfaces: ScopeInterface[];
}

export interface ScopeInterface {
  interface: string;
  type: 'input' | 'output' | 'coordination' | 'dependency';
  description: string;
  counterpart: string;
  frequency: string;
  protocol: string;
}

export interface ElementEffort {
  estimate: number;
  unit: 'hours' | 'days' | 'weeks' | 'months' | 'story_points';
  confidence: number;
  method: string;
  assumptions: string[];
  risks: string[];
  validation: EffortValidation;
}

export interface EffortValidation {
  basis: string[];
  comparison: string[];
  expert_review: string;
  historical_data: string;
  adjustment: string;
}

export interface ElementDuration {
  estimate: number;
  unit: 'hours' | 'days' | 'weeks' | 'months';
  confidence: number;
  dependencies: string[];
  constraints: string[];
  buffers: DurationBuffer[];
  optimization: DurationOptimization;
}

export interface DurationBuffer {
  type: 'schedule' | 'resource' | 'scope' | 'quality';
  amount: number;
  rationale: string;
  conditions: string[];
  governance: string;
}

export interface DurationOptimization {
  opportunities: string[];
  techniques: string[];
  constraints: string[];
  trade_offs: string[];
  impact: string;
}

export interface ElementResource {
  resourceId: string;
  type: 'human' | 'equipment' | 'material' | 'facility' | 'service';
  role: string;
  allocation: number;
  duration: number;
  skills: string[];
  availability: ResourceAvailability;
  cost: ResourceCost;
  performance: ResourcePerformance;
}

export interface ResourceAvailability {
  total: number;
  allocated: number;
  available: number;
  conflicts: AvailabilityConflict[];
  constraints: string[];
}

export interface AvailabilityConflict {
  conflict: string;
  period: string;
  impact: string;
  resolution: string;
  priority: string;
}

export interface ResourceCost {
  rate: number;
  total: number;
  currency: string;
  model: 'hourly' | 'daily' | 'monthly' | 'fixed' | 'variable';
  escalation: number;
}

export interface ResourcePerformance {
  productivity: number;
  quality: number;
  efficiency: number;
  utilization: number;
  trends: PerformanceTrend[];
}

export interface PerformanceTrend {
  metric: string;
  period: string;
  value: number;
  direction: 'improving' | 'stable' | 'declining';
}

export interface ElementDependency {
  dependencyId: string;
  type: 'finish_to_start' | 'start_to_start' | 'finish_to_finish' | 'start_to_finish';
  description: string;
  predecessor: string;
  successor: string;
  lag: number;
  lead: number;
  criticality: 'low' | 'medium' | 'high' | 'critical';
  impact: string;
  mitigation: string;
  status: DependencyStatus;
}

export interface DependencyStatus {
  current: 'pending' | 'active' | 'satisfied' | 'blocked' | 'cancelled';
  health: 'green' | 'amber' | 'red';
  issues: string[];
  actions: string[];
  escalation: string;
}

export interface ElementRisk {
  riskId: string;
  category: 'technical' | 'resource' | 'schedule' | 'scope' | 'quality' | 'external';
  description: string;
  probability: number;
  impact: number;
  riskScore: number;
  mitigation: string;
  contingency: string;
  owner: string;
  status: 'open' | 'mitigated' | 'closed' | 'realized';
  monitoring: RiskMonitoring;
}

export interface RiskMonitoring {
  indicators: string[];
  thresholds: RiskThreshold[];
  frequency: string;
  methods: string[];
  escalation: string;
}

export interface RiskThreshold {
  indicator: string;
  threshold: number;
  action: string;
  escalation: string;
}

export interface ElementQuality {
  standards: string[];
  criteria: string[];
  reviews: string[];
  testing: string[];
  acceptance: QualityAcceptance;
  assurance: QualityAssurance;
  metrics: QualityMetric[];
}

export interface QualityAcceptance {
  criteria: string[];
  methods: string[];
  stakeholders: string[];
  process: string;
  documentation: string;
}

export interface QualityAssurance {
  framework: string;
  processes: string[];
  controls: string[];
  audits: string[];
  improvement: string;
}

export interface QualityMetric {
  metric: string;
  target: number;
  threshold: number;
  measurement: string;
  frequency: string;
}

export interface ElementStatus {
  current: 'not_started' | 'in_progress' | 'completed' | 'on_hold' | 'cancelled';
  progress: number;
  health: 'green' | 'amber' | 'red';
  issues: string[];
  milestones: ElementMilestone[];
  forecast: StatusForecast;
}

export interface ElementMilestone {
  milestone: string;
  date: string;
  status: 'pending' | 'achieved' | 'missed' | 'at_risk';
  criteria: string[];
  evidence: string;
}

export interface StatusForecast {
  completion: string;
  confidence: number;
  risks: string[];
  assumptions: string[];
  scenarios: ForecastScenario[];
}

export interface ForecastScenario {
  scenario: string;
  probability: number;
  completion: string;
  impact: string;
}

export interface ElementOwnership {
  owner: string;
  accountable: string;
  responsible: string[];
  consulted: string[];
  informed: string[];
  decision_rights: string[];
  escalation: string;
}

export interface ElementGovernance {
  oversight: string;
  reporting: string;
  approval: string;
  change_control: string;
  quality_gates: string[];
  compliance: string;
}

export interface WBSRelationship {
  id: string;
  parent: string;
  child: string;
  type: 'decomposition' | 'dependency' | 'association' | 'aggregation' | 'interface';
  strength: 'weak' | 'medium' | 'strong';
  direction: 'one_way' | 'two_way';
  description: string;
  characteristics: RelationshipCharacteristics;
  management: RelationshipManagement;
  validation: RelationshipValidation;
}

export interface RelationshipCharacteristics {
  nature: string;
  frequency: string;
  formality: 'informal' | 'semi_formal' | 'formal';
  criticality: 'low' | 'medium' | 'high' | 'critical';
  stability: 'stable' | 'evolving' | 'volatile';
}

export interface RelationshipManagement {
  coordination: string;
  communication: string;
  monitoring: string;
  escalation: string;
  optimization: string;
}

export interface RelationshipValidation {
  consistency: string;
  completeness: string;
  accuracy: string;
  relevance: string;
  currency: string;
}

export interface WBSHierarchy {
  tree: HierarchyNode[];
  paths: HierarchyPath[];
  rules: HierarchyRule[];
  validation: HierarchyValidation;
  navigation: HierarchyNavigation;
  visualization: HierarchyVisualization;
}

export interface HierarchyNode {
  id: string;
  name: string;
  level: number;
  parent: string;
  children: string[];
  position: NodePosition;
  attributes: NodeAttribute[];
  metadata: NodeMetadata;
}

export interface NodePosition {
  sequence: number;
  coordinates: number[];
  grouping: string;
  classification: string;
}

export interface NodeAttribute {
  attribute: string;
  value: any;
  type: string;
  source: string;
  currency: string;
}

export interface NodeMetadata {
  created: string;
  modified: string;
  version: string;
  source: string;
  owner: string;
}

export interface HierarchyPath {
  path: string[];
  length: number;
  type: 'critical' | 'alternative' | 'optional';
  characteristics: PathCharacteristics;
  analysis: PathAnalysis;
}

export interface PathCharacteristics {
  complexity: number;
  risk: number;
  value: number;
  priority: string;
  constraints: string[];
}

export interface PathAnalysis {
  bottlenecks: string[];
  optimization: string[];
  alternatives: string[];
  dependencies: string[];
  risks: string[];
}

export interface HierarchyRule {
  rule: string;
  description: string;
  type: 'structural' | 'behavioral' | 'data' | 'business';
  enforcement: string;
  validation: string;
  exceptions: RuleException[];
}

export interface RuleException {
  exception: string;
  conditions: string[];
  approval: string;
  documentation: string;
  monitoring: string;
}

export interface HierarchyValidation {
  method: string;
  criteria: string[];
  results: ValidationResult[];
  frequency: string;
  automation: string;
  reporting: string;
}

export interface ValidationResult {
  test: string;
  result: boolean;
  details: string;
  recommendations: string[];
  severity: 'info' | 'warning' | 'error' | 'critical';
}

export interface HierarchyNavigation {
  methods: string[];
  interfaces: string[];
  shortcuts: string[];
  search: string[];
  filtering: string[];
}

export interface HierarchyVisualization {
  formats: string[];
  layouts: string[];
  styling: string[];
  interactivity: string[];
  export: string[];
}

export interface WBSDecomposition {
  criteria: DecompositionCriteria[];
  methods: DecompositionMethod[];
  rules: DecompositionRule[];
  validation: DecompositionValidation;
  automation: DecompositionAutomation;
  optimization: DecompositionOptimization;
}

export interface DecompositionCriteria {
  criteria: string;
  description: string;
  application: string[];
  priority: 'mandatory' | 'recommended' | 'optional';
  measurement: string;
  validation: string;
}

export interface DecompositionMethod {
  method: string;
  description: string;
  applicability: string[];
  advantages: string[];
  limitations: string[];
  implementation: MethodImplementation;
}

export interface MethodImplementation {
  steps: string[];
  tools: string[];
  skills: string[];
  effort: string;
  risks: string[];
}

export interface DecompositionRule {
  rule: string;
  description: string;
  scope: string[];
  enforcement: string;
  validation: string;
  exceptions: string[];
}

export interface DecompositionValidation {
  method: string;
  criteria: string[];
  results: ValidationResult[];
  automation: string;
  reporting: string;
}

export interface DecompositionAutomation {
  tools: string[];
  algorithms: string[];
  triggers: string[];
  validation: string;
  human_oversight: string;
}

export interface DecompositionOptimization {
  objectives: string[];
  constraints: string[];
  methods: string[];
  metrics: string[];
  trade_offs: string[];
}

export interface WBSIntegration {
  scope: IntegrationScope;
  methods: IntegrationMethod[];
  interfaces: IntegrationInterface[];
  synchronization: IntegrationSynchronization;
  validation: IntegrationValidation;
  governance: IntegrationGovernance;
}

export interface IntegrationScope {
  systems: string[];
  processes: string[];
  data: string[];
  stakeholders: string[];
  boundaries: string[];
}

export interface IntegrationMethod {
  method: string;
  approach: string;
  tools: string[];
  protocols: string[];
  standards: string[];
}

export interface IntegrationInterface {
  interface: string;
  type: 'API' | 'file' | 'database' | 'message' | 'service';
  protocol: string;
  format: string;
  frequency: string;
  security: string;
}

export interface IntegrationSynchronization {
  strategy: string;
  frequency: string;
  triggers: string[];
  validation: string;
  conflict_resolution: string;
}

export interface IntegrationValidation {
  testing: string;
  monitoring: string;
  alerting: string;
  reconciliation: string;
  reporting: string;
}

export interface IntegrationGovernance {
  ownership: string;
  standards: string[];
  approval: string;
  change_control: string;
  compliance: string;
}

export interface WBSValidation {
  framework: ValidationFramework;
  rules: ValidationRule[];
  processes: ValidationProcess[];
  automation: ValidationAutomation;
  reporting: ValidationReporting;
  improvement: ValidationImprovement;
}

export interface ValidationFramework {
  model: string;
  principles: string[];
  standards: string[];
  coverage: string[];
  frequency: string;
}

export interface ValidationRule {
  rule: string;
  category: 'completeness' | 'consistency' | 'correctness' | 'compliance';
  description: string;
  logic: string;
  severity: 'info' | 'warning' | 'error' | 'critical';
  remediation: string;
}

export interface ValidationProcess {
  process: string;
  steps: ProcessStep[];
  roles: string[];
  tools: string[];
  outputs: string[];
}

export interface ProcessStep {
  step: string;
  inputs: string[];
  activities: string[];
  outputs: string[];
  validation: string;
}

export interface ValidationAutomation {
  coverage: number;
  tools: string[];
  triggers: string[];
  scheduling: string;
  escalation: string;
}

export interface ValidationReporting {
  formats: string[];
  frequency: string;
  distribution: string[];
  escalation: string;
  retention: string;
}

export interface ValidationImprovement {
  feedback: string;
  analysis: string;
  enhancement: string;
  implementation: string;
  monitoring: string;
}

export interface WBSGovernance {
  framework: GovernanceFramework;
  ownership: GovernanceOwnership;
  processes: GovernanceProcess[];
  controls: GovernanceControl[];
  compliance: GovernanceCompliance;
  improvement: GovernanceImprovement;
}

export interface GovernanceFramework {
  model: string;
  principles: string[];
  policies: string[];
  standards: string[];
  procedures: string[];
}

export interface GovernanceOwnership {
  steward: string;
  custodians: string[];
  users: string[];
  approvers: string[];
  escalation: string;
}

export interface GovernanceProcess {
  process: string;
  purpose: string;
  inputs: string[];
  activities: string[];
  outputs: string[];
  controls: string[];
}

export interface GovernanceControl {
  control: string;
  type: 'preventive' | 'detective' | 'corrective';
  objective: string;
  implementation: string;
  testing: string;
}

export interface GovernanceCompliance {
  requirements: string[];
  assessment: string;
  monitoring: string;
  reporting: string;
  remediation: string;
}

export interface GovernanceImprovement {
  maturity: string;
  assessment: string;
  roadmap: string;
  implementation: string;
  measurement: string;
}

export interface WBSEvolution {
  lifecycle: EvolutionLifecycle;
  change_management: EvolutionChangeManagement;
  versioning: EvolutionVersioning;
  migration: EvolutionMigration;
  retirement: EvolutionRetirement;
}

export interface EvolutionLifecycle {
  phases: LifecyclePhase[];
  transitions: LifecycleTransition[];
  governance: string;
  triggers: string[];
}

export interface LifecyclePhase {
  phase: string;
  objectives: string[];
  activities: string[];
  outputs: string[];
  criteria: string[];
}

export interface LifecycleTransition {
  from: string;
  to: string;
  triggers: string[];
  conditions: string[];
  approval: string;
  communication: string;
}

export interface EvolutionChangeManagement {
  process: string;
  impact_assessment: string;
  approval: string;
  implementation: string;
  communication: string;
  monitoring: string;
}

export interface EvolutionVersioning {
  strategy: string;
  numbering: string;
  branching: string;
  tagging: string;
  documentation: string;
}

export interface EvolutionMigration {
  planning: string;
  execution: string;
  validation: string;
  rollback: string;
  communication: string;
}

export interface EvolutionRetirement {
  criteria: string[];
  process: string;
  archival: string;
  cleanup: string;
  communication: string;
}