/**
 * Cost Planning Core Models
 * 
 * Core data structures for cost planning including plan data,
 * scope, methodology, models, categories, elements, and constraints.
 * 
 * Generated by CC - Claude Code
 */

// Forward declarations for types from other modules
export interface CostEstimate {}
export interface CostBreakdown {}
export interface CostTimelineResult {}
export interface CostScenarioResult {}
export interface CostOptimization {}
export interface CostBenchmark {}
export interface CostRecommendation {}

// Core Data Types
export interface CostPlanData {
  id: string;
  name: string;
  description: string;
  scope: CostScope;
  methodology: CostMethodology;
  model: CostModel;
  timeline: CostTimeline;
  categories: CostCategory[];
  elements: CostElement[];
  assumptions: CostAssumption[];
  constraints: CostConstraint[];
  scenarios: CostScenario[];
  currency: CostCurrency;
  escalation: CostEscalation;
  contingency: CostContingency;
  metadata: Record<string, any>;
}

export interface CostPlanResult {
  id: string;
  costPlanData: CostPlanData;
  totalCost: number;
  totalBudget: number;
  variance: number;
  accuracy: number;
  confidence: number;
  riskAdjustment: number;
  breakdown: CostBreakdown;
  timeline: CostTimelineResult;
  scenarios: CostScenarioResult[];
  optimization: CostOptimization;
  benchmarks: CostBenchmark[];
  recommendations: CostRecommendation[];
}

export interface CostScope {
  domains: CostDomain[];
  workstreams: string[];
  phases: string[];
  deliverables: string[];
  resources: string[];
  geography: string[];
  timeframe: {
    start: string;
    end: string;
  };
  inclusions: string[];
  exclusions: string[];
}

export interface CostMethodology {
  approach: 'bottom_up' | 'top_down' | 'analogous' | 'parametric' | 'three_point' | 'hybrid';
  techniques: CostTechnique[];
  standards: CostStandard[];
  tools: CostTool[];
  validation: CostValidation;
  review: CostReview;
  approval: CostApproval;
}

export interface CostModel {
  type: 'deterministic' | 'probabilistic' | 'simulation' | 'machine_learning';
  structure: ModelStructure;
  parameters: ModelParameter[];
  relationships: ModelRelationship[];
  algorithms: ModelAlgorithm[];
  calibration: ModelCalibration;
  validation: ModelValidation;
}

export interface CostTimeline {
  duration: number;
  periods: CostPeriod[];
  milestones: CostMilestone[];
  phases: CostPhase[];
  dependencies: CostDependency[];
  cashflow: CashFlow[];
  funding: FundingSchedule[];
}

export interface CostCategory {
  id: string;
  name: string;
  description: string;
  type: 'capital' | 'operational' | 'one_time' | 'recurring' | 'contingency';
  subcategories: CostSubcategory[];
  allocation: CategoryAllocation;
  rules: CategoryRule[];
  ownership: CategoryOwnership;
  tracking: CategoryTracking;
}

export interface CostElement {
  id: string;
  name: string;
  description: string;
  category: string;
  subcategory: string;
  type: ElementType;
  unit: CostUnit;
  quantity: ElementQuantity;
  rate: ElementRate;
  cost: ElementCost;
  timing: ElementTiming;
  dependencies: string[];
  assumptions: string[];
  risks: ElementRisk[];
}

export interface CostAssumption {
  id: string;
  description: string;
  category: string;
  value: any;
  confidence: number;
  impact: AssumptionImpact;
  validation: AssumptionValidation;
  sensitivity: number;
  owner: string;
  dependencies: string[];
}

export interface CostConstraint {
  id: string;
  type: 'budget' | 'timeline' | 'resource' | 'regulatory' | 'contractual';
  description: string;
  value: any;
  flexibility: 'fixed' | 'flexible' | 'negotiable';
  impact: ConstraintImpact;
  workaround: string;
  escalation: string;
}

export interface CostScenario {
  id: string;
  name: string;
  description: string;
  type: 'optimistic' | 'pessimistic' | 'most_likely' | 'stress' | 'custom';
  probability: number;
  assumptions: ScenarioAssumption[];
  parameters: ScenarioParameter[];
  results: ScenarioResult[];
  comparison: ScenarioComparison;
}

export interface CostCurrency {
  primary: string;
  secondary: string[];
  exchangeRates: ExchangeRate[];
  hedging: CurrencyHedging;
  riskManagement: CurrencyRisk;
}

export interface CostEscalation {
  enabled: boolean;
  method: 'simple' | 'compound' | 'variable' | 'indexed';
  rate: EscalationRate[];
  factors: EscalationFactor[];
  adjustment: EscalationAdjustment[];
}

export interface CostContingency {
  enabled: boolean;
  method: 'percentage' | 'absolute' | 'risk_based' | 'scenario_based';
  level: ContingencyLevel[];
  allocation: ContingencyAllocation[];
  triggers: ContingencyTrigger[];
  governance: ContingencyGovernance;
}

// Supporting Detail Types for Core Models
export interface CostDomain {
  name: string;
  description: string;
  scope: string[];
  ownership: string;
  allocation: number;
  tracking: string;
}

export interface CostTechnique {
  name: string;
  type: string;
  applicability: string[];
  accuracy: number;
  confidence: number;
  effort: string;
}

export interface CostStandard {
  name: string;
  version: string;
  scope: string[];
  compliance: boolean;
  certification: string;
}

export interface CostTool {
  name: string;
  type: string;
  capabilities: string[];
  integration: string[];
  licensing: string;
}

export interface CostValidation {
  method: string[];
  criteria: string[];
  frequency: string;
  responsibility: string;
  documentation: string;
}

export interface CostReview {
  frequency: string;
  participants: string[];
  agenda: string[];
  criteria: string[];
  documentation: string;
}

export interface CostApproval {
  levels: ApprovalLevel[];
  thresholds: ApprovalThreshold[];
  authority: ApprovalAuthority[];
  process: ApprovalProcess;
  documentation: string;
}

// Model Structure Types
export interface ModelStructure {
  hierarchy: StructureLevel[];
  components: StructureComponent[];
  relationships: StructureRelationship[];
  constraints: StructureConstraint[];
}

export interface ModelParameter {
  name: string;
  type: 'input' | 'output' | 'calculated' | 'derived';
  value: any;
  distribution: ParameterDistribution;
  sensitivity: number;
  uncertainty: number;
}

export interface ModelRelationship {
  from: string;
  to: string;
  type: 'causal' | 'correlational' | 'functional' | 'conditional';
  strength: number;
  formula: string;
}

export interface ModelAlgorithm {
  name: string;
  type: string;
  purpose: string;
  parameters: AlgorithmParameter[];
  performance: AlgorithmPerformance;
}

export interface ModelCalibration {
  method: string;
  data: CalibrationData[];
  metrics: CalibrationMetric[];
  validation: CalibrationValidation;
  frequency: string;
}

export interface ModelValidation {
  method: string[];
  criteria: ValidationCriteria[];
  results: ValidationResult[];
  confidence: number;
  limitations: string[];
}

// Core Category and Element Types
export interface CostSubcategory {
  id: string;
  name: string;
  description: string;
  allocation: number;
  rules: string[];
  tracking: string;
}

export interface CategoryAllocation {
  method: 'direct' | 'proportional' | 'activity_based' | 'driver_based';
  basis: string;
  percentage: number;
  drivers: AllocationDriver[];
}

export interface CategoryRule {
  rule: string;
  condition: string;
  action: string;
  priority: number;
}

export interface CategoryOwnership {
  owner: string;
  accountable: string;
  responsible: string[];
  consulted: string[];
  informed: string[];
}

export interface CategoryTracking {
  method: string;
  frequency: string;
  metrics: string[];
  reporting: string;
  alerts: string[];
}

export interface ElementType {
  type: 'labor' | 'material' | 'equipment' | 'service' | 'license' | 'overhead';
  subtype: string;
  characteristics: string[];
  estimation: string;
}

export interface CostUnit {
  unit: string;
  description: string;
  conversion: UnitConversion[];
  standard: boolean;
}

export interface ElementQuantity {
  base: number;
  adjustment: QuantityAdjustment[];
  total: number;
  confidence: number;
  source: string;
}

export interface ElementRate {
  base: number;
  adjustment: RateAdjustment[];
  total: number;
  currency: string;
  escalation: number;
  confidence: number;
}

export interface ElementCost {
  base: number;
  adjustments: CostAdjustment[];
  total: number;
  currency: string;
  confidence: number;
  risk: number;
}

export interface ElementTiming {
  start: string;
  end: string;
  duration: number;
  distribution: TimingDistribution;
  dependencies: string[];
}

export interface ElementRisk {
  risk: string;
  probability: number;
  impact: number;
  mitigation: string;
  contingency: number;
}

// Assumption and Constraint Supporting Types
export interface AssumptionImpact {
  scope: 'element' | 'category' | 'phase' | 'total';
  magnitude: 'low' | 'medium' | 'high' | 'critical';
  direction: 'increase' | 'decrease' | 'neutral';
  quantification: number;
}

export interface AssumptionValidation {
  method: string;
  frequency: string;
  source: string;
  criteria: string[];
  status: string;
}

export interface ConstraintImpact {
  scope: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  cost: number;
  timeline: string;
  mitigation: string;
}

// Scenario Supporting Types
export interface ScenarioAssumption {
  assumption: string;
  value: any;
  rationale: string;
  confidence: number;
}

export interface ScenarioParameter {
  parameter: string;
  baseValue: any;
  scenarioValue: any;
  variance: number;
  impact: string;
}

export interface ScenarioResult {
  metric: string;
  value: number;
  variance: number;
  confidence: number;
  ranking: number;
}

export interface ScenarioComparison {
  baseline: string;
  comparison: ComparisonResult[];
  variance: ComparisonVariance[];
  ranking: ComparisonRanking[];
}

// Currency and Financial Types
export interface ExchangeRate {
  from: string;
  to: string;
  rate: number;
  date: string;
  source: string;
}

export interface CurrencyHedging {
  strategy: string;
  instruments: HedgingInstrument[];
  coverage: number;
  cost: number;
  effectiveness: number;
}

export interface CurrencyRisk {
  exposure: CurrencyExposure[];
  volatility: CurrencyVolatility;
  hedging: CurrencyHedging;
  monitoring: CurrencyMonitoring;
}

export interface EscalationRate {
  category: string;
  rate: number;
  period: string;
  source: string;
  confidence: number;
}

export interface EscalationFactor {
  factor: string;
  impact: number;
  variability: number;
  source: string;
}

export interface EscalationAdjustment {
  type: string;
  value: number;
  rationale: string;
  approval: string;
}

export interface ContingencyLevel {
  category: string;
  percentage: number;
  amount: number;
  rationale: string;
  approval: string;
}

export interface ContingencyAllocation {
  method: string;
  basis: string;
  distribution: AllocationDistribution[];
  rules: AllocationRule[];
}

export interface ContingencyTrigger {
  event: string;
  condition: string;
  threshold: number;
  action: string;
  approval: string;
}

export interface ContingencyGovernance {
  authority: string;
  approval: string;
  reporting: string;
  monitoring: string;
  escalation: string;
}

// Forward declaration supporting types that will be defined in utility module
export interface AllocationDriver {}
export interface UnitConversion {}
export interface QuantityAdjustment {}
export interface RateAdjustment {}
export interface CostAdjustment {}
export interface TimingDistribution {}
export interface ComparisonResult {}
export interface ComparisonVariance {}
export interface ComparisonRanking {}
export interface HedgingInstrument {}
export interface CurrencyExposure {}
export interface CurrencyVolatility {}
export interface CurrencyMonitoring {}
export interface AllocationDistribution {}
export interface AllocationRule {}
export interface ApprovalLevel {}
export interface ApprovalThreshold {}
export interface ApprovalAuthority {}
export interface ApprovalProcess {}
export interface StructureLevel {}
export interface StructureComponent {}
export interface StructureRelationship {}
export interface StructureConstraint {}
export interface ParameterDistribution {}
export interface AlgorithmParameter {}
export interface AlgorithmPerformance {}
export interface CalibrationData {}
export interface CalibrationMetric {}
export interface CalibrationValidation {}
export interface ValidationCriteria {}
export interface ValidationResult {}