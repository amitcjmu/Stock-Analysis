/**
 * Resource Planning Types
 * 
 * Type definitions for resource planning, allocation, and optimization.
 * Covers resource requirements, skills management, utilization analysis,
 * and resource optimization functionality.
 * 
 * Generated by CC - Claude Code
 */

import {
  BaseApiRequest,
  BaseApiResponse,
  MultiTenantContext,
  CreateRequest,
  CreateResponse,
  GetRequest,
  GetResponse
} from '../shared';

// Resource Planning APIs
export interface CreateResourcePlanRequest extends CreateRequest<ResourcePlanData> {
  flowId: string;
  timelineId?: string;
  data: ResourcePlanData;
  resourceTypes: ResourceType[];
  skillRequirements: SkillRequirement[];
  availabilityConstraints: AvailabilityConstraint[];
  budgetConstraints: BudgetConstraint[];
  includeOptimization?: boolean;
  includeSkillsGapAnalysis?: boolean;
}

export interface CreateResourcePlanResponse extends CreateResponse<ResourcePlanResult> {
  data: ResourcePlanResult;
  resourcePlanId: string;
  optimization?: ResourceOptimization;
  skillsGapAnalysis?: SkillsGapAnalysis;
  costProjection: CostProjection;
  feasibilityAssessment: ResourceFeasibility;
}

export interface GetResourcePlanRequest extends GetRequest {
  resourcePlanId: string;
  includeUtilization?: boolean;
  includeSkillsAnalysis?: boolean;
  includeCostAnalysis?: boolean;
  includeOptimization?: boolean;
  timeRange?: {
    start: string;
    end: string;
  };
}

export interface GetResourcePlanResponse extends GetResponse<ResourcePlanResult> {
  data: ResourcePlanResult;
  utilizationAnalysis: UtilizationAnalysis;
  skillsAnalysis: SkillsAnalysis;
  costAnalysis: ResourceCostAnalysis;
  optimizationOpportunities: OptimizationOpportunity[];
}

export interface OptimizeResourceAllocationRequest extends BaseApiRequest {
  resourcePlanId: string;
  optimizationCriteria: OptimizationCriteria[];
  constraints: OptimizationConstraint[];
  objectives: OptimizationObjective[];
  algorithm?: 'genetic' | 'simulated_annealing' | 'linear_programming' | 'heuristic';
  context: MultiTenantContext;
}

export interface OptimizeResourceAllocationResponse extends BaseApiResponse<ResourceOptimizationResult> {
  data: ResourceOptimizationResult;
  optimizedPlan: ResourcePlanResult;
  improvements: OptimizationImprovement[];
  scenarios: OptimizationScenario[];
}

// Core Data Types
export interface ResourcePlanData {
  id: string;
  name: string;
  description: string;
  scope: ResourceScope;
  duration: ResourceDuration;
  requirements: ResourceRequirement[];
  allocations: ResourceAllocation[];
  teams: ResourceTeam[];
  skills: SkillMatrix;
  budget: ResourceBudget;
  constraints: ResourceConstraint[];
  assumptions: ResourceAssumption[];
  policies: ResourcePolicy[];
  metadata: Record<string, any>;
}

export interface ResourcePlanResult {
  id: string;
  resourcePlanData: ResourcePlanData;
  feasibilityScore: number;
  utilizationScore: number;
  costEfficiency: number;
  skillsCoverage: number;
  riskScore: number;
  alternatives: ResourceAlternative[];
  recommendations: ResourceRecommendation[];
  gaps: ResourceGap[];
  conflicts: ResourceConflict[];
}

export interface ResourceScope {
  phases: string[];
  workstreams: string[];
  locations: string[];
  departments: string[];
  vendors: string[];
  timeframe: {
    start: string;
    end: string;
  };
  budget: {
    total: number;
    allocated: number;
    currency: string;
  };
}

export interface ResourceDuration {
  totalDuration: number;
  workingDays: number;
  phases: PhaseDuration[];
  milestones: string[];
  buffers: DurationBuffer[];
}

export interface ResourceRequirement {
  id: string;
  name: string;
  type: ResourceType;
  category: 'human' | 'technical' | 'physical' | 'financial';
  quantity: number;
  duration: number;
  effort: number;
  skills: RequiredSkill[];
  availability: AvailabilityRequirement;
  cost: CostRequirement;
  location: LocationRequirement;
  timing: TimingRequirement;
  flexibility: FlexibilityOptions;
  alternatives: AlternativeResource[];
}

export interface ResourceAllocation {
  id: string;
  resourceId: string;
  requirementId: string;
  allocation: number;
  startDate: string;
  endDate: string;
  effort: number;
  cost: number;
  role: string;
  responsibilities: string[];
  deliverables: string[];
  dependencies: string[];
  constraints: AllocationConstraint[];
  status: 'planned' | 'confirmed' | 'active' | 'completed' | 'cancelled';
}

export interface ResourceTeam {
  id: string;
  name: string;
  type: 'internal' | 'external' | 'hybrid';
  size: number;
  lead: TeamMember;
  members: TeamMember[];
  skills: TeamSkill[];
  capacity: TeamCapacity;
  cost: TeamCost;
  performance: TeamPerformance;
  availability: TeamAvailability[];
  location: TeamLocation;
}

export interface SkillMatrix {
  skills: Skill[];
  levels: SkillLevel[];
  requirements: SkillMatrixEntry[];
  availability: SkillAvailability[];
  gaps: SkillGap[];
  development: SkillDevelopment[];
}

export interface ResourceBudget {
  totalBudget: number;
  allocated: number;
  remaining: number;
  currency: string;
  categories: BudgetCategory[];
  reserves: BudgetReserve[];
  forecasts: BudgetForecast[];
  variances: BudgetVariance[];
}

// Resource Types and Categories
export interface ResourceType {
  id: string;
  name: string;
  category: 'human' | 'technical' | 'physical' | 'financial';
  subcategory: string;
  description: string;
  unit: string;
  rateType: 'hourly' | 'daily' | 'weekly' | 'monthly' | 'fixed';
  skillsRequired: string[];
  availability: TypeAvailability;
  cost: TypeCost;
  substitutes: string[];
}

export interface SkillRequirement {
  skill: string;
  level: 'beginner' | 'intermediate' | 'advanced' | 'expert';
  criticality: 'nice_to_have' | 'important' | 'required' | 'critical';
  quantity: number;
  duration: number;
  certification?: string;
  experience?: number;
  alternatives: string[];
  development: SkillDevelopmentOption[];
}

export interface AvailabilityConstraint {
  id: string;
  type: 'time' | 'location' | 'skill' | 'capacity' | 'contract';
  resourceId?: string;
  resourceType?: string;
  description: string;
  startDate?: string;
  endDate?: string;
  impact: 'low' | 'medium' | 'high' | 'critical';
  workaround?: string;
  cost?: number;
}

export interface BudgetConstraint {
  id: string;
  type: 'total' | 'category' | 'period' | 'resource' | 'vendor';
  category?: string;
  limit: number;
  period?: string;
  currency: string;
  flexibility: 'fixed' | 'flexible' | 'negotiable';
  approval: string;
  escalation: string;
}

// Analysis and Optimization Types
export interface ResourceOptimization {
  currentState: OptimizationState;
  optimizedState: OptimizationState;
  improvements: OptimizationMetric[];
  recommendations: OptimizationAction[];
  scenarios: OptimizationScenario[];
  tradeoffs: OptimizationTradeoff[];
}

export interface SkillsGapAnalysis {
  currentSkills: SkillInventory[];
  requiredSkills: SkillRequirement[];
  gaps: SkillGap[];
  surpluses: SkillSurplus[];
  development: SkillDevelopmentPlan[];
  acquisition: SkillAcquisitionPlan[];
  timeline: SkillTimeline[];
}

export interface CostProjection {
  totalCost: number;
  breakdown: CostBreakdown[];
  periods: PeriodCost[];
  scenarios: CostScenario[];
  risks: CostRisk[];
  optimizations: CostOptimization[];
  benchmarks: CostBenchmark[];
}

export interface ResourceFeasibility {
  overallFeasibility: 'high' | 'medium' | 'low' | 'not_feasible';
  availabilityFeasibility: AvailabilityFeasibility;
  skillsFeasibility: SkillsFeasibility;
  costFeasibility: CostFeasibility;
  timingFeasibility: TimingFeasibility;
  constraints: FeasibilityConstraint[];
  recommendations: FeasibilityRecommendation[];
}

export interface UtilizationAnalysis {
  overallUtilization: number;
  byResource: ResourceUtilization[];
  bySkill: SkillUtilization[];
  byPeriod: PeriodUtilization[];
  byLocation: LocationUtilization[];
  trends: UtilizationTrend[];
  projections: UtilizationProjection[];
}

export interface SkillsAnalysis {
  coverage: SkillCoverage[];
  gaps: SkillGap[];
  redundancy: SkillRedundancy[];
  development: SkillDevelopmentNeeds[];
  risks: SkillRisk[];
  opportunities: SkillOpportunity[];
}

export interface ResourceCostAnalysis {
  totalCost: number;
  costPerResource: ResourceCostDetail[];
  costPerSkill: SkillCostDetail[];
  costPerPeriod: PeriodCostDetail[];
  variances: CostVariance[];
  trends: CostTrend[];
  benchmarks: CostBenchmark[];
}

export interface OptimizationOpportunity {
  type: 'utilization' | 'cost' | 'skill' | 'timing' | 'allocation';
  description: string;
  impact: OpportunityImpact;
  effort: OpportunityEffort;
  feasibility: string;
  timeline: string;
  dependencies: string[];
  risks: string[];
}

// Supporting Detail Types
export interface PhaseDuration {
  phaseId: string;
  duration: number;
  startDate: string;
  endDate: string;
  resources: number;
}

export interface DurationBuffer {
  type: 'contingency' | 'management' | 'technical';
  percentage: number;
  days: number;
  rationale: string;
}

export interface RequiredSkill {
  skill: string;
  level: string;
  criticality: string;
  alternatives: string[];
}

export interface AvailabilityRequirement {
  startDate: string;
  endDate: string;
  allocation: number;
  flexibility: FlexibilityLevel;
  constraints: string[];
}

export interface CostRequirement {
  budgetCategory: string;
  maxCost: number;
  preferredCost: number;
  currency: string;
  billable: boolean;
}

export interface LocationRequirement {
  type: 'onsite' | 'remote' | 'hybrid';
  location?: string;
  timezone?: string;
  travelRequired?: boolean;
  flexibility: FlexibilityLevel;
}

export interface TimingRequirement {
  earliestStart: string;
  latestStart: string;
  earliestFinish: string;
  latestFinish: string;
  flexibility: FlexibilityLevel;
}

export interface FlexibilityOptions {
  schedule: FlexibilityLevel;
  location: FlexibilityLevel;
  scope: FlexibilityLevel;
  quality: FlexibilityLevel;
  cost: FlexibilityLevel;
}

export interface AlternativeResource {
  resourceId: string;
  resourceType: string;
  suitability: number;
  cost: number;
  availability: string;
  risks: string[];
}

export interface AllocationConstraint {
  type: string;
  description: string;
  impact: string;
  workaround?: string;
}

export interface TeamMember {
  id: string;
  name: string;
  role: string;
  level: string;
  skills: MemberSkill[];
  availability: number;
  cost: number;
  location: string;
  performance: MemberPerformance;
}

export interface TeamSkill {
  skill: string;
  level: string;
  count: number;
  availability: number;
  development: boolean;
}

export interface TeamCapacity {
  totalCapacity: number;
  availableCapacity: number;
  allocatedCapacity: number;
  efficiency: number;
  utilization: number;
}

export interface TeamCost {
  totalCost: number;
  costPerMember: number;
  overhead: number;
  currency: string;
  model: string;
}

export interface TeamPerformance {
  productivity: number;
  quality: number;
  velocity: number;
  satisfaction: number;
  retention: number;
}

export interface TeamAvailability {
  startDate: string;
  endDate: string;
  capacity: number;
  members: number;
}

export interface TeamLocation {
  primary: string;
  secondary: string[];
  distributed: boolean;
  timezone: string;
}

export interface Skill {
  id: string;
  name: string;
  category: string;
  description: string;
  level: SkillLevel[];
  certifications: string[];
  alternatives: string[];
}

export interface SkillLevel {
  level: string;
  name: string;
  description: string;
  experience: number;
  capabilities: string[];
  assessment: string;
}

export interface SkillMatrixEntry {
  skill: string;
  level: string;
  required: number;
  available: number;
  gap: number;
  priority: string;
}

export interface SkillAvailability {
  skill: string;
  level: string;
  available: number;
  allocated: number;
  remaining: number;
  cost: number;
}

export interface SkillGap {
  skill: string;
  level: string;
  required: number;
  available: number;
  gap: number;
  impact: 'low' | 'medium' | 'high' | 'critical';
  options: GapResolutionOption[];
}

export interface SkillDevelopment {
  skill: string;
  currentLevel: string;
  targetLevel: string;
  method: 'training' | 'mentoring' | 'certification' | 'experience';
  duration: number;
  cost: number;
  success: number;
}

export interface BudgetCategory {
  category: string;
  allocated: number;
  spent: number;
  committed: number;
  remaining: number;
  variance: number;
}

export interface BudgetReserve {
  type: 'contingency' | 'management' | 'change';
  amount: number;
  used: number;
  remaining: number;
  trigger: string;
}

export interface BudgetForecast {
  period: string;
  forecast: number;
  confidence: number;
  assumptions: string[];
  risks: string[];
}

export interface BudgetVariance {
  category: string;
  budgeted: number;
  actual: number;
  variance: number;
  percentage: number;
  explanation: string;
}

export interface TypeAvailability {
  total: number;
  available: number;
  allocated: number;
  utilization: number;
  constraints: string[];
}

export interface TypeCost {
  standard: number;
  minimum: number;
  maximum: number;
  currency: string;
  factors: CostFactor[];
}

export interface CostFactor {
  factor: string;
  impact: number;
  description: string;
}

export interface SkillDevelopmentOption {
  method: string;
  duration: number;
  cost: number;
  success: number;
  provider: string;
}

// Optimization Supporting Types
export interface OptimizationCriteria {
  criterion: string;
  weight: number;
  target: 'minimize' | 'maximize';
  constraint?: any;
  priority: string;
}

export interface OptimizationConstraint {
  type: string;
  description: string;
  value: any;
  flexibility: FlexibilityLevel;
  violation: string;
}

export interface OptimizationObjective {
  objective: string;
  weight: number;
  measure: string;
  target: number;
  current: number;
}

export interface ResourceOptimizationResult {
  algorithm: string;
  iterations: number;
  improvement: number;
  confidence: number;
  recommendations: OptimizationRecommendation[];
  alternatives: OptimizationAlternative[];
  tradeoffs: OptimizationTradeoff[];
}

export interface OptimizationImprovement {
  aspect: string;
  current: number;
  optimized: number;
  improvement: number;
  percentage: number;
  impact: string;
}

export interface OptimizationScenario {
  id: string;
  name: string;
  description: string;
  assumptions: string[];
  results: OptimizationResult[];
  recommendation: string;
}

export interface OptimizationState {
  utilization: number;
  cost: number;
  efficiency: number;
  satisfaction: number;
  risk: number;
  metrics: StateMetric[];
}

export interface OptimizationMetric {
  metric: string;
  current: number;
  optimized: number;
  improvement: number;
  unit: string;
}

export interface OptimizationAction {
  action: string;
  description: string;
  impact: string;
  effort: string;
  cost: number;
  timeline: string;
  dependencies: string[];
}

export interface OptimizationTradeoff {
  aspect1: string;
  aspect2: string;
  relationship: 'positive' | 'negative' | 'neutral';
  magnitude: number;
  impact: string;
  recommendation: string;
}

export interface SkillInventory {
  resourceId: string;
  skill: string;
  level: string;
  certified: boolean;
  experience: number;
  availability: number;
}

export interface SkillSurplus {
  skill: string;
  level: string;
  surplus: number;
  utilization: number;
  redeployment: RedeploymentOption[];
}

export interface SkillDevelopmentPlan {
  resourceId: string;
  skill: string;
  currentLevel: string;
  targetLevel: string;
  plan: DevelopmentPlan;
  timeline: string;
  cost: number;
}

export interface SkillAcquisitionPlan {
  skill: string;
  level: string;
  quantity: number;
  method: 'hire' | 'contract' | 'train' | 'outsource';
  timeline: string;
  cost: number;
  success: number;
}

export interface SkillTimeline {
  period: string;
  required: SkillRequirement[];
  available: SkillAvailability[];
  gaps: SkillGap[];
  actions: SkillAction[];
}

export interface CostBreakdown {
  category: string;
  amount: number;
  percentage: number;
  variance: number;
  trend: string;
}

export interface PeriodCost {
  period: string;
  startDate: string;
  endDate: string;
  cost: number;
  cumulative: number;
  budget: number;
  variance: number;
}

export interface CostScenario {
  scenario: string;
  cost: number;
  probability: number;
  assumptions: string[];
  impact: string;
}

export interface CostRisk {
  risk: string;
  probability: number;
  impact: number;
  cost: number;
  mitigation: string;
}

export interface CostOptimization {
  opportunity: string;
  saving: number;
  effort: string;
  risk: string;
  timeline: string;
}

export interface CostBenchmark {
  metric: string;
  value: number;
  benchmark: number;
  variance: number;
  industry: string;
}

// Feasibility Supporting Types
export interface AvailabilityFeasibility {
  score: number;
  resourceAvailability: number;
  skillAvailability: number;
  locationAvailability: number;
  timeAvailability: number;
  constraints: number;
}

export interface SkillsFeasibility {
  score: number;
  skillCoverage: number;
  skillGaps: number;
  developmentTime: number;
  acquisitionTime: number;
  cost: number;
}

export interface CostFeasibility {
  score: number;
  budgetFit: number;
  costVariance: number;
  fundingRisk: number;
  marketRates: number;
  contingency: number;
}

export interface TimingFeasibility {
  score: number;
  scheduleAlignment: number;
  availabilityAlignment: number;
  dependencyRisk: number;
  bufferAdequacy: number;
  flexibility: number;
}

export interface FeasibilityConstraint {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  impact: string;
  mitigation: string;
}

export interface FeasibilityRecommendation {
  type: string;
  description: string;
  impact: string;
  effort: string;
  timeline: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
}

// Utilization Supporting Types
export interface ResourceUtilization {
  resourceId: string;
  resourceName: string;
  type: string;
  utilization: number;
  capacity: number;
  allocated: number;
  efficiency: number;
  cost: number;
  performance: number;
}

export interface SkillUtilization {
  skill: string;
  level: string;
  utilization: number;
  demand: number;
  supply: number;
  cost: number;
  premium: number;
}

export interface PeriodUtilization {
  period: string;
  utilization: number;
  capacity: number;
  demand: number;
  variance: number;
  trend: string;
}

export interface LocationUtilization {
  location: string;
  utilization: number;
  capacity: number;
  cost: number;
  efficiency: number;
  satisfaction: number;
}

export interface UtilizationTrend {
  metric: string;
  trend: 'increasing' | 'decreasing' | 'stable';
  rate: number;
  confidence: number;
  factors: string[];
}

export interface UtilizationProjection {
  period: string;
  projected: number;
  confidence: number;
  assumptions: string[];
  risks: string[];
}

export interface SkillCoverage {
  skill: string;
  level: string;
  coverage: number;
  required: number;
  available: number;
  redundancy: number;
}

export interface SkillRedundancy {
  skill: string;
  level: string;
  redundancy: number;
  utilization: number;
  cost: number;
  optimization: string;
}

export interface SkillDevelopmentNeeds {
  skill: string;
  level: string;
  need: number;
  urgency: 'low' | 'medium' | 'high' | 'critical';
  method: string;
  timeline: string;
}

export interface SkillRisk {
  skill: string;
  risk: string;
  probability: number;
  impact: number;
  mitigation: string;
  contingency: string;
}

export interface SkillOpportunity {
  skill: string;
  opportunity: string;
  benefit: string;
  effort: string;
  timeline: string;
  investment: number;
}

export interface ResourceCostDetail {
  resourceId: string;
  resourceName: string;
  type: string;
  cost: number;
  rate: number;
  utilization: number;
  efficiency: number;
  variance: number;
}

export interface SkillCostDetail {
  skill: string;
  level: string;
  cost: number;
  rate: number;
  premium: number;
  demand: number;
  supply: number;
}

export interface PeriodCostDetail {
  period: string;
  cost: number;
  budget: number;
  variance: number;
  trend: string;
  forecast: number;
}

export interface CostVariance {
  category: string;
  budgeted: number;
  actual: number;
  variance: number;
  percentage: number;
  explanation: string;
  trend: string;
}

export interface CostTrend {
  metric: string;
  trend: 'increasing' | 'decreasing' | 'stable';
  rate: number;
  confidence: number;
  factors: string[];
}

export interface OpportunityImpact {
  financial: number;
  operational: string;
  strategic: string;
  risk: string;
  timeline: string;
}

export interface OpportunityEffort {
  complexity: 'low' | 'medium' | 'high' | 'very_high';
  duration: number;
  resources: number;
  cost: number;
  skills: string[];
}

// Additional Supporting Types
export interface FlexibilityLevel {
  level: 'fixed' | 'limited' | 'moderate' | 'high' | 'very_high';
  description: string;
  constraints: string[];
  options: string[];
}

export interface MemberSkill {
  skill: string;
  level: string;
  certified: boolean;
  experience: number;
  proficiency: number;
}

export interface MemberPerformance {
  productivity: number;
  quality: number;
  reliability: number;
  collaboration: number;
  adaptability: number;
}

export interface GapResolutionOption {
  option: 'hire' | 'train' | 'contract' | 'outsource' | 'reallocate';
  cost: number;
  timeline: string;
  risk: string;
  feasibility: string;
  impact: string;
}

export interface RedeploymentOption {
  opportunity: string;
  utilization: number;
  benefit: string;
  effort: string;
  timeline: string;
}

export interface DevelopmentPlan {
  method: string;
  duration: number;
  milestones: string[];
  resources: string[];
  cost: number;
  success: number;
}

export interface SkillAction {
  action: 'develop' | 'acquire' | 'reallocate' | 'outsource';
  skill: string;
  quantity: number;
  timeline: string;
  cost: number;
  risk: string;
}

export interface OptimizationResult {
  metric: string;
  value: number;
  improvement: number;
  confidence: number;
}

export interface OptimizationRecommendation {
  recommendation: string;
  description: string;
  impact: string;
  effort: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  timeline: string;
}

export interface OptimizationAlternative {
  alternative: string;
  description: string;
  cost: number;
  benefit: string;
  risk: string;
  feasibility: string;
}

export interface StateMetric {
  metric: string;
  value: number;
  unit: string;
  trend: string;
  benchmark: number;
}

export interface ResourceConflict {
  type: 'availability' | 'skill' | 'location' | 'cost' | 'priority';
  resources: string[];
  description: string;
  impact: 'low' | 'medium' | 'high' | 'critical';
  resolution: ConflictResolution[];
  timeline: string;
}

export interface ConflictResolution {
  option: string;
  description: string;
  impact: string;
  cost: number;
  feasibility: string;
  timeline: string;
}

export interface ResourceAlternative {
  id: string;
  name: string;
  description: string;
  cost: number;
  feasibility: string;
  advantages: string[];
  disadvantages: string[];
  recommendation: 'recommended' | 'viable' | 'not_recommended';
}

export interface ResourceRecommendation {
  type: string;
  description: string;
  rationale: string;
  impact: string;
  effort: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  timeline: string;
}

export interface ResourceGap {
  type: 'availability' | 'skill' | 'cost' | 'location' | 'timing';
  description: string;
  impact: 'low' | 'medium' | 'high' | 'critical';
  resolution: GapResolution[];
  timeline: string;
}

export interface GapResolution {
  option: string;
  description: string;
  cost: number;
  timeline: string;
  feasibility: string;
  risk: string;
}

export interface ResourceConstraint {
  id: string;
  type: string;
  description: string;
  impact: string;
  flexibility: FlexibilityLevel;
  mitigation: string;
}

export interface ResourceAssumption {
  id: string;
  description: string;
  confidence: number;
  impact: string;
  validation: string;
  owner: string;
}

export interface ResourcePolicy {
  id: string;
  name: string;
  description: string;
  type: string;
  rules: PolicyRule[];
  exceptions: PolicyException[];
  compliance: boolean;
}

export interface PolicyRule {
  rule: string;
  description: string;
  mandatory: boolean;
  penalty: string;
}

export interface PolicyException {
  condition: string;
  approval: string;
  documentation: string;
  review: string;
}